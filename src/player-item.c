/* player-item.c generated by valac, the Vala compiler
 * generated from player-item.vala, do not modify */

/*
Copyright 2010 Canonical Ltd.

Authors:
    Conor Curran <conor.curran@canonical.com>

This program is free software: you can redistribute it and/or modify it 
under the terms of the GNU General Public License version 3, as published 
by the Free Software Foundation.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranties of 
MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along 
with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <glib.h>
#include <glib-object.h>
#include <libdbusmenu-glib/client.h>
#include <libdbusmenu-glib/menuitem-proxy.h>
#include <libdbusmenu-glib/menuitem.h>
#include <libdbusmenu-glib/server.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>


#define TYPE_PLAYER_ITEM (player_item_get_type ())
#define PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_ITEM, PlayerItem))
#define PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_ITEM, PlayerItemClass))
#define IS_PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_ITEM))
#define IS_PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_ITEM))
#define PLAYER_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_ITEM, PlayerItemClass))

typedef struct _PlayerItem PlayerItem;
typedef struct _PlayerItemClass PlayerItemClass;
typedef struct _PlayerItemPrivate PlayerItemPrivate;

#define TYPE_MPRIS_CONTROLLER (mpris_controller_get_type ())
#define MPRIS_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS_CONTROLLER, MprisController))
#define MPRIS_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MPRIS_CONTROLLER, MprisControllerClass))
#define IS_MPRIS_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS_CONTROLLER))
#define IS_MPRIS_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MPRIS_CONTROLLER))
#define MPRIS_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MPRIS_CONTROLLER, MprisControllerClass))

typedef struct _MprisController MprisController;
typedef struct _MprisControllerClass MprisControllerClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

struct _PlayerItem {
	DbusmenuMenuitem parent_instance;
	PlayerItemPrivate * priv;
	MprisController* mpris_adaptor;
};

struct _PlayerItemClass {
	DbusmenuMenuitemClass parent_class;
	void (*check_layout) (PlayerItem* self);
};


static gpointer player_item_parent_class = NULL;

GType player_item_get_type (void);
GType mpris_controller_get_type (void);
enum  {
	PLAYER_ITEM_DUMMY_PROPERTY
};
PlayerItem* player_item_new (void);
PlayerItem* player_item_construct (GType object_type);
static gboolean player_item_ensure_valid_updates (GHashTable* data, GeeHashSet* attributes);
char* player_item_sanitize_string (const char* st);
void player_item_update (PlayerItem* self, GHashTable* data, GeeHashSet* attributes);
void player_item_set_adaptor (PlayerItem* self, MprisController* adaptor);
PlayerItem* player_item_new_title_item (const char* name);
PlayerItem* player_item_new_separator_item (void);
void player_item_check_layout (PlayerItem* self);
static void player_item_real_check_layout (PlayerItem* self);
static void player_item_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);



PlayerItem* player_item_construct (GType object_type) {
	PlayerItem * self;
	self = g_object_newv (object_type, 0, NULL);
	return self;
}


PlayerItem* player_item_new (void) {
	return player_item_construct (TYPE_PLAYER_ITEM);
}


void player_item_update (PlayerItem* self, GHashTable* data, GeeHashSet* attributes) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (data != NULL);
	g_return_if_fail (attributes != NULL);
	g_debug ("player-item.vala:33: PlayerItem::update()");
	if (player_item_ensure_valid_updates (data, attributes) == FALSE) {
		g_debug ("player-item.vala:35: PlayerItem::Update -> The hashtable update does n" \
"ot contain what we were expecting - just leave it!");
		return;
	}
	{
		GeeIterator* _property_it;
		_property_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) attributes);
		while (TRUE) {
			char* property;
			char** _tmp1_;
			gint _input_keys_size_;
			gint input_keys_length1;
			char** _tmp0_;
			char** input_keys;
			char** _tmp3_ = NULL;
			gint _tmp2_;
			char* search_key;
			GValue _tmp4_ = {0};
			GValue v;
			if (!gee_iterator_next (_property_it)) {
				break;
			}
			property = (char*) gee_iterator_get (_property_it);
			input_keys = (_tmp1_ = _tmp0_ = g_strsplit (property, "-", 0), input_keys_length1 = _vala_array_length (_tmp0_), _input_keys_size_ = input_keys_length1, _tmp1_);
			search_key = g_strdup ((_tmp3_ = input_keys + (input_keys_length1 - 1), _tmp2_ = input_keys_length1 - (input_keys_length1 - 1), _tmp3_)[0]);
			g_debug ("player-item.vala:41: search key = %s", search_key);
			v = G_IS_VALUE ((GValue*) g_hash_table_lookup (data, search_key)) ? (g_value_init (&_tmp4_, G_VALUE_TYPE ((GValue*) g_hash_table_lookup (data, search_key))), g_value_copy ((GValue*) g_hash_table_lookup (data, search_key), &_tmp4_), _tmp4_) : (*((GValue*) g_hash_table_lookup (data, search_key)));
			if (G_VALUE_HOLDS (&v, G_TYPE_STRING)) {
				char* _tmp5_;
				g_debug ("player-item.vala:44: with value : %s", g_value_get_string (&v));
				dbusmenu_menuitem_property_set ((DbusmenuMenuitem*) self, property, _tmp5_ = player_item_sanitize_string (g_value_get_string (&v)));
				_g_free0 (_tmp5_);
			} else {
				if (G_VALUE_HOLDS (&v, G_TYPE_INT)) {
					g_debug ("player-item.vala:48: with value : %i", g_value_get_int (&v));
					dbusmenu_menuitem_property_set_int ((DbusmenuMenuitem*) self, property, g_value_get_int (&v));
				} else {
					if (G_VALUE_HOLDS (&v, G_TYPE_BOOLEAN)) {
						dbusmenu_menuitem_property_set_bool ((DbusmenuMenuitem*) self, property, g_value_get_boolean (&v));
					}
				}
			}
			_g_free0 (property);
			input_keys = (_vala_array_free (input_keys, input_keys_length1, (GDestroyNotify) g_free), NULL);
			_g_free0 (search_key);
			G_IS_VALUE (&v) ? (g_value_unset (&v), NULL) : NULL;
		}
		_g_object_unref0 (_property_it);
	}
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void player_item_set_adaptor (PlayerItem* self, MprisController* adaptor) {
	MprisController* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (adaptor != NULL);
	self->mpris_adaptor = (_tmp0_ = _g_object_ref0 (adaptor), _g_object_unref0 (self->mpris_adaptor), _tmp0_);
}


static gboolean player_item_ensure_valid_updates (GHashTable* data, GeeHashSet* attributes) {
	gboolean result = FALSE;
	g_return_val_if_fail (data != NULL, FALSE);
	g_return_val_if_fail (attributes != NULL, FALSE);
	if (data == NULL) {
		result = FALSE;
		return result;
	}
	if (g_hash_table_size (data) < gee_collection_get_size ((GeeCollection*) attributes)) {
		g_warning ("player-item.vala:70: update hash was too small for the target");
		result = FALSE;
		return result;
	}
	result = TRUE;
	return result;
}


static char* string_strip (const char* self) {
	char* result = NULL;
	char* _result_;
	g_return_val_if_fail (self != NULL, NULL);
	_result_ = g_strdup (self);
	g_strstrip (_result_);
	result = _result_;
	return result;
}


static char* string_slice (const char* self, glong start, glong end) {
	char* result = NULL;
	glong string_length;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	const char* start_string;
	g_return_val_if_fail (self != NULL, NULL);
	string_length = g_utf8_strlen (self, -1);
	if (start < 0) {
		start = string_length + start;
	}
	if (end < 0) {
		end = string_length + end;
	}
	if (start >= 0) {
		_tmp0_ = start <= string_length;
	} else {
		_tmp0_ = FALSE;
	}
	g_return_val_if_fail (_tmp0_, NULL);
	if (end >= 0) {
		_tmp1_ = end <= string_length;
	} else {
		_tmp1_ = FALSE;
	}
	g_return_val_if_fail (_tmp1_, NULL);
	g_return_val_if_fail (start <= end, NULL);
	start_string = g_utf8_offset_to_pointer (self, start);
	result = g_strndup (start_string, ((gchar*) g_utf8_offset_to_pointer (start_string, end - start)) - ((gchar*) start_string));
	return result;
}


char* player_item_sanitize_string (const char* st) {
	char* result = NULL;
	char* _result_;
	g_return_val_if_fail (st != NULL, NULL);
	_result_ = string_strip (st);
	if (g_str_has_prefix (_result_, "file:///")) {
		char* _tmp0_;
		_result_ = (_tmp0_ = string_slice (_result_, (glong) 7, g_utf8_strlen (_result_, -1)), _g_free0 (_result_), _tmp0_);
	}
	g_debug ("player-item.vala:82: Sanitize string - result = %s", _result_);
	result = _result_;
	return result;
}


PlayerItem* player_item_new_title_item (const char* name) {
	PlayerItem* result = NULL;
	PlayerItem* item;
	g_return_val_if_fail (name != NULL, NULL);
	item = player_item_new ();
	dbusmenu_menuitem_property_set ((DbusmenuMenuitem*) item, DBUSMENU_MENUITEM_PROP_LABEL, name);
	dbusmenu_menuitem_property_set ((DbusmenuMenuitem*) item, DBUSMENU_MENUITEM_PROP_ICON_NAME, "applications-multimedia");
	result = item;
	return result;
}


PlayerItem* player_item_new_separator_item (void) {
	PlayerItem* result = NULL;
	PlayerItem* separator;
	separator = player_item_new ();
	dbusmenu_menuitem_property_set ((DbusmenuMenuitem*) separator, DBUSMENU_MENUITEM_PROP_TYPE, DBUSMENU_CLIENT_TYPES_SEPARATOR);
	result = separator;
	return result;
}


static void player_item_real_check_layout (PlayerItem* self) {
	g_return_if_fail (self != NULL);
	g_warning ("player-item.vala:106: this should not be hit");
}


void player_item_check_layout (PlayerItem* self) {
	PLAYER_ITEM_GET_CLASS (self)->check_layout (self);
}


static void player_item_class_init (PlayerItemClass * klass) {
	player_item_parent_class = g_type_class_peek_parent (klass);
	PLAYER_ITEM_CLASS (klass)->check_layout = player_item_real_check_layout;
	G_OBJECT_CLASS (klass)->finalize = player_item_finalize;
}


static void player_item_instance_init (PlayerItem * self) {
}


static void player_item_finalize (GObject* obj) {
	PlayerItem * self;
	self = PLAYER_ITEM (obj);
	_g_object_unref0 (self->mpris_adaptor);
	G_OBJECT_CLASS (player_item_parent_class)->finalize (obj);
}


GType player_item_get_type (void) {
	static volatile gsize player_item_type_id__volatile = 0;
	if (g_once_init_enter (&player_item_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (PlayerItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) player_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PlayerItem), 0, (GInstanceInitFunc) player_item_instance_init, NULL };
		GType player_item_type_id;
		player_item_type_id = g_type_register_static (DBUSMENU_TYPE_MENUITEM, "PlayerItem", &g_define_type_info, 0);
		g_once_init_leave (&player_item_type_id__volatile, player_item_type_id);
	}
	return player_item_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}




