/* player-item.c generated by valac, the Vala compiler
 * generated from player-item.vala, do not modify */

/*
Copyright 2010 Canonical Ltd.

Authors:
    Conor Curran <conor.curran@canonical.com>

This program is free software: you can redistribute it and/or modify it 
under the terms of the GNU General Public License version 3, as published 
by the Free Software Foundation.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranties of 
MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along 
with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <glib.h>
#include <glib-object.h>
#include <libdbusmenu-glib/client.h>
#include <libdbusmenu-glib/menuitem-proxy.h>
#include <libdbusmenu-glib/menuitem.h>
#include <libdbusmenu-glib/server.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>


#define TYPE_PLAYER_ITEM (player_item_get_type ())
#define PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_ITEM, PlayerItem))
#define PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_ITEM, PlayerItemClass))
#define IS_PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_ITEM))
#define IS_PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_ITEM))
#define PLAYER_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_ITEM, PlayerItemClass))

typedef struct _PlayerItem PlayerItem;
typedef struct _PlayerItemClass PlayerItemClass;
typedef struct _PlayerItemPrivate PlayerItemPrivate;

#define TYPE_PLAYER_CONTROLLER (player_controller_get_type ())
#define PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_CONTROLLER, PlayerController))
#define PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))
#define IS_PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_CONTROLLER))
#define IS_PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_CONTROLLER))
#define PLAYER_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))

typedef struct _PlayerController PlayerController;
typedef struct _PlayerControllerClass PlayerControllerClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

struct _PlayerItem {
	DbusmenuMenuitem parent_instance;
	PlayerItemPrivate * priv;
};

struct _PlayerItemClass {
	DbusmenuMenuitemClass parent_class;
};

struct _PlayerItemPrivate {
	PlayerController* _owner;
	char* _item_type;
};


static gpointer player_item_parent_class = NULL;

GType player_item_get_type (void);
GType player_controller_get_type (void);
#define PLAYER_ITEM_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_PLAYER_ITEM, PlayerItemPrivate))
enum  {
	PLAYER_ITEM_DUMMY_PROPERTY,
	PLAYER_ITEM_OWNER,
	PLAYER_ITEM_ITEM_TYPE
};
PlayerItem* player_item_new (const char* type);
PlayerItem* player_item_construct (GType object_type, const char* type);
void player_item_reset (PlayerItem* self, GeeHashSet* attrs);
static gboolean player_item_ensure_valid_updates (GHashTable* data, GeeHashSet* attributes);
static GValue* _g_value_dup (GValue* self);
char* player_item_sanitize_string (const char* st);
void player_item_update (PlayerItem* self, GHashTable* data, GeeHashSet* attributes);
PlayerController* player_item_get_owner (PlayerItem* self);
static void player_item_set_owner (PlayerItem* self, PlayerController* value);
const char* player_item_get_item_type (PlayerItem* self);
static void player_item_set_item_type (PlayerItem* self, const char* value);
static GObject * player_item_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void player_item_finalize (GObject* obj);
static void player_item_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void player_item_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);



PlayerItem* player_item_construct (GType object_type, const char* type) {
	PlayerItem * self;
	g_return_val_if_fail (type != NULL, NULL);
	self = (PlayerItem*) g_object_new (object_type, "item-type", type, NULL);
	return self;
}


PlayerItem* player_item_new (const char* type) {
	return player_item_construct (TYPE_PLAYER_ITEM, type);
}


void player_item_reset (PlayerItem* self, GeeHashSet* attrs) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (attrs != NULL);
	{
		GeeIterator* _s_it;
		_s_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) attrs);
		while (TRUE) {
			char* s;
			if (!gee_iterator_next (_s_it)) {
				break;
			}
			s = (char*) gee_iterator_get (_s_it);
			g_debug ("player-item.vala:39: attempting to set prop %s to null", s);
			dbusmenu_menuitem_property_set ((DbusmenuMenuitem*) self, s, NULL);
			_g_free0 (s);
		}
		_g_object_unref0 (_s_it);
	}
}


static GValue* _g_value_dup (GValue* self) {
	return g_boxed_copy (G_TYPE_VALUE, self);
}


static gpointer __g_value_dup0 (gpointer self) {
	return self ? _g_value_dup (self) : NULL;
}


void player_item_update (PlayerItem* self, GHashTable* data, GeeHashSet* attributes) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (data != NULL);
	g_return_if_fail (attributes != NULL);
	g_debug ("player-item.vala:46: PlayerItem::update()");
	if (player_item_ensure_valid_updates (data, attributes) == FALSE) {
		g_debug ("player-item.vala:48: PlayerItem::Update -> The hashtable update does n" \
"ot contain what we were expecting - just leave it!");
		return;
	}
	{
		GeeIterator* _property_it;
		_property_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) attributes);
		while (TRUE) {
			char* property;
			char** _tmp1_;
			gint _input_keys_size_;
			gint input_keys_length1;
			char** _tmp0_;
			char** input_keys;
			char** _tmp3_ = NULL;
			gint _tmp2_;
			char* search_key;
			GValue* v;
			if (!gee_iterator_next (_property_it)) {
				break;
			}
			property = (char*) gee_iterator_get (_property_it);
			input_keys = (_tmp1_ = _tmp0_ = g_strsplit (property, "-", 0), input_keys_length1 = _vala_array_length (_tmp0_), _input_keys_size_ = input_keys_length1, _tmp1_);
			search_key = g_strdup ((_tmp3_ = input_keys + (input_keys_length1 - 1), _tmp2_ = input_keys_length1 - (input_keys_length1 - 1), _tmp3_)[0]);
			g_debug ("player-item.vala:54: search key = %s", search_key);
			v = __g_value_dup0 ((GValue*) g_hash_table_lookup (data, search_key));
			if (G_VALUE_HOLDS (v, G_TYPE_STRING)) {
				char* _tmp4_;
				g_debug ("player-item.vala:58: with value : %s", g_value_get_string (v));
				dbusmenu_menuitem_property_set ((DbusmenuMenuitem*) self, property, _tmp4_ = player_item_sanitize_string (g_value_get_string (v)));
				_g_free0 (_tmp4_);
			} else {
				if (G_VALUE_HOLDS (v, G_TYPE_INT)) {
					g_debug ("player-item.vala:62: with value : %i", g_value_get_int (v));
					dbusmenu_menuitem_property_set_int ((DbusmenuMenuitem*) self, property, g_value_get_int (v));
				} else {
					if (G_VALUE_HOLDS (v, G_TYPE_BOOLEAN)) {
						dbusmenu_menuitem_property_set_bool ((DbusmenuMenuitem*) self, property, g_value_get_boolean (v));
					}
				}
			}
			_g_free0 (property);
			input_keys = (_vala_array_free (input_keys, input_keys_length1, (GDestroyNotify) g_free), NULL);
			_g_free0 (search_key);
			_g_free0 (v);
		}
		_g_object_unref0 (_property_it);
	}
}


static gboolean player_item_ensure_valid_updates (GHashTable* data, GeeHashSet* attributes) {
	gboolean result = FALSE;
	g_return_val_if_fail (data != NULL, FALSE);
	g_return_val_if_fail (attributes != NULL, FALSE);
	if (data == NULL) {
		result = FALSE;
		return result;
	}
	if (g_hash_table_size (data) < gee_collection_get_size ((GeeCollection*) attributes)) {
		g_warning ("player-item.vala:77: update hash was too small for the target");
		result = FALSE;
		return result;
	}
	result = TRUE;
	return result;
}


static char* string_strip (const char* self) {
	char* result = NULL;
	char* _result_;
	g_return_val_if_fail (self != NULL, NULL);
	_result_ = g_strdup (self);
	g_strstrip (_result_);
	result = _result_;
	return result;
}


static char* string_slice (const char* self, glong start, glong end) {
	char* result = NULL;
	glong string_length;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	const char* start_string;
	g_return_val_if_fail (self != NULL, NULL);
	string_length = g_utf8_strlen (self, -1);
	if (start < 0) {
		start = string_length + start;
	}
	if (end < 0) {
		end = string_length + end;
	}
	if (start >= 0) {
		_tmp0_ = start <= string_length;
	} else {
		_tmp0_ = FALSE;
	}
	g_return_val_if_fail (_tmp0_, NULL);
	if (end >= 0) {
		_tmp1_ = end <= string_length;
	} else {
		_tmp1_ = FALSE;
	}
	g_return_val_if_fail (_tmp1_, NULL);
	g_return_val_if_fail (start <= end, NULL);
	start_string = g_utf8_offset_to_pointer (self, start);
	result = g_strndup (start_string, ((gchar*) g_utf8_offset_to_pointer (start_string, end - start)) - ((gchar*) start_string));
	return result;
}


char* player_item_sanitize_string (const char* st) {
	char* result = NULL;
	char* _result_;
	g_return_val_if_fail (st != NULL, NULL);
	_result_ = string_strip (st);
	if (g_str_has_prefix (_result_, "file:///")) {
		char* _tmp0_;
		_result_ = (_tmp0_ = string_slice (_result_, (glong) 7, g_utf8_strlen (_result_, -1)), _g_free0 (_result_), _tmp0_);
	}
	g_debug ("player-item.vala:89: Sanitize string - result = %s", _result_);
	result = _result_;
	return result;
}


PlayerController* player_item_get_owner (PlayerItem* self) {
	PlayerController* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_owner;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void player_item_set_owner (PlayerItem* self, PlayerController* value) {
	PlayerController* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_owner = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_owner), _tmp0_);
	g_object_notify ((GObject *) self, "owner");
}


const char* player_item_get_item_type (PlayerItem* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_item_type;
	return result;
}


static void player_item_set_item_type (PlayerItem* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_item_type = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_item_type), _tmp0_);
	g_object_notify ((GObject *) self, "item-type");
}


static GObject * player_item_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	PlayerItem * self;
	parent_class = G_OBJECT_CLASS (player_item_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = PLAYER_ITEM (obj);
	{
		dbusmenu_menuitem_property_set ((DbusmenuMenuitem*) self, DBUSMENU_MENUITEM_PROP_TYPE, self->priv->_item_type);
	}
	return obj;
}


static void player_item_class_init (PlayerItemClass * klass) {
	player_item_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (PlayerItemPrivate));
	G_OBJECT_CLASS (klass)->get_property = player_item_get_property;
	G_OBJECT_CLASS (klass)->set_property = player_item_set_property;
	G_OBJECT_CLASS (klass)->constructor = player_item_constructor;
	G_OBJECT_CLASS (klass)->finalize = player_item_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLAYER_ITEM_OWNER, g_param_spec_object ("owner", "owner", "owner", TYPE_PLAYER_CONTROLLER, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLAYER_ITEM_ITEM_TYPE, g_param_spec_string ("item-type", "item-type", "item-type", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
}


static void player_item_instance_init (PlayerItem * self) {
	self->priv = PLAYER_ITEM_GET_PRIVATE (self);
}


static void player_item_finalize (GObject* obj) {
	PlayerItem * self;
	self = PLAYER_ITEM (obj);
	_g_object_unref0 (self->priv->_owner);
	_g_free0 (self->priv->_item_type);
	G_OBJECT_CLASS (player_item_parent_class)->finalize (obj);
}


GType player_item_get_type (void) {
	static volatile gsize player_item_type_id__volatile = 0;
	if (g_once_init_enter (&player_item_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (PlayerItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) player_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PlayerItem), 0, (GInstanceInitFunc) player_item_instance_init, NULL };
		GType player_item_type_id;
		player_item_type_id = g_type_register_static (DBUSMENU_TYPE_MENUITEM, "PlayerItem", &g_define_type_info, 0);
		g_once_init_leave (&player_item_type_id__volatile, player_item_type_id);
	}
	return player_item_type_id__volatile;
}


static void player_item_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	PlayerItem * self;
	self = PLAYER_ITEM (object);
	switch (property_id) {
		case PLAYER_ITEM_OWNER:
		g_value_set_object (value, player_item_get_owner (self));
		break;
		case PLAYER_ITEM_ITEM_TYPE:
		g_value_set_string (value, player_item_get_item_type (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void player_item_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	PlayerItem * self;
	self = PLAYER_ITEM (object);
	switch (property_id) {
		case PLAYER_ITEM_OWNER:
		player_item_set_owner (self, g_value_get_object (value));
		break;
		case PLAYER_ITEM_ITEM_TYPE:
		player_item_set_item_type (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}




