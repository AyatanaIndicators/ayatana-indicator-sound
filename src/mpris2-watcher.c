/* mpris2-watcher.c generated by valac 0.11.2, the Vala compiler
 * generated from mpris2-watcher.vala, do not modify */

/*
Copyright 2010 Canonical Ltd.

Authors:
    Conor Curran <conor.curran@canonical.com>

This program is free software: you can redistribute it and/or modify it 
under the terms of the GNU General Public License version 3, as published 
by the Free Software Foundation.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranties of 
MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along 
with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <glib.h>
#include <glib-object.h>
#include <gio/gio.h>
#include <stdlib.h>
#include <string.h>


#define TYPE_FREE_DESKTOP_OBJECT (free_desktop_object_get_type ())
#define FREE_DESKTOP_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FREE_DESKTOP_OBJECT, FreeDesktopObject))
#define IS_FREE_DESKTOP_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FREE_DESKTOP_OBJECT))
#define FREE_DESKTOP_OBJECT_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_FREE_DESKTOP_OBJECT, FreeDesktopObjectIface))

typedef struct _FreeDesktopObject FreeDesktopObject;
typedef struct _FreeDesktopObjectIface FreeDesktopObjectIface;

#define TYPE_FREE_DESKTOP_OBJECT_PROXY (free_desktop_object_proxy_get_type ())
typedef GDBusProxy FreeDesktopObjectProxy;
typedef GDBusProxyClass FreeDesktopObjectProxyClass;
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_MPRIS2_WATCHER (mpris2_watcher_get_type ())
#define MPRIS2_WATCHER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS2_WATCHER, Mpris2Watcher))
#define MPRIS2_WATCHER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MPRIS2_WATCHER, Mpris2WatcherClass))
#define IS_MPRIS2_WATCHER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS2_WATCHER))
#define IS_MPRIS2_WATCHER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MPRIS2_WATCHER))
#define MPRIS2_WATCHER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MPRIS2_WATCHER, Mpris2WatcherClass))

typedef struct _Mpris2Watcher Mpris2Watcher;
typedef struct _Mpris2WatcherClass Mpris2WatcherClass;
typedef struct _Mpris2WatcherPrivate Mpris2WatcherPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TYPE_MPRIS_ROOT (mpris_root_get_type ())
#define MPRIS_ROOT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS_ROOT, MprisRoot))
#define IS_MPRIS_ROOT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS_ROOT))
#define MPRIS_ROOT_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_MPRIS_ROOT, MprisRootIface))

typedef struct _MprisRoot MprisRoot;
typedef struct _MprisRootIface MprisRootIface;

#define TYPE_MPRIS_ROOT_PROXY (mpris_root_proxy_get_type ())
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _Mpris2WatcherCheckForActiveClientsData Mpris2WatcherCheckForActiveClientsData;

struct _FreeDesktopObjectIface {
	GTypeInterface parent_iface;
	void (*list_names) (FreeDesktopObject* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	gchar** (*list_names_finish) (FreeDesktopObject* self, GAsyncResult* _res_, int* result_length1, GError** error);
};

struct _Mpris2Watcher {
	GObject parent_instance;
	Mpris2WatcherPrivate * priv;
};

struct _Mpris2WatcherClass {
	GObjectClass parent_class;
};

struct _Mpris2WatcherPrivate {
	FreeDesktopObject* fdesktop_obj;
};

struct _MprisRootIface {
	GTypeInterface parent_iface;
	void (*Quit) (MprisRoot* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*Quit_finish) (MprisRoot* self, GAsyncResult* _res_, GError** error);
	void (*Raise) (MprisRoot* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*Raise_finish) (MprisRoot* self, GAsyncResult* _res_, GError** error);
	gboolean (*get_HasTracklist) (MprisRoot* self);
	void (*set_HasTracklist) (MprisRoot* self, gboolean value);
	gboolean (*get_CanQuit) (MprisRoot* self);
	void (*set_CanQuit) (MprisRoot* self, gboolean value);
	gboolean (*get_CanRaise) (MprisRoot* self);
	void (*set_CanRaise) (MprisRoot* self, gboolean value);
	gchar* (*get_Identity) (MprisRoot* self);
	void (*set_Identity) (MprisRoot* self, const gchar* value);
	gchar* (*get_DesktopEntry) (MprisRoot* self);
	void (*set_DesktopEntry) (MprisRoot* self, const gchar* value);
};

struct _Mpris2WatcherCheckForActiveClientsData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	Mpris2Watcher* self;
	gint interfaces_length1;
	gint _interfaces_size_;
	gchar** interfaces;
	gint _tmp0_;
	gchar** _tmp1_;
	gint _tmp2__length1;
	gint __tmp2__size_;
	gchar** _tmp3_;
	gchar** _tmp2_;
	gchar** _tmp4_;
	GError * e;
	gchar** address_collection;
	int address_collection_length1;
	int address_it;
	gchar* _tmp5_;
	gchar* address;
	gboolean _tmp6_;
	MprisRoot* _tmp7_;
	MprisRoot* mpris2_root;
	gchar* _tmp8_;
	gchar* _tmp9_;
	GError * _inner_error_;
};


static gpointer mpris2_watcher_parent_class = NULL;

GType free_desktop_object_proxy_get_type (void) G_GNUC_CONST;
guint free_desktop_object_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
GType free_desktop_object_get_type (void) G_GNUC_CONST;
void free_desktop_object_list_names (FreeDesktopObject* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
gchar** free_desktop_object_list_names_finish (FreeDesktopObject* self, GAsyncResult* _res_, int* result_length1, GError** error);
static void g_cclosure_user_marshal_VOID__STRING_STRING_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void free_desktop_object_proxy_g_signal (GDBusProxy* proxy, const gchar* sender_name, const gchar* signal_name, GVariant* parameters);
static void _dbus_handle_free_desktop_object_name_owner_changed (FreeDesktopObject* self, GVariant* parameters);
static void _vala_g_async_ready_callback (GObject *source_object, GAsyncResult *res, void *user_data);
static void free_desktop_object_proxy_list_names_async (FreeDesktopObject* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
static gchar** free_desktop_object_proxy_list_names_finish (FreeDesktopObject* self, GAsyncResult* _res_, int* result_length1, GError** error);
static void free_desktop_object_proxy_free_desktop_object_interface_init (FreeDesktopObjectIface* iface);
static void _dbus_free_desktop_object_list_names (FreeDesktopObject* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_free_desktop_object_list_names_ready (GObject * source_object, GAsyncResult * _res_, gpointer * _user_data_);
static void free_desktop_object_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data);
static GVariant* free_desktop_object_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data);
static gboolean free_desktop_object_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data);
static void _dbus_free_desktop_object_name_owner_changed (GObject* _sender, const gchar* name, const gchar* old_owner, const gchar* new_owner, gpointer* _data);
static void _free_desktop_object_unregister_object (gpointer user_data);
GType mpris2_watcher_get_type (void) G_GNUC_CONST;
#define MPRIS2_WATCHER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_MPRIS2_WATCHER, Mpris2WatcherPrivate))
enum  {
	MPRIS2_WATCHER_DUMMY_PROPERTY
};
#define MPRIS2_WATCHER_FREEDESKTOP_SERVICE "org.freedesktop.DBus"
#define MPRIS2_WATCHER_FREEDESKTOP_OBJECT "/org/freedesktop/DBus"
#define MPRIS2_WATCHER_MPRIS_PREFIX "org.mpris.MediaPlayer2."
#define MPRIS2_WATCHER_MPRIS_MEDIA_PLAYER_PATH "/org/mpris/MediaPlayer2"
Mpris2Watcher* mpris2_watcher_new (void);
Mpris2Watcher* mpris2_watcher_construct (GType object_type);
static void mpris2_watcher_name_changes_detected (Mpris2Watcher* self, FreeDesktopObject* dbus_obj, const gchar* name, const gchar* previous_owner, const gchar* current_owner);
GType mpris_root_proxy_get_type (void) G_GNUC_CONST;
guint mpris_root_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
GType mpris_root_get_type (void) G_GNUC_CONST;
static MprisRoot* mpris2_watcher_create_mpris_root (Mpris2Watcher* self, const gchar* name);
gchar* mpris_root_get_DesktopEntry (MprisRoot* self);
static void mpris2_watcher_check_for_active_clients_data_free (gpointer _data);
static void mpris2_watcher_check_for_active_clients_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void mpris2_watcher_check_for_active_clients (Mpris2Watcher* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
static void mpris2_watcher_check_for_active_clients_finish (Mpris2Watcher* self, GAsyncResult* _res_);
static gboolean mpris2_watcher_check_for_active_clients_co (Mpris2WatcherCheckForActiveClientsData* data);
static void g_cclosure_user_marshal_VOID__STRING_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static GObject * mpris2_watcher_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void _mpris2_watcher_name_changes_detected_free_desktop_object_name_owner_changed (FreeDesktopObject* _sender, const gchar* name, const gchar* old_owner, const gchar* new_owner, gpointer self);
static void mpris2_watcher_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);

static const GDBusArgInfo _free_desktop_object_dbus_arg_info_list_names_result = {-1, "result", "as"};
static const GDBusArgInfo * const _free_desktop_object_dbus_arg_info_list_names_in[] = {NULL};
static const GDBusArgInfo * const _free_desktop_object_dbus_arg_info_list_names_out[] = {&_free_desktop_object_dbus_arg_info_list_names_result, NULL};
static const GDBusMethodInfo _free_desktop_object_dbus_method_info_list_names = {-1, "ListNames", (GDBusArgInfo **) (&_free_desktop_object_dbus_arg_info_list_names_in), (GDBusArgInfo **) (&_free_desktop_object_dbus_arg_info_list_names_out)};
static const GDBusMethodInfo * const _free_desktop_object_dbus_method_info[] = {&_free_desktop_object_dbus_method_info_list_names, NULL};
static const GDBusArgInfo _free_desktop_object_dbus_arg_info_name_owner_changed_name = {-1, "name", "s"};
static const GDBusArgInfo _free_desktop_object_dbus_arg_info_name_owner_changed_old_owner = {-1, "old_owner", "s"};
static const GDBusArgInfo _free_desktop_object_dbus_arg_info_name_owner_changed_new_owner = {-1, "new_owner", "s"};
static const GDBusArgInfo * const _free_desktop_object_dbus_arg_info_name_owner_changed[] = {&_free_desktop_object_dbus_arg_info_name_owner_changed_name, &_free_desktop_object_dbus_arg_info_name_owner_changed_old_owner, &_free_desktop_object_dbus_arg_info_name_owner_changed_new_owner, NULL};
static const GDBusSignalInfo _free_desktop_object_dbus_signal_info_name_owner_changed = {-1, "NameOwnerChanged", (GDBusArgInfo **) (&_free_desktop_object_dbus_arg_info_name_owner_changed)};
static const GDBusSignalInfo * const _free_desktop_object_dbus_signal_info[] = {&_free_desktop_object_dbus_signal_info_name_owner_changed, NULL};
static const GDBusPropertyInfo * const _free_desktop_object_dbus_property_info[] = {NULL};
static const GDBusInterfaceInfo _free_desktop_object_dbus_interface_info = {-1, "org.freedesktop.DBus", (GDBusMethodInfo **) (&_free_desktop_object_dbus_method_info), (GDBusSignalInfo **) (&_free_desktop_object_dbus_signal_info), (GDBusPropertyInfo **) (&_free_desktop_object_dbus_property_info)};
static const GDBusInterfaceVTable _free_desktop_object_dbus_interface_vtable = {free_desktop_object_dbus_interface_method_call, free_desktop_object_dbus_interface_get_property, free_desktop_object_dbus_interface_set_property};

void free_desktop_object_list_names (FreeDesktopObject* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	FREE_DESKTOP_OBJECT_GET_INTERFACE (self)->list_names (self, _callback_, _user_data_);
}


gchar** free_desktop_object_list_names_finish (FreeDesktopObject* self, GAsyncResult* _res_, int* result_length1, GError** error) {
	return FREE_DESKTOP_OBJECT_GET_INTERFACE (self)->list_names_finish (self, _res_, result_length1, error);
}


static void g_cclosure_user_marshal_VOID__STRING_STRING_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__STRING_STRING_STRING) (gpointer data1, const char* arg_1, const char* arg_2, const char* arg_3, gpointer data2);
	register GMarshalFunc_VOID__STRING_STRING_STRING callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 4);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_STRING_STRING) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_string (param_values + 2), g_value_get_string (param_values + 3), data2);
}


static void free_desktop_object_base_init (FreeDesktopObjectIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
		g_signal_new ("name_owner_changed", TYPE_FREE_DESKTOP_OBJECT, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_STRING_STRING, G_TYPE_NONE, 3, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING);
		g_type_set_qdata (TYPE_FREE_DESKTOP_OBJECT, g_quark_from_static_string ("vala-dbus-register-object"), (void*) free_desktop_object_register_object);
	}
}


GType free_desktop_object_get_type (void) {
	static volatile gsize free_desktop_object_type_id__volatile = 0;
	if (g_once_init_enter (&free_desktop_object_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FreeDesktopObjectIface), (GBaseInitFunc) free_desktop_object_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType free_desktop_object_type_id;
		free_desktop_object_type_id = g_type_register_static (G_TYPE_INTERFACE, "FreeDesktopObject", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (free_desktop_object_type_id, G_TYPE_OBJECT);
		g_once_init_leave (&free_desktop_object_type_id__volatile, free_desktop_object_type_id);
	}
	return free_desktop_object_type_id__volatile;
}


G_DEFINE_TYPE_EXTENDED (FreeDesktopObjectProxy, free_desktop_object_proxy, G_TYPE_DBUS_PROXY, 0, G_IMPLEMENT_INTERFACE (TYPE_FREE_DESKTOP_OBJECT, free_desktop_object_proxy_free_desktop_object_interface_init) );
static void free_desktop_object_proxy_class_init (FreeDesktopObjectProxyClass* klass) {
	G_DBUS_PROXY_CLASS (klass)->g_signal = free_desktop_object_proxy_g_signal;
}


static void _dbus_handle_free_desktop_object_name_owner_changed (FreeDesktopObject* self, GVariant* parameters) {
	GVariantIter _arguments_iter;
	gchar* name = NULL;
	GVariant* _tmp69_;
	gchar* old_owner = NULL;
	GVariant* _tmp70_;
	gchar* new_owner = NULL;
	GVariant* _tmp71_;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp69_ = g_variant_iter_next_value (&_arguments_iter);
	name = g_variant_dup_string (_tmp69_, NULL);
	g_variant_unref (_tmp69_);
	_tmp70_ = g_variant_iter_next_value (&_arguments_iter);
	old_owner = g_variant_dup_string (_tmp70_, NULL);
	g_variant_unref (_tmp70_);
	_tmp71_ = g_variant_iter_next_value (&_arguments_iter);
	new_owner = g_variant_dup_string (_tmp71_, NULL);
	g_variant_unref (_tmp71_);
	g_signal_emit_by_name (self, "name-owner-changed", name, old_owner, new_owner);
	_g_free0 (name);
	_g_free0 (old_owner);
	_g_free0 (new_owner);
}


static void free_desktop_object_proxy_g_signal (GDBusProxy* proxy, const gchar* sender_name, const gchar* signal_name, GVariant* parameters) {
	if (strcmp (signal_name, "NameOwnerChanged") == 0) {
		_dbus_handle_free_desktop_object_name_owner_changed (proxy, parameters);
	}
}


static void free_desktop_object_proxy_init (FreeDesktopObjectProxy* self) {
}


static void _vala_g_async_ready_callback (GObject *source_object, GAsyncResult *res, void *user_data) {
	g_simple_async_result_set_op_res_gpointer (user_data, g_object_ref (res), g_object_unref);
	g_simple_async_result_complete (user_data);
	g_object_unref (user_data);
}


static void free_desktop_object_proxy_list_names_async (FreeDesktopObject* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	GDBusMessage *_message;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	G_IO_ERROR;
	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "org.freedesktop.DBus", "ListNames");
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_message_set_body (_message, _arguments);
	g_dbus_connection_send_message_with_reply (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, _vala_g_async_ready_callback, g_simple_async_result_new (self, _callback_, _user_data_, NULL));
	g_object_unref (_message);
}


static gchar** free_desktop_object_proxy_list_names_finish (FreeDesktopObject* self, GAsyncResult* _res_, int* result_length1, GError** error) {
	GDBusMessage *_reply_message;
	GVariant *_reply;
	GVariantIter _reply_iter;
	gchar** _result;
	int _result_length1;
	GVariant* _tmp72_;
	gchar** _tmp73_;
	int _tmp73__length;
	int _tmp73__size;
	int _tmp73__length1;
	GVariantIter _tmp74_;
	GVariant* _tmp75_;
	_reply_message = g_dbus_connection_send_message_with_reply_finish (g_dbus_proxy_get_connection ((GDBusProxy *) self), g_simple_async_result_get_op_res_gpointer (_res_), error);
	if (!_reply_message) {
		return NULL;
	}
	if (g_dbus_message_to_gerror (_reply_message, error)) {
		g_object_unref (_reply_message);
		return NULL;
	}
	_reply = g_dbus_message_get_body (_reply_message);
	g_variant_iter_init (&_reply_iter, _reply);
	_result_length1 = 0;
	_tmp72_ = g_variant_iter_next_value (&_reply_iter);
	_tmp73_ = g_new (gchar*, 5);
	_tmp73__length = 0;
	_tmp73__size = 4;
	_tmp73__length1 = 0;
	g_variant_iter_init (&_tmp74_, _tmp72_);
	for (; _tmp75_ = g_variant_iter_next_value (&_tmp74_); _tmp73__length1++) {
		if (_tmp73__size == _tmp73__length) {
			_tmp73__size = 2 * _tmp73__size;
			_tmp73_ = g_renew (gchar*, _tmp73_, _tmp73__size + 1);
		}
		_tmp73_[_tmp73__length++] = g_variant_dup_string (_tmp75_, NULL);
		g_variant_unref (_tmp75_);
	}
	_result_length1 = _tmp73__length1;
	_tmp73_[_tmp73__length] = NULL;
	_result = _tmp73_;
	g_variant_unref (_tmp72_);
	*result_length1 = _result_length1;
	g_object_unref (_reply_message);
	return _result;
}


static void free_desktop_object_proxy_free_desktop_object_interface_init (FreeDesktopObjectIface* iface) {
	iface->list_names = free_desktop_object_proxy_list_names_async;
	iface->list_names_finish = free_desktop_object_proxy_list_names_finish;
}


static void _dbus_free_desktop_object_list_names (FreeDesktopObject* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GVariantIter _arguments_iter;
	g_variant_iter_init (&_arguments_iter, parameters);
	free_desktop_object_list_names (self, (GAsyncReadyCallback) _dbus_free_desktop_object_list_names_ready, g_object_ref (invocation));
}


static void _dbus_free_desktop_object_list_names_ready (GObject * source_object, GAsyncResult * _res_, gpointer * _user_data_) {
	GDBusMethodInvocation * invocation;
	GError* error;
	GVariantIter _arguments_iter;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	gchar** result;
	int result_length1 = 0;
	gchar** _tmp76_;
	GVariantBuilder _tmp77_;
	int _tmp78_;
	invocation = _user_data_;
	error = NULL;
	result = free_desktop_object_list_names_finish ((FreeDesktopObject*) source_object, _res_, &result_length1, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (g_object_ref (invocation), error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_tmp76_ = result;
	g_variant_builder_init (&_tmp77_, G_VARIANT_TYPE ("as"));
	for (_tmp78_ = 0; _tmp78_ < result_length1; _tmp78_++) {
		g_variant_builder_add_value (&_tmp77_, g_variant_new_string (*_tmp76_));
		_tmp76_++;
	}
	g_variant_builder_add_value (&_reply_builder, g_variant_builder_end (&_tmp77_));
	result = (_vala_array_free (result,  result_length1, (GDestroyNotify) g_free), NULL);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void free_desktop_object_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	if (strcmp (method_name, "ListNames") == 0) {
		_dbus_free_desktop_object_list_names (object, parameters, invocation);
	}
	g_object_unref (invocation);
}


static GVariant* free_desktop_object_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return NULL;
}


static gboolean free_desktop_object_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return FALSE;
}


static void _dbus_free_desktop_object_name_owner_changed (GObject* _sender, const gchar* name, const gchar* old_owner, const gchar* new_owner, gpointer* _data) {
	GDBusConnection * _connection;
	const gchar * _path;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	_connection = _data[1];
	_path = _data[2];
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (name));
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (old_owner));
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (new_owner));
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_connection_emit_signal (_connection, NULL, _path, "org.freedesktop.DBus", "NameOwnerChanged", _arguments, NULL);
}


guint free_desktop_object_register_object (gpointer object, GDBusConnection* connection, const gchar* path, GError** error) {
	guint result;
	gpointer *data;
	data = g_new (gpointer, 3);
	data[0] = g_object_ref (object);
	data[1] = g_object_ref (connection);
	data[2] = g_strdup (path);
	result = g_dbus_connection_register_object (connection, path, &_free_desktop_object_dbus_interface_info, &_free_desktop_object_dbus_interface_vtable, data, _free_desktop_object_unregister_object, error);
	if (!result) {
		return 0;
	}
	g_signal_connect (object, "name-owner-changed", (GCallback) _dbus_free_desktop_object_name_owner_changed, data);
	return result;
}


static void _free_desktop_object_unregister_object (gpointer user_data) {
	gpointer* data;
	data = user_data;
	g_object_unref (data[0]);
	g_object_unref (data[1]);
	g_free (data[2]);
	g_free (data);
}


Mpris2Watcher* mpris2_watcher_construct (GType object_type) {
	Mpris2Watcher * self = NULL;
	self = (Mpris2Watcher*) g_object_new (object_type, NULL);
	return self;
}


Mpris2Watcher* mpris2_watcher_new (void) {
	return mpris2_watcher_construct (TYPE_MPRIS2_WATCHER);
}


static void mpris2_watcher_name_changes_detected (Mpris2Watcher* self, FreeDesktopObject* dbus_obj, const gchar* name, const gchar* previous_owner, const gchar* current_owner) {
	MprisRoot* _tmp0_ = NULL;
	MprisRoot* mpris2_root;
	gboolean _tmp1_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (dbus_obj != NULL);
	g_return_if_fail (name != NULL);
	g_return_if_fail (previous_owner != NULL);
	g_return_if_fail (current_owner != NULL);
	_tmp0_ = mpris2_watcher_create_mpris_root (self, name);
	mpris2_root = _tmp0_;
	if (mpris2_root == NULL) {
		_g_object_unref0 (mpris2_root);
		return;
	}
	if (g_strcmp0 (previous_owner, "") != 0) {
		_tmp1_ = g_strcmp0 (current_owner, "") == 0;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		g_debug ("mpris2-watcher.vala:70: Client '%s' gone down", name);
		g_signal_emit_by_name (self, "client-disappeared", name);
	} else {
		gboolean _tmp2_ = FALSE;
		if (g_strcmp0 (previous_owner, "") == 0) {
			_tmp2_ = g_strcmp0 (current_owner, "") != 0;
		} else {
			_tmp2_ = FALSE;
		}
		if (_tmp2_) {
			gchar* _tmp3_ = NULL;
			gchar* _tmp4_;
			g_debug ("mpris2-watcher.vala:74: Client '%s' has appeared", name);
			_tmp3_ = mpris_root_get_DesktopEntry (mpris2_root);
			_tmp4_ = _tmp3_;
			g_signal_emit_by_name (self, "client-appeared", _tmp4_, name);
			_g_free0 (_tmp4_);
		}
	}
	_g_object_unref0 (mpris2_root);
}


static MprisRoot* mpris2_watcher_create_mpris_root (Mpris2Watcher* self, const gchar* name) {
	MprisRoot* result = NULL;
	MprisRoot* mpris2_root;
	gboolean _tmp0_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (name != NULL, NULL);
	mpris2_root = NULL;
	_tmp0_ = g_str_has_prefix (name, MPRIS2_WATCHER_MPRIS_PREFIX);
	if (_tmp0_) {
		MprisRoot* _tmp1_;
		MprisRoot* _tmp2_;
		_tmp1_ = (MprisRoot*) g_initable_new (TYPE_MPRIS_ROOT_PROXY, NULL, &_inner_error_, "g-flags", 0, "g-name", name, "g-bus-type", G_BUS_TYPE_SESSION, "g-object-path", MPRIS2_WATCHER_MPRIS_MEDIA_PLAYER_PATH, "g-interface-name", "org.mpris.MediaPlayer2", NULL);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_IO_ERROR) {
				goto __catch7_g_io_error;
			}
			_g_object_unref0 (mpris2_root);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp2_ = _tmp1_;
		_g_object_unref0 (mpris2_root);
		mpris2_root = _tmp2_;
		goto __finally7;
		__catch7_g_io_error:
		{
			GError * e;
			e = _inner_error_;
			_inner_error_ = NULL;
			g_warning ("mpris2-watcher.vala:88: Mpris2watcher could not create a root interfac" \
"e: %s", e->message);
			_g_error_free0 (e);
		}
		__finally7:
		if (_inner_error_ != NULL) {
			_g_object_unref0 (mpris2_root);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = mpris2_root;
	return result;
}


static void mpris2_watcher_check_for_active_clients_data_free (gpointer _data) {
	Mpris2WatcherCheckForActiveClientsData* data;
	data = _data;
	_g_object_unref0 (data->self);
	g_slice_free (Mpris2WatcherCheckForActiveClientsData, data);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void mpris2_watcher_check_for_active_clients (Mpris2Watcher* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	Mpris2WatcherCheckForActiveClientsData* _data_;
	_data_ = g_slice_new0 (Mpris2WatcherCheckForActiveClientsData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, mpris2_watcher_check_for_active_clients);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, mpris2_watcher_check_for_active_clients_data_free);
	_data_->self = _g_object_ref0 (self);
	mpris2_watcher_check_for_active_clients_co (_data_);
}


static void mpris2_watcher_check_for_active_clients_finish (Mpris2Watcher* self, GAsyncResult* _res_) {
	Mpris2WatcherCheckForActiveClientsData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void mpris2_watcher_check_for_active_clients_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	Mpris2WatcherCheckForActiveClientsData* data;
	data = _user_data_;
	data->_source_object_ = source_object;
	data->_res_ = _res_;
	mpris2_watcher_check_for_active_clients_co (data);
}


static gboolean mpris2_watcher_check_for_active_clients_co (Mpris2WatcherCheckForActiveClientsData* data) {
	switch (data->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	data->interfaces_length1 = 0;
	data->_state_ = 1;
	free_desktop_object_list_names (data->self->priv->fdesktop_obj, mpris2_watcher_check_for_active_clients_ready, data);
	return FALSE;
	_state_1:
	data->_tmp1_ = NULL;
	data->_tmp1_ = free_desktop_object_list_names_finish (data->self->priv->fdesktop_obj, data->_res_, &data->_tmp0_, &data->_inner_error_);
	data->_tmp3_ = data->_tmp1_;
	data->_tmp2__length1 = data->_tmp0_;
	data->__tmp2__size_ = data->_tmp2__length1;
	data->_tmp2_ = data->_tmp3_;
	if (data->_inner_error_ != NULL) {
		if (data->_inner_error_->domain == G_IO_ERROR) {
			goto __catch8_g_io_error;
		}
		data->interfaces = (_vala_array_free (data->interfaces, data->interfaces_length1, (GDestroyNotify) g_free), NULL);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, data->_inner_error_->message, g_quark_to_string (data->_inner_error_->domain), data->_inner_error_->code);
		g_clear_error (&data->_inner_error_);
		return FALSE;
	}
	data->_tmp4_ = data->_tmp2_;
	data->interfaces = (_vala_array_free (data->interfaces, data->interfaces_length1, (GDestroyNotify) g_free), NULL);
	data->interfaces_length1 = data->_tmp2__length1;
	data->_interfaces_size_ = data->interfaces_length1;
	data->interfaces = data->_tmp4_;
	goto __finally8;
	__catch8_g_io_error:
	{
		data->e = data->_inner_error_;
		data->_inner_error_ = NULL;
		g_warning ("mpris2-watcher.vala:104: Mpris2watcher could fetch active interfaces a" \
"t startup: %s", data->e->message);
		_g_error_free0 (data->e);
		data->interfaces = (_vala_array_free (data->interfaces, data->interfaces_length1, (GDestroyNotify) g_free), NULL);
		if (data->_state_ == 0) {
			g_simple_async_result_complete_in_idle (data->_async_result);
		} else {
			g_simple_async_result_complete (data->_async_result);
		}
		g_object_unref (data->_async_result);
		return FALSE;
	}
	__finally8:
	if (data->_inner_error_ != NULL) {
		data->interfaces = (_vala_array_free (data->interfaces, data->interfaces_length1, (GDestroyNotify) g_free), NULL);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, data->_inner_error_->message, g_quark_to_string (data->_inner_error_->domain), data->_inner_error_->code);
		g_clear_error (&data->_inner_error_);
		return FALSE;
	}
	{
		data->address_collection = data->interfaces;
		data->address_collection_length1 = data->interfaces_length1;
		for (data->address_it = 0; data->address_it < data->interfaces_length1; data->address_it = data->address_it + 1) {
			data->_tmp5_ = g_strdup (data->address_collection[data->address_it]);
			data->address = data->_tmp5_;
			{
				data->_tmp6_ = g_str_has_prefix (data->address, MPRIS2_WATCHER_MPRIS_PREFIX);
				if (data->_tmp6_) {
					data->_tmp7_ = NULL;
					data->_tmp7_ = mpris2_watcher_create_mpris_root (data->self, data->address);
					data->mpris2_root = data->_tmp7_;
					if (data->mpris2_root == NULL) {
						_g_object_unref0 (data->mpris2_root);
						_g_free0 (data->address);
						data->interfaces = (_vala_array_free (data->interfaces, data->interfaces_length1, (GDestroyNotify) g_free), NULL);
						if (data->_state_ == 0) {
							g_simple_async_result_complete_in_idle (data->_async_result);
						} else {
							g_simple_async_result_complete (data->_async_result);
						}
						g_object_unref (data->_async_result);
						return FALSE;
					}
					data->_tmp8_ = NULL;
					data->_tmp8_ = mpris_root_get_DesktopEntry (data->mpris2_root);
					data->_tmp9_ = data->_tmp8_;
					g_signal_emit_by_name (data->self, "client-appeared", data->_tmp9_, data->address);
					_g_free0 (data->_tmp9_);
					_g_object_unref0 (data->mpris2_root);
				}
				_g_free0 (data->address);
			}
		}
	}
	data->interfaces = (_vala_array_free (data->interfaces, data->interfaces_length1, (GDestroyNotify) g_free), NULL);
	if (data->_state_ == 0) {
		g_simple_async_result_complete_in_idle (data->_async_result);
	} else {
		g_simple_async_result_complete (data->_async_result);
	}
	g_object_unref (data->_async_result);
	return FALSE;
}


static void g_cclosure_user_marshal_VOID__STRING_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__STRING_STRING) (gpointer data1, const char* arg_1, const char* arg_2, gpointer data2);
	register GMarshalFunc_VOID__STRING_STRING callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_STRING) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_string (param_values + 2), data2);
}


static void _mpris2_watcher_name_changes_detected_free_desktop_object_name_owner_changed (FreeDesktopObject* _sender, const gchar* name, const gchar* old_owner, const gchar* new_owner, gpointer self) {
	mpris2_watcher_name_changes_detected (self, _sender, name, old_owner, new_owner);
}


static GObject * mpris2_watcher_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	Mpris2Watcher * self;
	FreeDesktopObject* _tmp0_;
	FreeDesktopObject* _tmp1_;
	GError * _inner_error_ = NULL;
	parent_class = G_OBJECT_CLASS (mpris2_watcher_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = MPRIS2_WATCHER (obj);
	_tmp0_ = (FreeDesktopObject*) g_initable_new (TYPE_FREE_DESKTOP_OBJECT_PROXY, NULL, &_inner_error_, "g-flags", G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES, "g-name", MPRIS2_WATCHER_FREEDESKTOP_SERVICE, "g-bus-type", G_BUS_TYPE_SESSION, "g-object-path", MPRIS2_WATCHER_FREEDESKTOP_OBJECT, "g-interface-name", "org.freedesktop.DBus", NULL);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_IO_ERROR) {
			goto __catch9_g_io_error;
		}
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
	}
	_tmp1_ = _tmp0_;
	_g_object_unref0 (self->priv->fdesktop_obj);
	self->priv->fdesktop_obj = _tmp1_;
	g_signal_connect_object (self->priv->fdesktop_obj, "name-owner-changed", (GCallback) _mpris2_watcher_name_changes_detected_free_desktop_object_name_owner_changed, self, 0);
	mpris2_watcher_check_for_active_clients (self, NULL, NULL);
	goto __finally9;
	__catch9_g_io_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_warning ("mpris2-watcher.vala:55: Mpris2watcher could not set up a watch for mpr" \
"is clients appearing on the bus: %s", e->message);
		_g_error_free0 (e);
	}
	__finally9:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
	}
	return obj;
}


static void mpris2_watcher_class_init (Mpris2WatcherClass * klass) {
	mpris2_watcher_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (Mpris2WatcherPrivate));
	G_OBJECT_CLASS (klass)->constructor = mpris2_watcher_constructor;
	G_OBJECT_CLASS (klass)->finalize = mpris2_watcher_finalize;
	g_signal_new ("client_appeared", TYPE_MPRIS2_WATCHER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_STRING, G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_STRING);
	g_signal_new ("client_disappeared", TYPE_MPRIS2_WATCHER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
}


static void mpris2_watcher_instance_init (Mpris2Watcher * self) {
	self->priv = MPRIS2_WATCHER_GET_PRIVATE (self);
}


static void mpris2_watcher_finalize (GObject* obj) {
	Mpris2Watcher * self;
	self = MPRIS2_WATCHER (obj);
	_g_object_unref0 (self->priv->fdesktop_obj);
	G_OBJECT_CLASS (mpris2_watcher_parent_class)->finalize (obj);
}


GType mpris2_watcher_get_type (void) {
	static volatile gsize mpris2_watcher_type_id__volatile = 0;
	if (g_once_init_enter (&mpris2_watcher_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (Mpris2WatcherClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) mpris2_watcher_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Mpris2Watcher), 0, (GInstanceInitFunc) mpris2_watcher_instance_init, NULL };
		GType mpris2_watcher_type_id;
		mpris2_watcher_type_id = g_type_register_static (G_TYPE_OBJECT, "Mpris2Watcher", &g_define_type_info, 0);
		g_once_init_leave (&mpris2_watcher_type_id__volatile, mpris2_watcher_type_id);
	}
	return mpris2_watcher_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



