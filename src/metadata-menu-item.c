/* metadata-menu-item.c generated by valac 0.9.8, the Vala compiler
 * generated from metadata-menu-item.vala, do not modify */

/*
Copyright 2010 Canonical Ltd.

Authors:
    Conor Curran <conor.curran@canonical.com>

This program is free software: you can redistribute it and/or modify it 
under the terms of the GNU General Public License version 3, as published 
by the Free Software Foundation.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranties of 
MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along 
with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <glib.h>
#include <glib-object.h>
#include <libdbusmenu-glib/client.h>
#include <libdbusmenu-glib/menuitem-proxy.h>
#include <libdbusmenu-glib/menuitem.h>
#include <libdbusmenu-glib/server.h>
#include <stdlib.h>
#include <string.h>
#include <common-defs.h>
#include <gee.h>
#include <gio/gio.h>
#include <gdk-pixbuf/gdk-pixdata.h>
#include <glib/gstdio.h>


#define TYPE_PLAYER_ITEM (player_item_get_type ())
#define PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_ITEM, PlayerItem))
#define PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_ITEM, PlayerItemClass))
#define IS_PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_ITEM))
#define IS_PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_ITEM))
#define PLAYER_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_ITEM, PlayerItemClass))

typedef struct _PlayerItem PlayerItem;
typedef struct _PlayerItemClass PlayerItemClass;
typedef struct _PlayerItemPrivate PlayerItemPrivate;

#define TYPE_METADATA_MENUITEM (metadata_menuitem_get_type ())
#define METADATA_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_METADATA_MENUITEM, MetadataMenuitem))
#define METADATA_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_METADATA_MENUITEM, MetadataMenuitemClass))
#define IS_METADATA_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_METADATA_MENUITEM))
#define IS_METADATA_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_METADATA_MENUITEM))
#define METADATA_MENUITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_METADATA_MENUITEM, MetadataMenuitemClass))

typedef struct _MetadataMenuitem MetadataMenuitem;
typedef struct _MetadataMenuitemClass MetadataMenuitemClass;
typedef struct _MetadataMenuitemPrivate MetadataMenuitemPrivate;

#define TYPE_FETCH_FILE (fetch_file_get_type ())
#define FETCH_FILE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FETCH_FILE, FetchFile))
#define FETCH_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FETCH_FILE, FetchFileClass))
#define IS_FETCH_FILE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FETCH_FILE))
#define IS_FETCH_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FETCH_FILE))
#define FETCH_FILE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FETCH_FILE, FetchFileClass))

typedef struct _FetchFile FetchFile;
typedef struct _FetchFileClass FetchFileClass;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _PlayerItem {
	DbusmenuMenuitem parent_instance;
	PlayerItemPrivate * priv;
};

struct _PlayerItemClass {
	DbusmenuMenuitemClass parent_class;
};

struct _MetadataMenuitem {
	PlayerItem parent_instance;
	MetadataMenuitemPrivate * priv;
};

struct _MetadataMenuitemClass {
	PlayerItemClass parent_class;
};

struct _MetadataMenuitemPrivate {
	char* previous_temp_album_art_path;
};


extern char* metadata_menuitem_album_art_cache_dir;
char* metadata_menuitem_album_art_cache_dir = NULL;
static FetchFile* metadata_menuitem_fetcher;
static FetchFile* metadata_menuitem_fetcher = NULL;
static gpointer metadata_menuitem_parent_class = NULL;

GType player_item_get_type (void) G_GNUC_CONST;
GType metadata_menuitem_get_type (void) G_GNUC_CONST;
#define METADATA_MENUITEM_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_METADATA_MENUITEM, MetadataMenuitemPrivate))
enum  {
	METADATA_MENUITEM_DUMMY_PROPERTY
};
GType fetch_file_get_type (void) G_GNUC_CONST;
#define METADATA_MENUITEM_ALBUM_ART_DIR_SUFFIX "indicators/sound/album-art-cache"
MetadataMenuitem* metadata_menuitem_new (void);
MetadataMenuitem* metadata_menuitem_construct (GType object_type);
void player_item_reset (PlayerItem* self, GeeHashSet* attrs);
GeeHashSet* metadata_menuitem_attributes_format (void);
static void metadata_menuitem_clean_album_art_temp_dir (void);
static gboolean metadata_menuitem_delete_album_art_contents (GFile* dir);
static char* metadata_menuitem_create_album_art_temp_dir (void);
void metadata_menuitem_fetch_art (MetadataMenuitem* self, const char* uri, const char* prop);
FetchFile* fetch_file_new (const char* uri, const char* prop);
FetchFile* fetch_file_construct (GType object_type, const char* uri, const char* prop);
static void _lambda0_ (MetadataMenuitem* self);
static void metadata_menuitem_on_fetcher_failed (MetadataMenuitem* self);
static void __lambda0__fetch_file_failed (FetchFile* _sender, gpointer self);
static void metadata_menuitem_on_fetcher_completed (MetadataMenuitem* self, GByteArray* update, const char* property);
static void _metadata_menuitem_on_fetcher_completed_fetch_file_completed (FetchFile* _sender, GByteArray* data, const char* property, gpointer self);
void fetch_file_fetch_data (FetchFile* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void fetch_file_fetch_data_finish (FetchFile* self, GAsyncResult* _res_);
static GObject * metadata_menuitem_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void metadata_menuitem_finalize (GObject* obj);



MetadataMenuitem* metadata_menuitem_construct (GType object_type) {
	MetadataMenuitem * self;
	GeeHashSet* _tmp0_;
	self = (MetadataMenuitem*) g_object_new (object_type, "item-type", DBUSMENU_METADATA_MENUITEM_TYPE, NULL);
	player_item_reset ((PlayerItem*) self, _tmp0_ = metadata_menuitem_attributes_format ());
	_g_object_unref0 (_tmp0_);
	return self;
}


MetadataMenuitem* metadata_menuitem_new (void) {
	return metadata_menuitem_construct (TYPE_METADATA_MENUITEM);
}


static void metadata_menuitem_clean_album_art_temp_dir (void) {
	char* path;
	GFile* album_art_dir;
	path = g_build_filename (g_get_user_cache_dir (), METADATA_MENUITEM_ALBUM_ART_DIR_SUFFIX, NULL);
	album_art_dir = g_file_new_for_path (path);
	if (metadata_menuitem_delete_album_art_contents (album_art_dir) == FALSE) {
		g_warning ("metadata-menu-item.vala:52: could not remove the temp album art files " \
"%s", path);
	}
	_g_object_unref0 (album_art_dir);
	_g_free0 (path);
}


static char* metadata_menuitem_create_album_art_temp_dir (void) {
	char* result = NULL;
	char* path;
	path = g_build_filename (g_get_user_cache_dir (), METADATA_MENUITEM_ALBUM_ART_DIR_SUFFIX, NULL);
	if (g_mkdir (path, 0700) == (-1)) {
		g_warning ("metadata-menu-item.vala:60: could not create a temp dir for remote alb" \
"um art, it must have been created already");
	}
	result = path;
	return result;
}


static const char* string_to_string (const char* self) {
	const char* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


static gboolean metadata_menuitem_delete_album_art_contents (GFile* dir) {
	gboolean result = FALSE;
	gboolean _result_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (dir != NULL, FALSE);
	_result_ = TRUE;
	{
		GFileEnumerator* e;
		e = g_file_enumerate_children (dir, G_FILE_ATTRIBUTE_STANDARD_NAME, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS, NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch0_g_error;
		}
		while (TRUE) {
			GFileInfo* file;
			GFile* child;
			file = g_file_enumerator_next_file (e, NULL, &_inner_error_);
			if (_inner_error_ != NULL) {
				_g_object_unref0 (e);
				goto __catch0_g_error;
			}
			g_debug ("metadata-menu-item.vala:76: file name = %s", g_file_info_get_name (file));
			if (file == NULL) {
				_g_object_unref0 (file);
				break;
			}
			child = g_file_get_child (dir, g_file_info_get_name (file));
			{
				g_file_delete (child, NULL, &_inner_error_);
				if (_inner_error_ != NULL) {
					goto __catch1_g_error;
				}
			}
			goto __finally1;
			__catch1_g_error:
			{
				GError * error_;
				error_ = _inner_error_;
				_inner_error_ = NULL;
				{
					char* _tmp0_;
					char* _tmp1_;
					g_warning ("metadata-menu-item.vala:86: %s", _tmp1_ = g_strconcat ("Unable to delete file '", string_to_string (_tmp0_ = g_file_get_basename (child)), ": ", string_to_string (error_->message), NULL));
					_g_free0 (_tmp1_);
					_g_free0 (_tmp0_);
					_result_ = FALSE;
					_g_error_free0 (error_);
				}
			}
			__finally1:
			if (_inner_error_ != NULL) {
				_g_object_unref0 (child);
				_g_object_unref0 (file);
				_g_object_unref0 (e);
				goto __catch0_g_error;
			}
			_g_object_unref0 (child);
			_g_object_unref0 (file);
		}
		_g_object_unref0 (e);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError * _error_;
		_error_ = _inner_error_;
		_inner_error_ = NULL;
		{
			char* _tmp2_;
			char* _tmp3_;
			g_warning (_tmp3_ = g_strconcat ("Unable to read files from directory '", string_to_string (_tmp2_ = g_file_get_basename (dir)), "': %s", NULL), _error_->message);
			_g_free0 (_tmp3_);
			_g_free0 (_tmp2_);
			_result_ = FALSE;
			_g_error_free0 (_error_);
		}
	}
	__finally0:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = _result_;
	return result;
}


static char* string_strip (const char* self) {
	char* result = NULL;
	char* _result_;
	g_return_val_if_fail (self != NULL, NULL);
	_result_ = g_strdup (self);
	g_strstrip (_result_);
	result = _result_;
	return result;
}


static void _lambda0_ (MetadataMenuitem* self) {
	metadata_menuitem_on_fetcher_failed (self);
}


static void __lambda0__fetch_file_failed (FetchFile* _sender, gpointer self) {
	_lambda0_ (self);
}


static void _metadata_menuitem_on_fetcher_completed_fetch_file_completed (FetchFile* _sender, GByteArray* data, const char* property, gpointer self) {
	metadata_menuitem_on_fetcher_completed (self, data, property);
}


void metadata_menuitem_fetch_art (MetadataMenuitem* self, const char* uri, const char* prop) {
	GFile* art_file;
	FetchFile* _tmp4_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (uri != NULL);
	g_return_if_fail (prop != NULL);
	art_file = g_file_new_for_uri (uri);
	if (g_file_is_native (art_file) == TRUE) {
		char* path;
		path = NULL;
		{
			char* _tmp0_;
			char* _tmp1_;
			char* _tmp2_;
			char* _tmp3_;
			_tmp2_ = (_tmp1_ = g_filename_from_uri (_tmp0_ = string_strip (uri), NULL, &_inner_error_), _g_free0 (_tmp0_), _tmp1_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == G_CONVERT_ERROR) {
					goto __catch2_g_convert_error;
				}
				_g_free0 (path);
				_g_object_unref0 (art_file);
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
			path = (_tmp3_ = _tmp2_, _g_free0 (path), _tmp3_);
			dbusmenu_menuitem_property_set ((DbusmenuMenuitem*) self, prop, path);
		}
		goto __finally2;
		__catch2_g_convert_error:
		{
			GError * e;
			e = _inner_error_;
			_inner_error_ = NULL;
			{
				g_warning ("metadata-menu-item.vala:108: Problem converting URI %s to file path", uri);
				_g_error_free0 (e);
			}
		}
		__finally2:
		if (_inner_error_ != NULL) {
			_g_free0 (path);
			_g_object_unref0 (art_file);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_g_free0 (path);
		_g_object_unref0 (art_file);
		return;
	}
	g_debug ("metadata-menu-item.vala:114: fetch_art -remotely %s", metadata_menuitem_album_art_cache_dir);
	if (metadata_menuitem_album_art_cache_dir == NULL) {
		_g_object_unref0 (art_file);
		return;
	}
	metadata_menuitem_fetcher = (_tmp4_ = fetch_file_new (uri, prop), _g_object_unref0 (metadata_menuitem_fetcher), _tmp4_);
	g_signal_connect_object (metadata_menuitem_fetcher, "failed", (GCallback) __lambda0__fetch_file_failed, self, 0);
	g_signal_connect_object (metadata_menuitem_fetcher, "completed", (GCallback) _metadata_menuitem_on_fetcher_completed_fetch_file_completed, self, 0);
	fetch_file_fetch_data (metadata_menuitem_fetcher, NULL, NULL);
	_g_object_unref0 (art_file);
}


static void metadata_menuitem_on_fetcher_failed (MetadataMenuitem* self) {
	g_return_if_fail (self != NULL);
	g_warning ("metadata-menu-item.vala:129: on_fetcher_failed -> could not fetch artw" \
"ork");
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void metadata_menuitem_on_fetcher_completed (MetadataMenuitem* self, GByteArray* update, const char* property) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (update != NULL);
	g_return_if_fail (property != NULL);
	{
		GdkPixbufLoader* loader;
		GdkPixbuf* icon;
		char* path;
		gint r;
		loader = gdk_pixbuf_loader_new ();
		gdk_pixbuf_loader_write (loader, update->data, (gsize) update->len, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_object_unref0 (loader);
			goto __catch3_g_error;
		}
		gdk_pixbuf_loader_close (loader, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_object_unref0 (loader);
			goto __catch3_g_error;
		}
		icon = _g_object_ref0 (gdk_pixbuf_loader_get_pixbuf (loader));
		path = g_strconcat (metadata_menuitem_album_art_cache_dir, "/downloaded-coverart-XXXXXX", NULL);
		r = g_mkstemp (path);
		if (r != (-1)) {
			char* _tmp0_;
			gdk_pixbuf_save (icon, path, gdk_pixbuf_format_get_name (gdk_pixbuf_loader_get_format (loader)), &_inner_error_, NULL);
			if (_inner_error_ != NULL) {
				_g_free0 (path);
				_g_object_unref0 (icon);
				_g_object_unref0 (loader);
				goto __catch3_g_error;
			}
			dbusmenu_menuitem_property_set ((DbusmenuMenuitem*) self, property, path);
			if (self->priv->previous_temp_album_art_path != NULL) {
				g_remove (self->priv->previous_temp_album_art_path);
			}
			self->priv->previous_temp_album_art_path = (_tmp0_ = g_strdup (path), _g_free0 (self->priv->previous_temp_album_art_path), _tmp0_);
		}
		_g_free0 (path);
		_g_object_unref0 (icon);
		_g_object_unref0 (loader);
	}
	goto __finally3;
	__catch3_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			g_warning ("metadata-menu-item.vala:151: Problem creating file from bytearray fetc" \
"hed from the interweb - error: %s", e->message);
			_g_error_free0 (e);
		}
	}
	__finally3:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


GeeHashSet* metadata_menuitem_attributes_format (void) {
	GeeHashSet* result = NULL;
	GeeHashSet* attrs;
	attrs = gee_hash_set_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL);
	gee_abstract_collection_add ((GeeAbstractCollection*) attrs, DBUSMENU_METADATA_MENUITEM_TITLE);
	gee_abstract_collection_add ((GeeAbstractCollection*) attrs, DBUSMENU_METADATA_MENUITEM_ARTIST);
	gee_abstract_collection_add ((GeeAbstractCollection*) attrs, DBUSMENU_METADATA_MENUITEM_ALBUM);
	gee_abstract_collection_add ((GeeAbstractCollection*) attrs, DBUSMENU_METADATA_MENUITEM_ARTURL);
	result = attrs;
	return result;
}


static GObject * metadata_menuitem_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	MetadataMenuitem * self;
	parent_class = G_OBJECT_CLASS (metadata_menuitem_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = METADATA_MENUITEM (obj);
	{
		char* _tmp0_;
		char* _tmp1_;
		metadata_menuitem_clean_album_art_temp_dir ();
		self->priv->previous_temp_album_art_path = (_tmp0_ = NULL, _g_free0 (self->priv->previous_temp_album_art_path), _tmp0_);
		metadata_menuitem_album_art_cache_dir = (_tmp1_ = metadata_menuitem_create_album_art_temp_dir (), _g_free0 (metadata_menuitem_album_art_cache_dir), _tmp1_);
	}
	return obj;
}


static void metadata_menuitem_class_init (MetadataMenuitemClass * klass) {
	metadata_menuitem_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (MetadataMenuitemPrivate));
	G_OBJECT_CLASS (klass)->constructor = metadata_menuitem_constructor;
	G_OBJECT_CLASS (klass)->finalize = metadata_menuitem_finalize;
}


static void metadata_menuitem_instance_init (MetadataMenuitem * self) {
	self->priv = METADATA_MENUITEM_GET_PRIVATE (self);
}


static void metadata_menuitem_finalize (GObject* obj) {
	MetadataMenuitem * self;
	self = METADATA_MENUITEM (obj);
	_g_free0 (self->priv->previous_temp_album_art_path);
	G_OBJECT_CLASS (metadata_menuitem_parent_class)->finalize (obj);
}


GType metadata_menuitem_get_type (void) {
	static volatile gsize metadata_menuitem_type_id__volatile = 0;
	if (g_once_init_enter (&metadata_menuitem_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (MetadataMenuitemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) metadata_menuitem_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MetadataMenuitem), 0, (GInstanceInitFunc) metadata_menuitem_instance_init, NULL };
		GType metadata_menuitem_type_id;
		metadata_menuitem_type_id = g_type_register_static (TYPE_PLAYER_ITEM, "MetadataMenuitem", &g_define_type_info, 0);
		g_once_init_leave (&metadata_menuitem_type_id__volatile, metadata_menuitem_type_id);
	}
	return metadata_menuitem_type_id__volatile;
}




