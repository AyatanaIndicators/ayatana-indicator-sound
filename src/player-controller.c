/* player-controller.c generated by valac, the Vala compiler
 * generated from player-controller.vala, do not modify */

/*
This service primarily controls PulseAudio and is driven by the sound indicator menu on the panel.
Copyright 2010 Canonical Ltd.

Authors:
    Conor Curran <conor.curran@canonical.com>

This program is free software: you can redistribute it and/or modify it 
under the terms of the GNU General Public License version 3, as published 
by the Free Software Foundation.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranties of 
MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along 
with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <glib.h>
#include <glib-object.h>
#include <libdbusmenu-glib/client.h>
#include <libdbusmenu-glib/menuitem-proxy.h>
#include <libdbusmenu-glib/menuitem.h>
#include <libdbusmenu-glib/server.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>


#define TYPE_PLAYER_CONTROLLER (player_controller_get_type ())
#define PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_CONTROLLER, PlayerController))
#define PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))
#define IS_PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_CONTROLLER))
#define IS_PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_CONTROLLER))
#define PLAYER_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))

typedef struct _PlayerController PlayerController;
typedef struct _PlayerControllerClass PlayerControllerClass;
typedef struct _PlayerControllerPrivate PlayerControllerPrivate;

#define TYPE_MPRIS_CONTROLLER (mpris_controller_get_type ())
#define MPRIS_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS_CONTROLLER, MprisController))
#define MPRIS_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MPRIS_CONTROLLER, MprisControllerClass))
#define IS_MPRIS_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS_CONTROLLER))
#define IS_MPRIS_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MPRIS_CONTROLLER))
#define MPRIS_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MPRIS_CONTROLLER, MprisControllerClass))

typedef struct _MprisController MprisController;
typedef struct _MprisControllerClass MprisControllerClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_MPRIS_CONTROLLER_V2 (mpris_controller_v2_get_type ())
#define MPRIS_CONTROLLER_V2(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS_CONTROLLER_V2, MprisControllerV2))
#define MPRIS_CONTROLLER_V2_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MPRIS_CONTROLLER_V2, MprisControllerV2Class))
#define IS_MPRIS_CONTROLLER_V2(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS_CONTROLLER_V2))
#define IS_MPRIS_CONTROLLER_V2_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MPRIS_CONTROLLER_V2))
#define MPRIS_CONTROLLER_V2_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MPRIS_CONTROLLER_V2, MprisControllerV2Class))

typedef struct _MprisControllerV2 MprisControllerV2;
typedef struct _MprisControllerV2Class MprisControllerV2Class;

#define TYPE_TRANSPORT_MENUITEM (transport_menuitem_get_type ())
#define TRANSPORT_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TRANSPORT_MENUITEM, TransportMenuitem))
#define TRANSPORT_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TRANSPORT_MENUITEM, TransportMenuitemClass))
#define IS_TRANSPORT_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TRANSPORT_MENUITEM))
#define IS_TRANSPORT_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TRANSPORT_MENUITEM))
#define TRANSPORT_MENUITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TRANSPORT_MENUITEM, TransportMenuitemClass))

typedef struct _TransportMenuitem TransportMenuitem;
typedef struct _TransportMenuitemClass TransportMenuitemClass;

#define TYPE_METADATA_MENUITEM (metadata_menuitem_get_type ())
#define METADATA_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_METADATA_MENUITEM, MetadataMenuitem))
#define METADATA_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_METADATA_MENUITEM, MetadataMenuitemClass))
#define IS_METADATA_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_METADATA_MENUITEM))
#define IS_METADATA_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_METADATA_MENUITEM))
#define METADATA_MENUITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_METADATA_MENUITEM, MetadataMenuitemClass))

typedef struct _MetadataMenuitem MetadataMenuitem;
typedef struct _MetadataMenuitemClass MetadataMenuitemClass;

struct _PlayerController {
	GObject parent_instance;
	PlayerControllerPrivate * priv;
};

struct _PlayerControllerClass {
	GObjectClass parent_class;
};

struct _PlayerControllerPrivate {
	DbusmenuMenuitem* root_menu;
	char* name;
	gboolean is_active;
	GeeArrayList* custom_items;
	MprisController* mpris_adaptor;
};


static gpointer player_controller_parent_class = NULL;

GType player_controller_get_type (void);
GType mpris_controller_get_type (void);
#define PLAYER_CONTROLLER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_PLAYER_CONTROLLER, PlayerControllerPrivate))
enum  {
	PLAYER_CONTROLLER_DUMMY_PROPERTY
};
#define PLAYER_CONTROLLER_METADATA 2
#define PLAYER_CONTROLLER_TRANSPORT 3
static char* player_controller_format_client_name (const char* client_name);
static gboolean player_controller_self_construct (PlayerController* self);
MprisControllerV2* mpris_controller_v2_new (const char* name, PlayerController* controller);
MprisControllerV2* mpris_controller_v2_construct (GType object_type, const char* name, PlayerController* controller);
GType mpris_controller_v2_get_type (void);
MprisController* mpris_controller_new (const char* name, PlayerController* controller, const char* mpris_interface);
MprisController* mpris_controller_construct (GType object_type, const char* name, PlayerController* controller, const char* mpris_interface);
GType transport_menuitem_get_type (void);
void transport_menuitem_set_adaptor (TransportMenuitem* self, MprisController* adaptor);
PlayerController* player_controller_new (DbusmenuMenuitem* root, const char* client_name, gboolean active);
PlayerController* player_controller_construct (GType object_type, DbusmenuMenuitem* root, const char* client_name, gboolean active);
void player_controller_vanish (PlayerController* self);
MetadataMenuitem* metadata_menuitem_new (void);
MetadataMenuitem* metadata_menuitem_construct (GType object_type);
GType metadata_menuitem_get_type (void);
TransportMenuitem* transport_menuitem_new (void);
TransportMenuitem* transport_menuitem_construct (GType object_type);
void metadata_menuitem_update (MetadataMenuitem* self, GeeHashMap* data);
void player_controller_update_playing_info (PlayerController* self, GeeHashMap* data);
static void player_controller_finalize (GObject* obj);
static int _vala_strcmp0 (const char * str1, const char * str2);



static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static char* string_strip (const char* self) {
	char* result = NULL;
	char* _result_;
	g_return_val_if_fail (self != NULL, NULL);
	_result_ = g_strdup (self);
	g_strstrip (_result_);
	result = _result_;
	return result;
}


PlayerController* player_controller_construct (GType object_type, DbusmenuMenuitem* root, const char* client_name, gboolean active) {
	PlayerController * self;
	DbusmenuMenuitem* _tmp0_;
	char* _tmp2_;
	char* _tmp1_;
	GeeArrayList* _tmp3_;
	TransportMenuitem* t;
	g_return_val_if_fail (root != NULL, NULL);
	g_return_val_if_fail (client_name != NULL, NULL);
	self = (PlayerController*) g_object_new (object_type, NULL);
	self->priv->root_menu = (_tmp0_ = _g_object_ref0 (root), _g_object_unref0 (self->priv->root_menu), _tmp0_);
	self->priv->name = (_tmp2_ = player_controller_format_client_name (_tmp1_ = string_strip (client_name)), _g_free0 (self->priv->name), _tmp2_);
	_g_free0 (_tmp1_);
	self->priv->is_active = active;
	self->priv->custom_items = (_tmp3_ = gee_array_list_new (DBUSMENU_TYPE_MENUITEM, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL), _g_object_unref0 (self->priv->custom_items), _tmp3_);
	player_controller_self_construct (self);
	if (_vala_strcmp0 (self->priv->name, "Vlc") == 0) {
		MprisController* _tmp4_;
		self->priv->mpris_adaptor = (_tmp4_ = (MprisController*) mpris_controller_v2_new (self->priv->name, self), _g_object_unref0 (self->priv->mpris_adaptor), _tmp4_);
	} else {
		MprisController* _tmp5_;
		self->priv->mpris_adaptor = (_tmp5_ = mpris_controller_new (self->priv->name, self, "org.freedesktop.MediaPlayer"), _g_object_unref0 (self->priv->mpris_adaptor), _tmp5_);
	}
	t = TRANSPORT_MENUITEM ((DbusmenuMenuitem*) gee_abstract_list_get ((GeeAbstractList*) self->priv->custom_items, PLAYER_CONTROLLER_TRANSPORT));
	transport_menuitem_set_adaptor (t, self->priv->mpris_adaptor);
	_g_object_unref0 (t);
	return self;
}


PlayerController* player_controller_new (DbusmenuMenuitem* root, const char* client_name, gboolean active) {
	return player_controller_construct (TYPE_PLAYER_CONTROLLER, root, client_name, active);
}


void player_controller_vanish (PlayerController* self) {
	g_return_if_fail (self != NULL);
	{
		GeeIterator* _item_it;
		_item_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->custom_items);
		while (TRUE) {
			DbusmenuMenuitem* item;
			if (!gee_iterator_next (_item_it)) {
				break;
			}
			item = (DbusmenuMenuitem*) gee_iterator_get (_item_it);
			dbusmenu_menuitem_child_delete (self->priv->root_menu, item);
			_g_object_unref0 (item);
		}
		_g_object_unref0 (_item_it);
	}
}


static gboolean player_controller_self_construct (PlayerController* self) {
	gboolean result = FALSE;
	DbusmenuMenuitem* separator_item;
	DbusmenuMenuitem* title_item;
	MetadataMenuitem* metadata_item;
	TransportMenuitem* transport_item;
	gint offset;
	g_return_val_if_fail (self != NULL, FALSE);
	separator_item = dbusmenu_menuitem_new ();
	dbusmenu_menuitem_property_set (separator_item, DBUSMENU_MENUITEM_PROP_TYPE, DBUSMENU_CLIENT_TYPES_SEPARATOR);
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->custom_items, separator_item);
	title_item = dbusmenu_menuitem_new ();
	dbusmenu_menuitem_property_set (title_item, DBUSMENU_MENUITEM_PROP_LABEL, self->priv->name);
	dbusmenu_menuitem_property_set (title_item, DBUSMENU_MENUITEM_PROP_ICON_NAME, "applications-multimedia");
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->custom_items, title_item);
	metadata_item = metadata_menuitem_new ();
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->custom_items, (DbusmenuMenuitem*) metadata_item);
	transport_item = transport_menuitem_new ();
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->custom_items, (DbusmenuMenuitem*) transport_item);
	offset = 2;
	{
		GeeIterator* _item_it;
		_item_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->custom_items);
		while (TRUE) {
			DbusmenuMenuitem* item;
			if (!gee_iterator_next (_item_it)) {
				break;
			}
			item = (DbusmenuMenuitem*) gee_iterator_get (_item_it);
			dbusmenu_menuitem_child_add_position (self->priv->root_menu, item, (guint) (offset + gee_abstract_list_index_of ((GeeAbstractList*) self->priv->custom_items, item)));
			_g_object_unref0 (item);
		}
		_g_object_unref0 (_item_it);
	}
	result = TRUE;
	_g_object_unref0 (separator_item);
	_g_object_unref0 (title_item);
	_g_object_unref0 (metadata_item);
	_g_object_unref0 (transport_item);
	return result;
}


void player_controller_update_playing_info (PlayerController* self, GeeHashMap* data) {
	MetadataMenuitem* item;
	g_return_if_fail (self != NULL);
	g_return_if_fail (data != NULL);
	g_debug ("player-controller.vala:95: PlayerController - update_playing_info");
	item = METADATA_MENUITEM ((DbusmenuMenuitem*) gee_abstract_list_get ((GeeAbstractList*) self->priv->custom_items, PLAYER_CONTROLLER_METADATA));
	metadata_menuitem_update (item, data);
	_g_object_unref0 (item);
}


static char* string_slice (const char* self, glong start, glong end) {
	char* result = NULL;
	glong string_length;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	const char* start_string;
	g_return_val_if_fail (self != NULL, NULL);
	string_length = g_utf8_strlen (self, -1);
	if (start < 0) {
		start = string_length + start;
	}
	if (end < 0) {
		end = string_length + end;
	}
	if (start >= 0) {
		_tmp0_ = start <= string_length;
	} else {
		_tmp0_ = FALSE;
	}
	g_return_val_if_fail (_tmp0_, NULL);
	if (end >= 0) {
		_tmp1_ = end <= string_length;
	} else {
		_tmp1_ = FALSE;
	}
	g_return_val_if_fail (_tmp1_, NULL);
	g_return_val_if_fail (start <= end, NULL);
	start_string = g_utf8_offset_to_pointer (self, start);
	result = g_strndup (start_string, ((gchar*) g_utf8_offset_to_pointer (start_string, end - start)) - ((gchar*) start_string));
	return result;
}


static char* player_controller_format_client_name (const char* client_name) {
	char* result = NULL;
	char* formatted;
	g_return_val_if_fail (client_name != NULL, NULL);
	formatted = g_strdup (client_name);
	if (g_utf8_strlen (formatted, -1) > 1) {
		char* _tmp2_;
		char* _tmp1_;
		char* _tmp0_;
		formatted = (_tmp2_ = g_strconcat (_tmp0_ = g_utf8_strup (client_name, (gssize) 1), _tmp1_ = string_slice (client_name, (glong) 1, g_utf8_strlen (client_name, -1)), NULL), _g_free0 (formatted), _tmp2_);
		_g_free0 (_tmp1_);
		_g_free0 (_tmp0_);
		g_debug ("player-controller.vala:105: PlayerController->format_client_name - : %" \
"s", formatted);
	}
	result = formatted;
	return result;
}


static void player_controller_class_init (PlayerControllerClass * klass) {
	player_controller_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (PlayerControllerPrivate));
	G_OBJECT_CLASS (klass)->finalize = player_controller_finalize;
}


static void player_controller_instance_init (PlayerController * self) {
	self->priv = PLAYER_CONTROLLER_GET_PRIVATE (self);
}


static void player_controller_finalize (GObject* obj) {
	PlayerController * self;
	self = PLAYER_CONTROLLER (obj);
	_g_object_unref0 (self->priv->root_menu);
	_g_free0 (self->priv->name);
	_g_object_unref0 (self->priv->custom_items);
	_g_object_unref0 (self->priv->mpris_adaptor);
	G_OBJECT_CLASS (player_controller_parent_class)->finalize (obj);
}


GType player_controller_get_type (void) {
	static volatile gsize player_controller_type_id__volatile = 0;
	if (g_once_init_enter (&player_controller_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (PlayerControllerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) player_controller_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PlayerController), 0, (GInstanceInitFunc) player_controller_instance_init, NULL };
		GType player_controller_type_id;
		player_controller_type_id = g_type_register_static (G_TYPE_OBJECT, "PlayerController", &g_define_type_info, 0);
		g_once_init_leave (&player_controller_type_id__volatile, player_controller_type_id);
	}
	return player_controller_type_id__volatile;
}


static int _vala_strcmp0 (const char * str1, const char * str2) {
	if (str1 == NULL) {
		return -(str1 != str2);
	}
	if (str2 == NULL) {
		return str1 != str2;
	}
	return strcmp (str1, str2);
}




