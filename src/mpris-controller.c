/* mpris-controller.c generated by valac, the Vala compiler
 * generated from mpris-controller.vala, do not modify */

/*
This service primarily controls PulseAudio and is driven by the sound indicator menu on the panel.
Copyright 2010 Canonical Ltd.

Authors:
    Conor Curran <conor.curran@canonical.com>

This program is free software: you can redistribute it and/or modify it 
under the terms of the GNU General Public License version 3, as published 
by the Free Software Foundation.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranties of 
MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along 
with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <glib.h>
#include <glib-object.h>
#include <dbus/dbus-glib-lowlevel.h>
#include <dbus/dbus-glib.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>
#include <libdbusmenu-glib/client.h>
#include <libdbusmenu-glib/menuitem-proxy.h>
#include <libdbusmenu-glib/menuitem.h>
#include <libdbusmenu-glib/server.h>
#include <float.h>
#include <math.h>


#define TYPE_MPRIS_CONTROLLER (mpris_controller_get_type ())
#define MPRIS_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS_CONTROLLER, MprisController))
#define MPRIS_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MPRIS_CONTROLLER, MprisControllerClass))
#define IS_MPRIS_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS_CONTROLLER))
#define IS_MPRIS_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MPRIS_CONTROLLER))
#define MPRIS_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MPRIS_CONTROLLER, MprisControllerClass))

typedef struct _MprisController MprisController;
typedef struct _MprisControllerClass MprisControllerClass;
typedef struct _MprisControllerPrivate MprisControllerPrivate;

#define TYPE_PLAYER_CONTROLLER (player_controller_get_type ())
#define PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_CONTROLLER, PlayerController))
#define PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))
#define IS_PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_CONTROLLER))
#define IS_PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_CONTROLLER))
#define PLAYER_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))

typedef struct _PlayerController PlayerController;
typedef struct _PlayerControllerClass PlayerControllerClass;
#define _dbus_g_connection_unref0(var) ((var == NULL) ? NULL : (var = (dbus_g_connection_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define MPRIS_CONTROLLER_TYPE_STATUS (mpris_controller_status_get_type ())
typedef struct _MprisControllerstatus MprisControllerstatus;
typedef struct _PlayerControllerPrivate PlayerControllerPrivate;

#define TYPE_PLAYER_ITEM (player_item_get_type ())
#define PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_ITEM, PlayerItem))
#define PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_ITEM, PlayerItemClass))
#define IS_PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_ITEM))
#define IS_PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_ITEM))
#define PLAYER_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_ITEM, PlayerItemClass))

typedef struct _PlayerItem PlayerItem;
typedef struct _PlayerItemClass PlayerItemClass;

#define PLAYER_CONTROLLER_TYPE_WIDGET_ORDER (player_controller_widget_order_get_type ())

#define TYPE_TRANSPORT_MENUITEM (transport_menuitem_get_type ())
#define TRANSPORT_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TRANSPORT_MENUITEM, TransportMenuitem))
#define TRANSPORT_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TRANSPORT_MENUITEM, TransportMenuitemClass))
#define IS_TRANSPORT_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TRANSPORT_MENUITEM))
#define IS_TRANSPORT_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TRANSPORT_MENUITEM))
#define TRANSPORT_MENUITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TRANSPORT_MENUITEM, TransportMenuitemClass))

typedef struct _TransportMenuitem TransportMenuitem;
typedef struct _TransportMenuitemClass TransportMenuitemClass;
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))

#define TYPE_SCRUB_MENUITEM (scrub_menuitem_get_type ())
#define SCRUB_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCRUB_MENUITEM, ScrubMenuitem))
#define SCRUB_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCRUB_MENUITEM, ScrubMenuitemClass))
#define IS_SCRUB_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCRUB_MENUITEM))
#define IS_SCRUB_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCRUB_MENUITEM))
#define SCRUB_MENUITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCRUB_MENUITEM, ScrubMenuitemClass))

typedef struct _ScrubMenuitem ScrubMenuitem;
typedef struct _ScrubMenuitemClass ScrubMenuitemClass;

#define TRANSPORT_MENUITEM_TYPE_ACTION (transport_menuitem_action_get_type ())
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _MprisController {
	GObject parent_instance;
	MprisControllerPrivate * priv;
};

struct _MprisControllerClass {
	GObjectClass parent_class;
};

struct _MprisControllerPrivate {
	DBusGConnection* connection;
	DBusGProxy* _mpris_player;
	PlayerController* _owner;
	char* _mpris_interface;
};

struct _MprisControllerstatus {
	gint32 playback;
	gint32 shuffle;
	gint32 repeat;
	gint32 endless;
};

struct _PlayerController {
	GObject parent_instance;
	PlayerControllerPrivate * priv;
	gint current_state;
	GeeArrayList* custom_items;
	MprisController* mpris_adaptor;
};

struct _PlayerControllerClass {
	GObjectClass parent_class;
};

typedef enum  {
	PLAYER_CONTROLLER_WIDGET_ORDER_SEPARATOR,
	PLAYER_CONTROLLER_WIDGET_ORDER_TITLE,
	PLAYER_CONTROLLER_WIDGET_ORDER_METADATA,
	PLAYER_CONTROLLER_WIDGET_ORDER_SCRUB,
	PLAYER_CONTROLLER_WIDGET_ORDER_TRANSPORT
} PlayerControllerwidget_order;

typedef enum  {
	TRANSPORT_MENUITEM_ACTION_PREVIOUS,
	TRANSPORT_MENUITEM_ACTION_PLAY_PAUSE,
	TRANSPORT_MENUITEM_ACTION_NEXT
} TransportMenuitemaction;


static gpointer mpris_controller_parent_class = NULL;

GType mpris_controller_get_type (void);
GType player_controller_get_type (void);
#define MPRIS_CONTROLLER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_MPRIS_CONTROLLER, MprisControllerPrivate))
enum  {
	MPRIS_CONTROLLER_DUMMY_PROPERTY,
	MPRIS_CONTROLLER_MPRIS_PLAYER,
	MPRIS_CONTROLLER_OWNER,
	MPRIS_CONTROLLER_MPRIS_INTERFACE
};
MprisController* mpris_controller_new (PlayerController* ctrl, const char* inter);
MprisController* mpris_controller_construct (GType object_type, PlayerController* ctrl, const char* inter);
DBusGProxy* mpris_controller_get_mpris_player (MprisController* self);
static GType mpris_controller_status_get_type (void) G_GNUC_UNUSED;
static MprisControllerstatus* mpris_controller_status_dup (const MprisControllerstatus* self);
static void mpris_controller_status_free (MprisControllerstatus* self);
static void _dynamic_GetStatus0 (DBusGProxy* self, MprisControllerstatus* result, GError** error);
PlayerController* mpris_controller_get_owner (MprisController* self);
GType player_item_get_type (void);
GType player_controller_widget_order_get_type (void);
GType transport_menuitem_get_type (void);
void transport_menuitem_change_play_state (TransportMenuitem* self, gint state);
static GHashTable* _dynamic_GetMetadata1 (DBusGProxy* self, GError** error);
void player_item_update (PlayerItem* self, GHashTable* data, GeeHashSet* attributes);
GeeHashSet* metadata_menuitem_attributes_format (void);
static GHashTable* _dynamic_GetMetadata2 (DBusGProxy* self, GError** error);
GeeHashSet* scrub_menuitem_attributes_format (void);
GType scrub_menuitem_get_type (void);
static gint32 _dynamic_PositionGet3 (DBusGProxy* self, GError** error);
void scrub_menuitem_update_position (ScrubMenuitem* self, gint32 new_position);
static void mpris_controller_initial_update (MprisController* self);
GType transport_menuitem_action_get_type (void);
static void _dynamic_Pause4 (DBusGProxy* self, GError** error);
static void _dynamic_Prev5 (DBusGProxy* self, GError** error);
static void _dynamic_Next6 (DBusGProxy* self, GError** error);
void mpris_controller_transport_event (MprisController* self, TransportMenuitemaction command);
static GHashTable* _dynamic_GetMetadata7 (DBusGProxy* self, GError** error);
static GValue* _g_value_dup (GValue* self);
static void _dynamic_PositionSet8 (DBusGProxy* self, gint32 param1, GError** error);
static gint32 _dynamic_PositionGet9 (DBusGProxy* self, GError** error);
void mpris_controller_set_position (MprisController* self, double position);
gboolean mpris_controller_connected (MprisController* self);
GeeHashSet* transport_menuitem_attributes_format (void);
static void mpris_controller_onStatusChange (MprisController* self, DBusGProxy* mpris_client, MprisControllerstatus* st);
void player_item_reset (PlayerItem* self, GeeHashSet* attrs);
static GHashTable* _dynamic_GetMetadata10 (DBusGProxy* self, GError** error);
static gint32 _dynamic_PositionGet11 (DBusGProxy* self, GError** error);
static void mpris_controller_onTrackChange (MprisController* self, DBusGProxy* mpris_client, GHashTable* ht);
static void mpris_controller_set_mpris_player (MprisController* self, DBusGProxy* value);
static void mpris_controller_set_owner (MprisController* self, PlayerController* value);
const char* mpris_controller_get_mpris_interface (MprisController* self);
static void mpris_controller_set_mpris_interface (MprisController* self, const char* value);
const char* player_controller_get_name (PlayerController* self);
static void _mpris_controller_onTrackChange_dynamic_TrackChange0_ (DBusGProxy* _sender, GHashTable* ht, gpointer self);
void _dynamic_TrackChange1_connect (gpointer obj, const char * signal_name, GCallback handler, gpointer data);
static void _mpris_controller_onStatusChange_dynamic_StatusChange2_ (DBusGProxy* _sender, MprisControllerstatus* st, gpointer self);
void _dynamic_StatusChange3_connect (gpointer obj, const char * signal_name, GCallback handler, gpointer data);
static GObject * mpris_controller_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void mpris_controller_finalize (GObject* obj);
static void mpris_controller_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void mpris_controller_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);


static void g_cclosure_user_marshal_VOID__BOXED (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);

MprisController* mpris_controller_construct (GType object_type, PlayerController* ctrl, const char* inter) {
	MprisController * self;
	g_return_val_if_fail (ctrl != NULL, NULL);
	g_return_val_if_fail (inter != NULL, NULL);
	self = (MprisController*) g_object_new (object_type, "owner", ctrl, "mpris-interface", inter, NULL);
	return self;
}


MprisController* mpris_controller_new (PlayerController* ctrl, const char* inter) {
	return mpris_controller_construct (TYPE_MPRIS_CONTROLLER, ctrl, inter);
}


static void _dynamic_GetStatus0 (DBusGProxy* self, MprisControllerstatus* result, GError** error) {
	GValueArray* dbus_result;
	dbus_g_proxy_call (self, "GetStatus", error, G_TYPE_INVALID, dbus_g_type_get_struct ("GValueArray", G_TYPE_INT, G_TYPE_INT, G_TYPE_INT, G_TYPE_INT, G_TYPE_INVALID), &dbus_result, G_TYPE_INVALID);
	if (*error) {
		return;
	}
	result->playback = g_value_get_int (&dbus_result->values[0]);
	result->shuffle = g_value_get_int (&dbus_result->values[1]);
	result->repeat = g_value_get_int (&dbus_result->values[2]);
	result->endless = g_value_get_int (&dbus_result->values[3]);
}


static GHashTable* _dynamic_GetMetadata1 (DBusGProxy* self, GError** error) {
	GHashTable* result;
	dbus_g_proxy_call (self, "GetMetadata", error, G_TYPE_INVALID, dbus_g_type_get_map ("GHashTable", G_TYPE_STRING, G_TYPE_VALUE), &result, G_TYPE_INVALID);
	if (*error) {
		return NULL;
	}
	return result;
}


static GHashTable* _dynamic_GetMetadata2 (DBusGProxy* self, GError** error) {
	GHashTable* result;
	dbus_g_proxy_call (self, "GetMetadata", error, G_TYPE_INVALID, dbus_g_type_get_map ("GHashTable", G_TYPE_STRING, G_TYPE_VALUE), &result, G_TYPE_INVALID);
	if (*error) {
		return NULL;
	}
	return result;
}


static gint32 _dynamic_PositionGet3 (DBusGProxy* self, GError** error) {
	gint32 result;
	dbus_g_proxy_call (self, "PositionGet", error, G_TYPE_INVALID, G_TYPE_INT, &result, G_TYPE_INVALID);
	if (*error) {
		return 0;
	}
	return result;
}


static void mpris_controller_initial_update (MprisController* self) {
	GError * _inner_error_;
	MprisControllerstatus _tmp0_ = {0};
	MprisControllerstatus st;
	gint play_state;
	TransportMenuitem* _tmp2_;
	PlayerItem* _tmp1_;
	GHashTable* _tmp3_;
	GeeHashSet* _tmp6_;
	GHashTable* _tmp5_;
	PlayerItem* _tmp4_;
	GHashTable* _tmp7_;
	GeeHashSet* _tmp10_;
	GHashTable* _tmp9_;
	PlayerItem* _tmp8_;
	PlayerItem* _tmp11_;
	ScrubMenuitem* scrub;
	gint32 _tmp12_;
	g_return_if_fail (self != NULL);
	_inner_error_ = NULL;
	st = (_dynamic_GetStatus0 (self->priv->_mpris_player, &_tmp0_, &_inner_error_), _tmp0_);
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	play_state = (gint) st.playback;
	g_debug ("mpris-controller.vala:60: GetStatusChange - play state %i", play_state);
	transport_menuitem_change_play_state (_tmp2_ = (_tmp1_ = (PlayerItem*) gee_abstract_list_get ((GeeAbstractList*) self->priv->_owner->custom_items, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_TRANSPORT), IS_TRANSPORT_MENUITEM (_tmp1_) ? ((TransportMenuitem*) _tmp1_) : NULL), play_state);
	_g_object_unref0 (_tmp2_);
	_tmp3_ = _dynamic_GetMetadata1 (self->priv->_mpris_player, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	player_item_update (_tmp4_ = (PlayerItem*) gee_abstract_list_get ((GeeAbstractList*) self->priv->_owner->custom_items, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_METADATA), _tmp5_ = _tmp3_, _tmp6_ = metadata_menuitem_attributes_format ());
	_g_object_unref0 (_tmp6_);
	_g_hash_table_unref0 (_tmp5_);
	_g_object_unref0 (_tmp4_);
	_tmp7_ = _dynamic_GetMetadata2 (self->priv->_mpris_player, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	player_item_update (_tmp8_ = (PlayerItem*) gee_abstract_list_get ((GeeAbstractList*) self->priv->_owner->custom_items, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_SCRUB), _tmp9_ = _tmp7_, _tmp10_ = scrub_menuitem_attributes_format ());
	_g_object_unref0 (_tmp10_);
	_g_hash_table_unref0 (_tmp9_);
	_g_object_unref0 (_tmp8_);
	scrub = (_tmp11_ = (PlayerItem*) gee_abstract_list_get ((GeeAbstractList*) self->priv->_owner->custom_items, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_SCRUB), IS_SCRUB_MENUITEM (_tmp11_) ? ((ScrubMenuitem*) _tmp11_) : NULL);
	_tmp12_ = _dynamic_PositionGet3 (self->priv->_mpris_player, &_inner_error_);
	if (_inner_error_ != NULL) {
		_g_object_unref0 (scrub);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	scrub_menuitem_update_position (scrub, _tmp12_);
	_g_object_unref0 (scrub);
}


static void _dynamic_Pause4 (DBusGProxy* self, GError** error) {
	dbus_g_proxy_call (self, "Pause", error, G_TYPE_INVALID, G_TYPE_INVALID);
	if (*error) {
		return;
	}
}


static void _dynamic_Prev5 (DBusGProxy* self, GError** error) {
	dbus_g_proxy_call (self, "Prev", error, G_TYPE_INVALID, G_TYPE_INVALID);
	if (*error) {
		return;
	}
}


static void _dynamic_Next6 (DBusGProxy* self, GError** error) {
	dbus_g_proxy_call (self, "Next", error, G_TYPE_INVALID, G_TYPE_INVALID);
	if (*error) {
		return;
	}
}


void mpris_controller_transport_event (MprisController* self, TransportMenuitemaction command) {
	GError * _inner_error_;
	g_return_if_fail (self != NULL);
	_inner_error_ = NULL;
	g_debug ("mpris-controller.vala:73: transport_event input = %i", (gint) command);
	if (command == TRANSPORT_MENUITEM_ACTION_PLAY_PAUSE) {
		g_debug ("mpris-controller.vala:75: transport_event PLAY_PAUSE");
		_dynamic_Pause4 (self->priv->_mpris_player, &_inner_error_);
		if (_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	} else {
		if (command == TRANSPORT_MENUITEM_ACTION_PREVIOUS) {
			_dynamic_Prev5 (self->priv->_mpris_player, &_inner_error_);
			if (_inner_error_ != NULL) {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		} else {
			if (command == TRANSPORT_MENUITEM_ACTION_NEXT) {
				_dynamic_Next6 (self->priv->_mpris_player, &_inner_error_);
				if (_inner_error_ != NULL) {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
		}
	}
}


static GHashTable* _dynamic_GetMetadata7 (DBusGProxy* self, GError** error) {
	GHashTable* result;
	dbus_g_proxy_call (self, "GetMetadata", error, G_TYPE_INVALID, dbus_g_type_get_map ("GHashTable", G_TYPE_STRING, G_TYPE_VALUE), &result, G_TYPE_INVALID);
	if (*error) {
		return NULL;
	}
	return result;
}


static GValue* _g_value_dup (GValue* self) {
	return g_boxed_copy (G_TYPE_VALUE, self);
}


static gpointer __g_value_dup0 (gpointer self) {
	return self ? _g_value_dup (self) : NULL;
}


static void _dynamic_PositionSet8 (DBusGProxy* self, gint32 param1, GError** error) {
	dbus_g_proxy_call (self, "PositionSet", error, G_TYPE_INT, param1, G_TYPE_INVALID, G_TYPE_INVALID);
	if (*error) {
		return;
	}
}


static gint32 _dynamic_PositionGet9 (DBusGProxy* self, GError** error) {
	gint32 result;
	dbus_g_proxy_call (self, "PositionGet", error, G_TYPE_INVALID, G_TYPE_INT, &result, G_TYPE_INVALID);
	if (*error) {
		return 0;
	}
	return result;
}


void mpris_controller_set_position (MprisController* self, double position) {
	GError * _inner_error_;
	GHashTable* data;
	GValue* time_value;
	guint32 total_time;
	double new_time_position;
	PlayerItem* _tmp0_;
	ScrubMenuitem* scrub;
	gint32 _tmp1_;
	g_return_if_fail (self != NULL);
	_inner_error_ = NULL;
	g_debug ("mpris-controller.vala:88: Set position with pos (0-100) %f", position);
	data = _dynamic_GetMetadata7 (self->priv->_mpris_player, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	time_value = __g_value_dup0 ((GValue*) g_hash_table_lookup (data, "time"));
	if (time_value == NULL) {
		g_warning ("mpris-controller.vala:92: Can't fetch the duration of the track theref" \
"ore cant set the position");
		_g_hash_table_unref0 (data);
		_g_free0 (time_value);
		return;
	}
	total_time = (guint32) g_value_get_uint (time_value);
	g_debug ("mpris-controller.vala:96: total time of track = %i", (gint) total_time);
	new_time_position = (total_time * position) / 100.0;
	g_debug ("mpris-controller.vala:98: new position = %f", new_time_position * 1000);
	_dynamic_PositionSet8 (self->priv->_mpris_player, (gint32) new_time_position, &_inner_error_);
	if (_inner_error_ != NULL) {
		_g_hash_table_unref0 (data);
		_g_free0 (time_value);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	scrub = (_tmp0_ = (PlayerItem*) gee_abstract_list_get ((GeeAbstractList*) self->priv->_owner->custom_items, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_SCRUB), IS_SCRUB_MENUITEM (_tmp0_) ? ((ScrubMenuitem*) _tmp0_) : NULL);
	_tmp1_ = _dynamic_PositionGet9 (self->priv->_mpris_player, &_inner_error_);
	if (_inner_error_ != NULL) {
		_g_hash_table_unref0 (data);
		_g_free0 (time_value);
		_g_object_unref0 (scrub);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	scrub_menuitem_update_position (scrub, _tmp1_);
	_g_hash_table_unref0 (data);
	_g_free0 (time_value);
	_g_object_unref0 (scrub);
}


gboolean mpris_controller_connected (MprisController* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_mpris_player != NULL;
	return result;
}


static void mpris_controller_onStatusChange (MprisController* self, DBusGProxy* mpris_client, MprisControllerstatus* st) {
	MprisControllerstatus* status;
	GValueArray* ar;
	gint play_state;
	GHashTable* ht;
	GValue v = {0};
	GeeHashSet* _tmp1_;
	PlayerItem* _tmp0_;
	GeeHashSet* _tmp3_;
	PlayerItem* _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (mpris_client != NULL);
	g_debug ("mpris-controller.vala:111: onStatusChange - signal received");
	status = st;
	ar = (GValueArray*) status;
	play_state = g_value_get_int (g_value_array_get_nth (ar, (guint) 0));
	g_debug ("mpris-controller.vala:115: onStatusChange - play state %i", play_state);
	ht = g_hash_table_new (g_str_hash, g_str_equal);
	g_value_init (&v, G_TYPE_INT);
	g_value_set_int (&v, play_state);
	g_hash_table_insert (ht, g_strdup ("state"), __g_value_dup0 (&v));
	player_item_update (_tmp0_ = (PlayerItem*) gee_abstract_list_get ((GeeAbstractList*) self->priv->_owner->custom_items, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_TRANSPORT), ht, _tmp1_ = transport_menuitem_attributes_format ());
	_g_object_unref0 (_tmp1_);
	_g_object_unref0 (_tmp0_);
	player_item_update (_tmp2_ = (PlayerItem*) gee_abstract_list_get ((GeeAbstractList*) self->priv->_owner->custom_items, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_SCRUB), ht, _tmp3_ = scrub_menuitem_attributes_format ());
	_g_object_unref0 (_tmp3_);
	_g_object_unref0 (_tmp2_);
	_g_hash_table_unref0 (ht);
	G_IS_VALUE (&v) ? (g_value_unset (&v), NULL) : NULL;
}


static GHashTable* _dynamic_GetMetadata10 (DBusGProxy* self, GError** error) {
	GHashTable* result;
	dbus_g_proxy_call (self, "GetMetadata", error, G_TYPE_INVALID, dbus_g_type_get_map ("GHashTable", G_TYPE_STRING, G_TYPE_VALUE), &result, G_TYPE_INVALID);
	if (*error) {
		return NULL;
	}
	return result;
}


static gint32 _dynamic_PositionGet11 (DBusGProxy* self, GError** error) {
	gint32 result;
	dbus_g_proxy_call (self, "PositionGet", error, G_TYPE_INVALID, G_TYPE_INT, &result, G_TYPE_INVALID);
	if (*error) {
		return 0;
	}
	return result;
}


static void mpris_controller_onTrackChange (MprisController* self, DBusGProxy* mpris_client, GHashTable* ht) {
	GError * _inner_error_;
	GeeHashSet* _tmp1_;
	PlayerItem* _tmp0_;
	GeeHashSet* _tmp3_;
	PlayerItem* _tmp2_;
	GeeHashSet* _tmp5_;
	PlayerItem* _tmp4_;
	GHashTable* _tmp6_;
	GeeHashSet* _tmp9_;
	GHashTable* _tmp8_;
	PlayerItem* _tmp7_;
	PlayerItem* _tmp10_;
	ScrubMenuitem* scrub;
	gint32 _tmp11_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (mpris_client != NULL);
	g_return_if_fail (ht != NULL);
	_inner_error_ = NULL;
	g_debug ("mpris-controller.vala:126: onTrackChange");
	player_item_reset (_tmp0_ = (PlayerItem*) gee_abstract_list_get ((GeeAbstractList*) self->priv->_owner->custom_items, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_METADATA), _tmp1_ = metadata_menuitem_attributes_format ());
	_g_object_unref0 (_tmp1_);
	_g_object_unref0 (_tmp0_);
	player_item_reset (_tmp2_ = (PlayerItem*) gee_abstract_list_get ((GeeAbstractList*) self->priv->_owner->custom_items, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_SCRUB), _tmp3_ = scrub_menuitem_attributes_format ());
	_g_object_unref0 (_tmp3_);
	_g_object_unref0 (_tmp2_);
	player_item_update (_tmp4_ = (PlayerItem*) gee_abstract_list_get ((GeeAbstractList*) self->priv->_owner->custom_items, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_METADATA), ht, _tmp5_ = metadata_menuitem_attributes_format ());
	_g_object_unref0 (_tmp5_);
	_g_object_unref0 (_tmp4_);
	g_debug ("mpris-controller.vala:131: about to update the duration on the scrub b" \
"ar");
	_tmp6_ = _dynamic_GetMetadata10 (self->priv->_mpris_player, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	player_item_update (_tmp7_ = (PlayerItem*) gee_abstract_list_get ((GeeAbstractList*) self->priv->_owner->custom_items, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_SCRUB), _tmp8_ = _tmp6_, _tmp9_ = scrub_menuitem_attributes_format ());
	_g_object_unref0 (_tmp9_);
	_g_hash_table_unref0 (_tmp8_);
	_g_object_unref0 (_tmp7_);
	scrub = (_tmp10_ = (PlayerItem*) gee_abstract_list_get ((GeeAbstractList*) self->priv->_owner->custom_items, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_SCRUB), IS_SCRUB_MENUITEM (_tmp10_) ? ((ScrubMenuitem*) _tmp10_) : NULL);
	_tmp11_ = _dynamic_PositionGet11 (self->priv->_mpris_player, &_inner_error_);
	if (_inner_error_ != NULL) {
		_g_object_unref0 (scrub);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	scrub_menuitem_update_position (scrub, _tmp11_);
	_g_object_unref0 (scrub);
}


DBusGProxy* mpris_controller_get_mpris_player (MprisController* self) {
	DBusGProxy* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_mpris_player;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void mpris_controller_set_mpris_player (MprisController* self, DBusGProxy* value) {
	DBusGProxy* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_mpris_player = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_mpris_player), _tmp0_);
	g_object_notify ((GObject *) self, "mpris-player");
}


PlayerController* mpris_controller_get_owner (MprisController* self) {
	PlayerController* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_owner;
	return result;
}


static void mpris_controller_set_owner (MprisController* self, PlayerController* value) {
	PlayerController* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_owner = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_owner), _tmp0_);
	g_object_notify ((GObject *) self, "owner");
}


const char* mpris_controller_get_mpris_interface (MprisController* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_mpris_interface;
	return result;
}


static void mpris_controller_set_mpris_interface (MprisController* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_mpris_interface = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_mpris_interface), _tmp0_);
	g_object_notify ((GObject *) self, "mpris-interface");
}


static void _mpris_controller_onTrackChange_dynamic_TrackChange0_ (DBusGProxy* _sender, GHashTable* ht, gpointer self) {
	mpris_controller_onTrackChange (self, _sender, ht);
}


void _dynamic_TrackChange1_connect (gpointer obj, const char * signal_name, GCallback handler, gpointer data) {
	dbus_g_object_register_marshaller (g_cclosure_user_marshal_VOID__BOXED, G_TYPE_NONE, dbus_g_type_get_map ("GHashTable", G_TYPE_STRING, G_TYPE_VALUE), G_TYPE_INVALID);
	dbus_g_proxy_add_signal (obj, "TrackChange", dbus_g_type_get_map ("GHashTable", G_TYPE_STRING, G_TYPE_VALUE), G_TYPE_INVALID);
	dbus_g_proxy_connect_signal (obj, signal_name, handler, data, NULL);
}


static void _mpris_controller_onStatusChange_dynamic_StatusChange2_ (DBusGProxy* _sender, MprisControllerstatus* st, gpointer self) {
	mpris_controller_onStatusChange (self, _sender, st);
}


void _dynamic_StatusChange3_connect (gpointer obj, const char * signal_name, GCallback handler, gpointer data) {
	dbus_g_object_register_marshaller (g_cclosure_user_marshal_VOID__BOXED, G_TYPE_NONE, dbus_g_type_get_struct ("GValueArray", G_TYPE_INT, G_TYPE_INT, G_TYPE_INT, G_TYPE_INT, G_TYPE_INVALID), G_TYPE_INVALID);
	dbus_g_proxy_add_signal (obj, "StatusChange", dbus_g_type_get_struct ("GValueArray", G_TYPE_INT, G_TYPE_INT, G_TYPE_INT, G_TYPE_INT, G_TYPE_INVALID), G_TYPE_INVALID);
	dbus_g_proxy_connect_signal (obj, signal_name, handler, data, NULL);
}


static GObject * mpris_controller_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	MprisController * self;
	GError * _inner_error_;
	parent_class = G_OBJECT_CLASS (mpris_controller_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = MPRIS_CONTROLLER (obj);
	_inner_error_ = NULL;
	{
		DBusGProxy* _tmp4_;
		char* _tmp3_;
		char* _tmp2_;
		char* _tmp6_;
		char* _tmp5_;
		{
			DBusGConnection* _tmp0_;
			DBusGConnection* _tmp1_;
			_tmp0_ = dbus_g_bus_get (DBUS_BUS_SESSION, &_inner_error_);
			if (_inner_error_ != NULL) {
				goto __catch1_g_error;
			}
			self->priv->connection = (_tmp1_ = _tmp0_, _dbus_g_connection_unref0 (self->priv->connection), _tmp1_);
		}
		goto __finally1;
		__catch1_g_error:
		{
			GError * e;
			e = _inner_error_;
			_inner_error_ = NULL;
			{
				g_error ("mpris-controller.vala:45: Problems connecting to the session bus - %s", e->message);
				_g_error_free0 (e);
			}
		}
		__finally1:
		if (_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
		}
		mpris_controller_set_mpris_player (self, _tmp4_ = dbus_g_proxy_new_for_name (self->priv->connection, _tmp3_ = g_strconcat ("org.mpris.", _tmp2_ = g_utf8_strdown (player_controller_get_name (self->priv->_owner), -1), NULL), "/Player", self->priv->_mpris_interface));
		_g_object_unref0 (_tmp4_);
		_g_free0 (_tmp3_);
		_g_free0 (_tmp2_);
		g_debug ("mpris-controller.vala:49: Attempting to establish an mpris connection " \
"to %s, %s, %s", _tmp6_ = g_strconcat ("org.mpris.", _tmp5_ = g_utf8_strdown (player_controller_get_name (self->priv->_owner), -1), NULL), "/Player", self->priv->_mpris_interface);
		_g_free0 (_tmp6_);
		_g_free0 (_tmp5_);
		_dynamic_TrackChange1_connect (self->priv->_mpris_player, "TrackChange", (GCallback) _mpris_controller_onTrackChange_dynamic_TrackChange0_, self);
		_dynamic_StatusChange3_connect (self->priv->_mpris_player, "StatusChange", (GCallback) _mpris_controller_onStatusChange_dynamic_StatusChange2_, self);
		mpris_controller_initial_update (self);
	}
	return obj;
}


static MprisControllerstatus* mpris_controller_status_dup (const MprisControllerstatus* self) {
	MprisControllerstatus* dup;
	dup = g_new0 (MprisControllerstatus, 1);
	memcpy (dup, self, sizeof (MprisControllerstatus));
	return dup;
}


static void mpris_controller_status_free (MprisControllerstatus* self) {
	g_free (self);
}


static GType mpris_controller_status_get_type (void) {
	static volatile gsize mpris_controller_status_type_id__volatile = 0;
	if (g_once_init_enter (&mpris_controller_status_type_id__volatile)) {
		GType mpris_controller_status_type_id;
		mpris_controller_status_type_id = g_boxed_type_register_static ("MprisControllerstatus", (GBoxedCopyFunc) mpris_controller_status_dup, (GBoxedFreeFunc) mpris_controller_status_free);
		g_once_init_leave (&mpris_controller_status_type_id__volatile, mpris_controller_status_type_id);
	}
	return mpris_controller_status_type_id__volatile;
}


static void mpris_controller_class_init (MprisControllerClass * klass) {
	mpris_controller_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (MprisControllerPrivate));
	G_OBJECT_CLASS (klass)->get_property = mpris_controller_get_property;
	G_OBJECT_CLASS (klass)->set_property = mpris_controller_set_property;
	G_OBJECT_CLASS (klass)->constructor = mpris_controller_constructor;
	G_OBJECT_CLASS (klass)->finalize = mpris_controller_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), MPRIS_CONTROLLER_MPRIS_PLAYER, g_param_spec_object ("mpris-player", "mpris-player", "mpris-player", DBUS_TYPE_G_PROXY, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MPRIS_CONTROLLER_OWNER, g_param_spec_object ("owner", "owner", "owner", TYPE_PLAYER_CONTROLLER, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MPRIS_CONTROLLER_MPRIS_INTERFACE, g_param_spec_string ("mpris-interface", "mpris-interface", "mpris-interface", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
}


static void mpris_controller_instance_init (MprisController * self) {
	self->priv = MPRIS_CONTROLLER_GET_PRIVATE (self);
}


static void mpris_controller_finalize (GObject* obj) {
	MprisController * self;
	self = MPRIS_CONTROLLER (obj);
	_dbus_g_connection_unref0 (self->priv->connection);
	_g_object_unref0 (self->priv->_mpris_player);
	_g_object_unref0 (self->priv->_owner);
	_g_free0 (self->priv->_mpris_interface);
	G_OBJECT_CLASS (mpris_controller_parent_class)->finalize (obj);
}


GType mpris_controller_get_type (void) {
	static volatile gsize mpris_controller_type_id__volatile = 0;
	if (g_once_init_enter (&mpris_controller_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (MprisControllerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) mpris_controller_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MprisController), 0, (GInstanceInitFunc) mpris_controller_instance_init, NULL };
		GType mpris_controller_type_id;
		mpris_controller_type_id = g_type_register_static (G_TYPE_OBJECT, "MprisController", &g_define_type_info, 0);
		g_once_init_leave (&mpris_controller_type_id__volatile, mpris_controller_type_id);
	}
	return mpris_controller_type_id__volatile;
}


static void mpris_controller_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	MprisController * self;
	self = MPRIS_CONTROLLER (object);
	switch (property_id) {
		case MPRIS_CONTROLLER_MPRIS_PLAYER:
		g_value_set_object (value, mpris_controller_get_mpris_player (self));
		break;
		case MPRIS_CONTROLLER_OWNER:
		g_value_set_object (value, mpris_controller_get_owner (self));
		break;
		case MPRIS_CONTROLLER_MPRIS_INTERFACE:
		g_value_set_string (value, mpris_controller_get_mpris_interface (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void mpris_controller_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	MprisController * self;
	self = MPRIS_CONTROLLER (object);
	switch (property_id) {
		case MPRIS_CONTROLLER_MPRIS_PLAYER:
		mpris_controller_set_mpris_player (self, g_value_get_object (value));
		break;
		case MPRIS_CONTROLLER_OWNER:
		mpris_controller_set_owner (self, g_value_get_object (value));
		break;
		case MPRIS_CONTROLLER_MPRIS_INTERFACE:
		mpris_controller_set_mpris_interface (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



static void g_cclosure_user_marshal_VOID__BOXED (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__BOXED) (gpointer data1, gpointer arg_1, gpointer data2);
	register GMarshalFunc_VOID__BOXED callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 2);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__BOXED) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_boxed (param_values + 1), data2);
}



