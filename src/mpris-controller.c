/* mpris-controller.c generated by valac, the Vala compiler
 * generated from mpris-controller.vala, do not modify */

/*
This service primarily controls PulseAudio and is driven by the sound indicator menu on the panel.
Copyright 2010 Canonical Ltd.

Authors:
    Conor Curran <conor.curran@canonical.com>

This program is free software: you can redistribute it and/or modify it 
under the terms of the GNU General Public License version 3, as published 
by the Free Software Foundation.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranties of 
MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along 
with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <glib.h>
#include <glib-object.h>
#include <dbus/dbus-glib-lowlevel.h>
#include <dbus/dbus-glib.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>
#include <libdbusmenu-glib/client.h>
#include <libdbusmenu-glib/menuitem-proxy.h>
#include <libdbusmenu-glib/menuitem.h>
#include <libdbusmenu-glib/server.h>


#define TYPE_MPRIS_CONTROLLER (mpris_controller_get_type ())
#define MPRIS_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS_CONTROLLER, MprisController))
#define MPRIS_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MPRIS_CONTROLLER, MprisControllerClass))
#define IS_MPRIS_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS_CONTROLLER))
#define IS_MPRIS_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MPRIS_CONTROLLER))
#define MPRIS_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MPRIS_CONTROLLER, MprisControllerClass))

typedef struct _MprisController MprisController;
typedef struct _MprisControllerClass MprisControllerClass;
typedef struct _MprisControllerPrivate MprisControllerPrivate;

#define TYPE_PLAYER_CONTROLLER (player_controller_get_type ())
#define PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_CONTROLLER, PlayerController))
#define PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))
#define IS_PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_CONTROLLER))
#define IS_PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_CONTROLLER))
#define PLAYER_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))

typedef struct _PlayerController PlayerController;
typedef struct _PlayerControllerClass PlayerControllerClass;
#define _dbus_g_connection_unref0(var) ((var == NULL) ? NULL : (var = (dbus_g_connection_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define MPRIS_CONTROLLER_TYPE_STATUS (mpris_controller_status_get_type ())
typedef struct _MprisControllerstatus MprisControllerstatus;
typedef struct _PlayerControllerPrivate PlayerControllerPrivate;

#define TYPE_PLAYER_ITEM (player_item_get_type ())
#define PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_ITEM, PlayerItem))
#define PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_ITEM, PlayerItemClass))
#define IS_PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_ITEM))
#define IS_PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_ITEM))
#define PLAYER_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_ITEM, PlayerItemClass))

typedef struct _PlayerItem PlayerItem;
typedef struct _PlayerItemClass PlayerItemClass;

#define TYPE_TRANSPORT_MENUITEM (transport_menuitem_get_type ())
#define TRANSPORT_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TRANSPORT_MENUITEM, TransportMenuitem))
#define TRANSPORT_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TRANSPORT_MENUITEM, TransportMenuitemClass))
#define IS_TRANSPORT_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TRANSPORT_MENUITEM))
#define IS_TRANSPORT_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TRANSPORT_MENUITEM))
#define TRANSPORT_MENUITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TRANSPORT_MENUITEM, TransportMenuitemClass))

typedef struct _TransportMenuitem TransportMenuitem;
typedef struct _TransportMenuitemClass TransportMenuitemClass;
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))

struct _MprisController {
	GObject parent_instance;
	MprisControllerPrivate * priv;
	DBusGProxy* mpris_player;
};

struct _MprisControllerClass {
	GObjectClass parent_class;
};

struct _MprisControllerPrivate {
	DBusGConnection* connection;
	PlayerController* controller;
};

struct _MprisControllerstatus {
	gint32 playback;
	gint32 shuffle;
	gint32 repeat;
	gint32 endless;
};

struct _PlayerController {
	GObject parent_instance;
	PlayerControllerPrivate * priv;
	GeeArrayList* custom_items;
};

struct _PlayerControllerClass {
	GObjectClass parent_class;
};


static gpointer mpris_controller_parent_class = NULL;

GType mpris_controller_get_type (void);
GType player_controller_get_type (void);
#define MPRIS_CONTROLLER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_MPRIS_CONTROLLER, MprisControllerPrivate))
enum  {
	MPRIS_CONTROLLER_DUMMY_PROPERTY
};
static void mpris_controller_onTrackChange (MprisController* self, DBusGProxy* mpris_client, GHashTable* ht);
static void _mpris_controller_onTrackChange_dynamic_TrackChange0_ (DBusGProxy* _sender, GHashTable* ht, gpointer self);
void _dynamic_TrackChange1_connect (gpointer obj, const char * signal_name, GCallback handler, gpointer data);
static GType mpris_controller_status_get_type (void) G_GNUC_UNUSED;
static MprisControllerstatus* mpris_controller_status_dup (const MprisControllerstatus* self);
static void mpris_controller_status_free (MprisControllerstatus* self);
static void mpris_controller_onStatusChange (MprisController* self, DBusGProxy* mpris_client, MprisControllerstatus* st);
static void _mpris_controller_onStatusChange_dynamic_StatusChange2_ (DBusGProxy* _sender, MprisControllerstatus* st, gpointer self);
void _dynamic_StatusChange3_connect (gpointer obj, const char * signal_name, GCallback handler, gpointer data);
static void _dynamic_GetStatus0 (DBusGProxy* self, MprisControllerstatus* result, GError** error);
GType player_item_get_type (void);
#define PLAYER_CONTROLLER_TRANSPORT 3
GType transport_menuitem_get_type (void);
void transport_menuitem_change_play_state (TransportMenuitem* self, gint state);
static GHashTable* _dynamic_GetMetadata1 (DBusGProxy* self, GError** error);
#define PLAYER_CONTROLLER_METADATA 2
void player_item_update (PlayerItem* self, GHashTable* data, GeeHashSet* attributes);
GeeHashSet* metadata_menuitem_attributes_format (void);
MprisController* mpris_controller_new (const char* name, PlayerController* controller, const char* mpris_interface);
MprisController* mpris_controller_construct (GType object_type, const char* name, PlayerController* controller, const char* mpris_interface);
static void _dynamic_Play2 (DBusGProxy* self, GError** error);
static void _dynamic_Pause3 (DBusGProxy* self, GError** error);
void mpris_controller_toggle_playback (MprisController* self, gboolean state);
static GValue* _g_value_dup (GValue* self);
GeeHashSet* transport_menuitem_attributes_format (void);
static void mpris_controller_finalize (GObject* obj);


static void g_cclosure_user_marshal_VOID__BOXED (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);

static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _mpris_controller_onTrackChange_dynamic_TrackChange0_ (DBusGProxy* _sender, GHashTable* ht, gpointer self) {
	mpris_controller_onTrackChange (self, _sender, ht);
}


void _dynamic_TrackChange1_connect (gpointer obj, const char * signal_name, GCallback handler, gpointer data) {
	dbus_g_object_register_marshaller (g_cclosure_user_marshal_VOID__BOXED, G_TYPE_NONE, dbus_g_type_get_map ("GHashTable", G_TYPE_STRING, G_TYPE_VALUE), G_TYPE_INVALID);
	dbus_g_proxy_add_signal (obj, "TrackChange", dbus_g_type_get_map ("GHashTable", G_TYPE_STRING, G_TYPE_VALUE), G_TYPE_INVALID);
	dbus_g_proxy_connect_signal (obj, signal_name, handler, data, NULL);
}


static void _mpris_controller_onStatusChange_dynamic_StatusChange2_ (DBusGProxy* _sender, MprisControllerstatus* st, gpointer self) {
	mpris_controller_onStatusChange (self, _sender, st);
}


void _dynamic_StatusChange3_connect (gpointer obj, const char * signal_name, GCallback handler, gpointer data) {
	dbus_g_object_register_marshaller (g_cclosure_user_marshal_VOID__BOXED, G_TYPE_NONE, dbus_g_type_get_struct ("GValueArray", G_TYPE_INT, G_TYPE_INT, G_TYPE_INT, G_TYPE_INT, G_TYPE_INVALID), G_TYPE_INVALID);
	dbus_g_proxy_add_signal (obj, "StatusChange", dbus_g_type_get_struct ("GValueArray", G_TYPE_INT, G_TYPE_INT, G_TYPE_INT, G_TYPE_INT, G_TYPE_INVALID), G_TYPE_INVALID);
	dbus_g_proxy_connect_signal (obj, signal_name, handler, data, NULL);
}


static void _dynamic_GetStatus0 (DBusGProxy* self, MprisControllerstatus* result, GError** error) {
	GValueArray* dbus_result;
	dbus_g_proxy_call (self, "GetStatus", error, G_TYPE_INVALID, dbus_g_type_get_struct ("GValueArray", G_TYPE_INT, G_TYPE_INT, G_TYPE_INT, G_TYPE_INT, G_TYPE_INVALID), &dbus_result, G_TYPE_INVALID);
	if (*error) {
		return;
	}
	result->playback = g_value_get_int (&dbus_result->values[0]);
	result->shuffle = g_value_get_int (&dbus_result->values[1]);
	result->repeat = g_value_get_int (&dbus_result->values[2]);
	result->endless = g_value_get_int (&dbus_result->values[3]);
}


static GHashTable* _dynamic_GetMetadata1 (DBusGProxy* self, GError** error) {
	GHashTable* result;
	dbus_g_proxy_call (self, "GetMetadata", error, G_TYPE_INVALID, dbus_g_type_get_map ("GHashTable", G_TYPE_STRING, G_TYPE_VALUE), &result, G_TYPE_INVALID);
	if (*error) {
		return NULL;
	}
	return result;
}


MprisController* mpris_controller_construct (GType object_type, const char* name, PlayerController* controller, const char* mpris_interface) {
	GError * _inner_error_;
	MprisController * self;
	PlayerController* _tmp2_;
	DBusGProxy* _tmp5_;
	char* _tmp4_;
	char* _tmp3_;
	MprisControllerstatus _tmp6_ = {0};
	MprisControllerstatus st;
	gint play_state;
	TransportMenuitem* _tmp8_;
	PlayerItem* _tmp7_;
	GHashTable* _tmp9_;
	GeeHashSet* _tmp12_;
	GHashTable* _tmp11_;
	PlayerItem* _tmp10_;
	g_return_val_if_fail (name != NULL, NULL);
	g_return_val_if_fail (controller != NULL, NULL);
	g_return_val_if_fail (mpris_interface != NULL, NULL);
	_inner_error_ = NULL;
	self = (MprisController*) g_object_new (object_type, NULL);
	{
		DBusGConnection* _tmp0_;
		DBusGConnection* _tmp1_;
		_tmp0_ = dbus_g_bus_get (DBUS_BUS_SESSION, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch1_g_error;
		}
		self->priv->connection = (_tmp1_ = _tmp0_, _dbus_g_connection_unref0 (self->priv->connection), _tmp1_);
	}
	goto __finally1;
	__catch1_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			g_error ("mpris-controller.vala:39: Problems connecting to the session bus - %s", e->message);
			_g_error_free0 (e);
		}
	}
	__finally1:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	self->priv->controller = (_tmp2_ = _g_object_ref0 (controller), _g_object_unref0 (self->priv->controller), _tmp2_);
	self->mpris_player = (_tmp5_ = dbus_g_proxy_new_for_name (self->priv->connection, _tmp4_ = g_strconcat ("org.mpris.", _tmp3_ = g_utf8_strdown (name, -1), NULL), "/Player", mpris_interface), _g_object_unref0 (self->mpris_player), _tmp5_);
	_g_free0 (_tmp4_);
	_g_free0 (_tmp3_);
	_dynamic_TrackChange1_connect (self->mpris_player, "TrackChange", (GCallback) _mpris_controller_onTrackChange_dynamic_TrackChange0_, self);
	_dynamic_StatusChange3_connect (self->mpris_player, "StatusChange", (GCallback) _mpris_controller_onStatusChange_dynamic_StatusChange2_, self);
	st = (_dynamic_GetStatus0 (self->mpris_player, &_tmp6_, &_inner_error_), _tmp6_);
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	play_state = (gint) st.playback;
	g_debug ("mpris-controller.vala:48: GetStatusChange - play state %i", play_state);
	transport_menuitem_change_play_state (_tmp8_ = (_tmp7_ = (PlayerItem*) gee_abstract_list_get ((GeeAbstractList*) self->priv->controller->custom_items, PLAYER_CONTROLLER_TRANSPORT), IS_TRANSPORT_MENUITEM (_tmp7_) ? ((TransportMenuitem*) _tmp7_) : NULL), play_state);
	_g_object_unref0 (_tmp8_);
	_tmp9_ = _dynamic_GetMetadata1 (self->mpris_player, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	player_item_update (_tmp10_ = (PlayerItem*) gee_abstract_list_get ((GeeAbstractList*) self->priv->controller->custom_items, PLAYER_CONTROLLER_METADATA), _tmp11_ = _tmp9_, _tmp12_ = metadata_menuitem_attributes_format ());
	_g_object_unref0 (_tmp12_);
	_g_hash_table_unref0 (_tmp11_);
	_g_object_unref0 (_tmp10_);
	return self;
}


MprisController* mpris_controller_new (const char* name, PlayerController* controller, const char* mpris_interface) {
	return mpris_controller_construct (TYPE_MPRIS_CONTROLLER, name, controller, mpris_interface);
}


static void mpris_controller_onTrackChange (MprisController* self, DBusGProxy* mpris_client, GHashTable* ht) {
	GeeHashSet* _tmp1_;
	PlayerItem* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (mpris_client != NULL);
	g_return_if_fail (ht != NULL);
	g_debug ("mpris-controller.vala:58: onTrackChange");
	player_item_update (_tmp0_ = (PlayerItem*) gee_abstract_list_get ((GeeAbstractList*) self->priv->controller->custom_items, PLAYER_CONTROLLER_METADATA), ht, _tmp1_ = metadata_menuitem_attributes_format ());
	_g_object_unref0 (_tmp1_);
	_g_object_unref0 (_tmp0_);
}


static void _dynamic_Play2 (DBusGProxy* self, GError** error) {
	dbus_g_proxy_call (self, "Play", error, G_TYPE_INVALID, G_TYPE_INVALID);
	if (*error) {
		return;
	}
}


static void _dynamic_Pause3 (DBusGProxy* self, GError** error) {
	dbus_g_proxy_call (self, "Pause", error, G_TYPE_INVALID, G_TYPE_INVALID);
	if (*error) {
		return;
	}
}


void mpris_controller_toggle_playback (MprisController* self, gboolean state) {
	GError * _inner_error_;
	g_return_if_fail (self != NULL);
	_inner_error_ = NULL;
	if (state == TRUE) {
		g_debug ("mpris-controller.vala:70: about to play");
		_dynamic_Play2 (self->mpris_player, &_inner_error_);
		if (_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	} else {
		g_debug ("mpris-controller.vala:74: about to pause");
		_dynamic_Pause3 (self->mpris_player, &_inner_error_);
		if (_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
}


static GValue* _g_value_dup (GValue* self) {
	return g_boxed_copy (G_TYPE_VALUE, self);
}


static gpointer __g_value_dup0 (gpointer self) {
	return self ? _g_value_dup (self) : NULL;
}


static void mpris_controller_onStatusChange (MprisController* self, DBusGProxy* mpris_client, MprisControllerstatus* st) {
	MprisControllerstatus* status;
	GValueArray* ar;
	gint play_state;
	GHashTable* ht;
	GValue v = {0};
	GeeHashSet* _tmp1_;
	PlayerItem* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (mpris_client != NULL);
	g_debug ("mpris-controller.vala:81: onStatusChange - signal received");
	status = st;
	ar = (GValueArray*) status;
	play_state = g_value_get_int (g_value_array_get_nth (ar, (guint) 0));
	g_debug ("mpris-controller.vala:85: onStatusChange - play state %i", play_state);
	ht = g_hash_table_new (g_str_hash, g_str_equal);
	g_value_init (&v, G_TYPE_INT);
	g_value_set_int (&v, play_state);
	g_hash_table_insert (ht, g_strdup ("state"), __g_value_dup0 (&v));
	player_item_update (_tmp0_ = (PlayerItem*) gee_abstract_list_get ((GeeAbstractList*) self->priv->controller->custom_items, PLAYER_CONTROLLER_TRANSPORT), ht, _tmp1_ = transport_menuitem_attributes_format ());
	_g_object_unref0 (_tmp1_);
	_g_object_unref0 (_tmp0_);
	_g_hash_table_unref0 (ht);
	G_IS_VALUE (&v) ? (g_value_unset (&v), NULL) : NULL;
}


static MprisControllerstatus* mpris_controller_status_dup (const MprisControllerstatus* self) {
	MprisControllerstatus* dup;
	dup = g_new0 (MprisControllerstatus, 1);
	memcpy (dup, self, sizeof (MprisControllerstatus));
	return dup;
}


static void mpris_controller_status_free (MprisControllerstatus* self) {
	g_free (self);
}


static GType mpris_controller_status_get_type (void) {
	static volatile gsize mpris_controller_status_type_id__volatile = 0;
	if (g_once_init_enter (&mpris_controller_status_type_id__volatile)) {
		GType mpris_controller_status_type_id;
		mpris_controller_status_type_id = g_boxed_type_register_static ("MprisControllerstatus", (GBoxedCopyFunc) mpris_controller_status_dup, (GBoxedFreeFunc) mpris_controller_status_free);
		g_once_init_leave (&mpris_controller_status_type_id__volatile, mpris_controller_status_type_id);
	}
	return mpris_controller_status_type_id__volatile;
}


static void mpris_controller_class_init (MprisControllerClass * klass) {
	mpris_controller_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (MprisControllerPrivate));
	G_OBJECT_CLASS (klass)->finalize = mpris_controller_finalize;
}


static void mpris_controller_instance_init (MprisController * self) {
	self->priv = MPRIS_CONTROLLER_GET_PRIVATE (self);
}


static void mpris_controller_finalize (GObject* obj) {
	MprisController * self;
	self = MPRIS_CONTROLLER (obj);
	_dbus_g_connection_unref0 (self->priv->connection);
	_g_object_unref0 (self->mpris_player);
	_g_object_unref0 (self->priv->controller);
	G_OBJECT_CLASS (mpris_controller_parent_class)->finalize (obj);
}


GType mpris_controller_get_type (void) {
	static volatile gsize mpris_controller_type_id__volatile = 0;
	if (g_once_init_enter (&mpris_controller_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (MprisControllerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) mpris_controller_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MprisController), 0, (GInstanceInitFunc) mpris_controller_instance_init, NULL };
		GType mpris_controller_type_id;
		mpris_controller_type_id = g_type_register_static (G_TYPE_OBJECT, "MprisController", &g_define_type_info, 0);
		g_once_init_leave (&mpris_controller_type_id__volatile, mpris_controller_type_id);
	}
	return mpris_controller_type_id__volatile;
}



static void g_cclosure_user_marshal_VOID__BOXED (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__BOXED) (gpointer data1, gpointer arg_1, gpointer data2);
	register GMarshalFunc_VOID__BOXED callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 2);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__BOXED) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_boxed (param_values + 1), data2);
}



