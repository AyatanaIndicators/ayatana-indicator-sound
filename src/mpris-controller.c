/* mpris-controller.c generated by valac, the Vala compiler
 * generated from mpris-controller.vala, do not modify */

/*
This service primarily controls PulseAudio and is driven by the sound indicator menu on the panel.
Copyright 2010 Canonical Ltd.

Authors:
    Conor Curran <conor.curran@canonical.com>

This program is free software: you can redistribute it and/or modify it 
under the terms of the GNU General Public License version 3, as published 
by the Free Software Foundation.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranties of 
MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along 
with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <glib.h>
#include <glib-object.h>
#include <dbus/dbus-glib-lowlevel.h>
#include <dbus/dbus-glib.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>


#define TYPE_MPRIS_CONTROLLER (mpris_controller_get_type ())
#define MPRIS_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS_CONTROLLER, MprisController))
#define MPRIS_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MPRIS_CONTROLLER, MprisControllerClass))
#define IS_MPRIS_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS_CONTROLLER))
#define IS_MPRIS_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MPRIS_CONTROLLER))
#define MPRIS_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MPRIS_CONTROLLER, MprisControllerClass))

typedef struct _MprisController MprisController;
typedef struct _MprisControllerClass MprisControllerClass;
typedef struct _MprisControllerPrivate MprisControllerPrivate;

#define TYPE_PLAYER_CONTROLLER (player_controller_get_type ())
#define PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_CONTROLLER, PlayerController))
#define PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))
#define IS_PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_CONTROLLER))
#define IS_PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_CONTROLLER))
#define PLAYER_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))

typedef struct _PlayerController PlayerController;
typedef struct _PlayerControllerClass PlayerControllerClass;
#define _dbus_g_connection_unref0(var) ((var == NULL) ? NULL : (var = (dbus_g_connection_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define MPRIS_CONTROLLER_TYPE_STATUS (mpris_controller_status_get_type ())
typedef struct _MprisControllerstatus MprisControllerstatus;
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))

struct _MprisController {
	GObject parent_instance;
	MprisControllerPrivate * priv;
	DBusGProxy* mpris_player;
};

struct _MprisControllerClass {
	GObjectClass parent_class;
};

struct _MprisControllerPrivate {
	DBusGConnection* connection;
	PlayerController* controller;
};

struct _MprisControllerstatus {
	gint32 playback;
	gint32 shuffle;
	gint32 repeat;
	gint32 endless;
};


static gpointer mpris_controller_parent_class = NULL;

GType mpris_controller_get_type (void);
GType player_controller_get_type (void);
#define MPRIS_CONTROLLER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_MPRIS_CONTROLLER, MprisControllerPrivate))
enum  {
	MPRIS_CONTROLLER_DUMMY_PROPERTY
};
static void mpris_controller_onTrackChange (MprisController* self, DBusGProxy* mpris_client, GHashTable* ht);
static void _mpris_controller_onTrackChange_dynamic_TrackChange0_ (DBusGProxy* _sender, GHashTable* ht, gpointer self);
void _dynamic_TrackChange1_connect (gpointer obj, const char * signal_name, GCallback handler, gpointer data);
static GType mpris_controller_status_get_type (void) G_GNUC_UNUSED;
static MprisControllerstatus* mpris_controller_status_dup (const MprisControllerstatus* self);
static void mpris_controller_status_free (MprisControllerstatus* self);
static void mpris_controller_onStatusChange (MprisController* self, DBusGProxy* mpris_client, MprisControllerstatus* st);
static void _mpris_controller_onStatusChange_dynamic_StatusChange2_ (DBusGProxy* _sender, MprisControllerstatus* st, gpointer self);
void _dynamic_StatusChange3_connect (gpointer obj, const char * signal_name, GCallback handler, gpointer data);
void player_controller_update_playing_info (PlayerController* self, GeeHashMap* data);
GeeHashMap* mpris_controller_get_track_data (MprisController* self);
MprisController* mpris_controller_new (const char* name, PlayerController* controller, const char* mpris_interface);
MprisController* mpris_controller_construct (GType object_type, const char* name, PlayerController* controller, const char* mpris_interface);
static GHashTable* _dynamic_GetMetadata0 (DBusGProxy* self, GError** error);
static GeeHashMap* mpris_controller_format_metadata (GHashTable* data);
static void _dynamic_Play1 (DBusGProxy* self, GError** error);
static void _dynamic_Pause2 (DBusGProxy* self, GError** error);
void mpris_controller_toggle_playback (MprisController* self, gboolean state);
static void mpris_controller_finalize (GObject* obj);


static void g_cclosure_user_marshal_VOID__BOXED (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);

static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _mpris_controller_onTrackChange_dynamic_TrackChange0_ (DBusGProxy* _sender, GHashTable* ht, gpointer self) {
	mpris_controller_onTrackChange (self, _sender, ht);
}


void _dynamic_TrackChange1_connect (gpointer obj, const char * signal_name, GCallback handler, gpointer data) {
	dbus_g_object_register_marshaller (g_cclosure_user_marshal_VOID__BOXED, G_TYPE_NONE, dbus_g_type_get_map ("GHashTable", G_TYPE_STRING, G_TYPE_VALUE), G_TYPE_INVALID);
	dbus_g_proxy_add_signal (obj, "TrackChange", dbus_g_type_get_map ("GHashTable", G_TYPE_STRING, G_TYPE_VALUE), G_TYPE_INVALID);
	dbus_g_proxy_connect_signal (obj, signal_name, handler, data, NULL);
}


static void _mpris_controller_onStatusChange_dynamic_StatusChange2_ (DBusGProxy* _sender, MprisControllerstatus* st, gpointer self) {
	mpris_controller_onStatusChange (self, _sender, st);
}


void _dynamic_StatusChange3_connect (gpointer obj, const char * signal_name, GCallback handler, gpointer data) {
	dbus_g_object_register_marshaller (g_cclosure_user_marshal_VOID__BOXED, G_TYPE_NONE, dbus_g_type_get_struct ("GValueArray", G_TYPE_INT, G_TYPE_INT, G_TYPE_INT, G_TYPE_INT, G_TYPE_INVALID), G_TYPE_INVALID);
	dbus_g_proxy_add_signal (obj, "StatusChange", dbus_g_type_get_struct ("GValueArray", G_TYPE_INT, G_TYPE_INT, G_TYPE_INT, G_TYPE_INT, G_TYPE_INVALID), G_TYPE_INVALID);
	dbus_g_proxy_connect_signal (obj, signal_name, handler, data, NULL);
}


MprisController* mpris_controller_construct (GType object_type, const char* name, PlayerController* controller, const char* mpris_interface) {
	GError * _inner_error_;
	MprisController * self;
	PlayerController* _tmp2_;
	DBusGProxy* _tmp5_;
	char* _tmp4_;
	char* _tmp3_;
	GeeHashMap* _tmp6_;
	g_return_val_if_fail (name != NULL, NULL);
	g_return_val_if_fail (controller != NULL, NULL);
	g_return_val_if_fail (mpris_interface != NULL, NULL);
	_inner_error_ = NULL;
	self = (MprisController*) g_object_new (object_type, NULL);
	{
		DBusGConnection* _tmp0_;
		DBusGConnection* _tmp1_;
		_tmp0_ = dbus_g_bus_get (DBUS_BUS_SESSION, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch0_g_error;
		}
		self->priv->connection = (_tmp1_ = _tmp0_, _dbus_g_connection_unref0 (self->priv->connection), _tmp1_);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			g_error ("mpris-controller.vala:41: Problems connecting to the session bus - %s", e->message);
			_g_error_free0 (e);
		}
	}
	__finally0:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	self->priv->controller = (_tmp2_ = _g_object_ref0 (controller), _g_object_unref0 (self->priv->controller), _tmp2_);
	self->mpris_player = (_tmp5_ = dbus_g_proxy_new_for_name (self->priv->connection, _tmp4_ = g_strconcat ("org.mpris.", _tmp3_ = g_utf8_strdown (name, -1), NULL), "/Player", mpris_interface), _g_object_unref0 (self->mpris_player), _tmp5_);
	_g_free0 (_tmp4_);
	_g_free0 (_tmp3_);
	_dynamic_TrackChange1_connect (self->mpris_player, "TrackChange", (GCallback) _mpris_controller_onTrackChange_dynamic_TrackChange0_, self);
	_dynamic_StatusChange3_connect (self->mpris_player, "StatusChange", (GCallback) _mpris_controller_onStatusChange_dynamic_StatusChange2_, self);
	player_controller_update_playing_info (self->priv->controller, _tmp6_ = mpris_controller_get_track_data (self));
	_g_object_unref0 (_tmp6_);
	return self;
}


MprisController* mpris_controller_new (const char* name, PlayerController* controller, const char* mpris_interface) {
	return mpris_controller_construct (TYPE_MPRIS_CONTROLLER, name, controller, mpris_interface);
}


static GHashTable* _dynamic_GetMetadata0 (DBusGProxy* self, GError** error) {
	GHashTable* result;
	dbus_g_proxy_call (self, "GetMetadata", error, G_TYPE_INVALID, dbus_g_type_get_map ("GHashTable", G_TYPE_STRING, G_TYPE_VALUE), &result, G_TYPE_INVALID);
	if (*error) {
		return NULL;
	}
	return result;
}


GeeHashMap* mpris_controller_get_track_data (MprisController* self) {
	GeeHashMap* result = NULL;
	GError * _inner_error_;
	GHashTable* _tmp0_;
	GHashTable* _tmp1_;
	GeeHashMap* _tmp2_;
	g_return_val_if_fail (self != NULL, NULL);
	_inner_error_ = NULL;
	_tmp0_ = _dynamic_GetMetadata0 (self->mpris_player, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = (_tmp2_ = mpris_controller_format_metadata (_tmp1_ = _tmp0_), _g_hash_table_unref0 (_tmp1_), _tmp2_);
	return result;
}


static void mpris_controller_onTrackChange (MprisController* self, DBusGProxy* mpris_client, GHashTable* ht) {
	GeeHashMap* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (mpris_client != NULL);
	g_return_if_fail (ht != NULL);
	player_controller_update_playing_info (self->priv->controller, _tmp0_ = mpris_controller_format_metadata (ht));
	_g_object_unref0 (_tmp0_);
}


static void _dynamic_Play1 (DBusGProxy* self, GError** error) {
	dbus_g_proxy_call (self, "Play", error, G_TYPE_INVALID, G_TYPE_INVALID);
	if (*error) {
		return;
	}
}


static void _dynamic_Pause2 (DBusGProxy* self, GError** error) {
	dbus_g_proxy_call (self, "Pause", error, G_TYPE_INVALID, G_TYPE_INVALID);
	if (*error) {
		return;
	}
}


void mpris_controller_toggle_playback (MprisController* self, gboolean state) {
	GError * _inner_error_;
	g_return_if_fail (self != NULL);
	_inner_error_ = NULL;
	if (state == TRUE) {
		g_debug ("mpris-controller.vala:67: about to play");
		_dynamic_Play1 (self->mpris_player, &_inner_error_);
		if (_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	} else {
		g_debug ("mpris-controller.vala:71: about to pause");
		_dynamic_Pause2 (self->mpris_player, &_inner_error_);
		if (_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
}


static void mpris_controller_onStatusChange (MprisController* self, DBusGProxy* mpris_client, MprisControllerstatus* st) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (mpris_client != NULL);
	g_debug ("mpris-controller.vala:78: onStatusChange - signal received");
}


static GeeHashMap* mpris_controller_format_metadata (GHashTable* data) {
	GeeHashMap* result = NULL;
	GeeHashMap* results;
	g_return_val_if_fail (data != NULL, NULL);
	results = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL);
	g_debug ("mpris-controller.vala:93: format_metadata - title = %s", g_value_get_string ((GValue*) g_hash_table_lookup (data, "title")));
	gee_abstract_map_set ((GeeAbstractMap*) results, "title", g_value_get_string ((GValue*) g_hash_table_lookup (data, "title")));
	gee_abstract_map_set ((GeeAbstractMap*) results, "artist", g_value_get_string ((GValue*) g_hash_table_lookup (data, "artist")));
	gee_abstract_map_set ((GeeAbstractMap*) results, "album", g_value_get_string ((GValue*) g_hash_table_lookup (data, "album")));
	gee_abstract_map_set ((GeeAbstractMap*) results, "arturl", g_value_get_string ((GValue*) g_hash_table_lookup (data, "arturl")));
	result = results;
	return result;
}


static MprisControllerstatus* mpris_controller_status_dup (const MprisControllerstatus* self) {
	MprisControllerstatus* dup;
	dup = g_new0 (MprisControllerstatus, 1);
	memcpy (dup, self, sizeof (MprisControllerstatus));
	return dup;
}


static void mpris_controller_status_free (MprisControllerstatus* self) {
	g_free (self);
}


static GType mpris_controller_status_get_type (void) {
	static volatile gsize mpris_controller_status_type_id__volatile = 0;
	if (g_once_init_enter (&mpris_controller_status_type_id__volatile)) {
		GType mpris_controller_status_type_id;
		mpris_controller_status_type_id = g_boxed_type_register_static ("MprisControllerstatus", (GBoxedCopyFunc) mpris_controller_status_dup, (GBoxedFreeFunc) mpris_controller_status_free);
		g_once_init_leave (&mpris_controller_status_type_id__volatile, mpris_controller_status_type_id);
	}
	return mpris_controller_status_type_id__volatile;
}


static void mpris_controller_class_init (MprisControllerClass * klass) {
	mpris_controller_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (MprisControllerPrivate));
	G_OBJECT_CLASS (klass)->finalize = mpris_controller_finalize;
}


static void mpris_controller_instance_init (MprisController * self) {
	self->priv = MPRIS_CONTROLLER_GET_PRIVATE (self);
}


static void mpris_controller_finalize (GObject* obj) {
	MprisController * self;
	self = MPRIS_CONTROLLER (obj);
	_dbus_g_connection_unref0 (self->priv->connection);
	_g_object_unref0 (self->mpris_player);
	_g_object_unref0 (self->priv->controller);
	G_OBJECT_CLASS (mpris_controller_parent_class)->finalize (obj);
}


GType mpris_controller_get_type (void) {
	static volatile gsize mpris_controller_type_id__volatile = 0;
	if (g_once_init_enter (&mpris_controller_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (MprisControllerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) mpris_controller_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MprisController), 0, (GInstanceInitFunc) mpris_controller_instance_init, NULL };
		GType mpris_controller_type_id;
		mpris_controller_type_id = g_type_register_static (G_TYPE_OBJECT, "MprisController", &g_define_type_info, 0);
		g_once_init_leave (&mpris_controller_type_id__volatile, mpris_controller_type_id);
	}
	return mpris_controller_type_id__volatile;
}



static void g_cclosure_user_marshal_VOID__BOXED (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__BOXED) (gpointer data1, gpointer arg_1, gpointer data2);
	register GMarshalFunc_VOID__BOXED callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 2);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__BOXED) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_boxed (param_values + 1), data2);
}



