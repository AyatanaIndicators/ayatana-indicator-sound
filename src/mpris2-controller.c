/* mpris2-controller.c generated by valac 0.11.2, the Vala compiler
 * generated from mpris2-controller.vala, do not modify */

/*
Copyright 2010 Canonical Ltd.

Authors:
    Conor Curran <conor.curran@canonical.com>

This program is free software: you can redistribute it and/or modify it 
under the terms of the GNU General Public License version 3, as published 
by the Free Software Foundation.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranties of 
MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along 
with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <gee.h>
#include <libdbusmenu-glib/client.h>
#include <libdbusmenu-glib/menuitem-proxy.h>
#include <libdbusmenu-glib/menuitem.h>
#include <libdbusmenu-glib/server.h>


#define TYPE_FREE_DESKTOP_PROPERTIES (free_desktop_properties_get_type ())
#define FREE_DESKTOP_PROPERTIES(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FREE_DESKTOP_PROPERTIES, FreeDesktopProperties))
#define IS_FREE_DESKTOP_PROPERTIES(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FREE_DESKTOP_PROPERTIES))
#define FREE_DESKTOP_PROPERTIES_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_FREE_DESKTOP_PROPERTIES, FreeDesktopPropertiesIface))

typedef struct _FreeDesktopProperties FreeDesktopProperties;
typedef struct _FreeDesktopPropertiesIface FreeDesktopPropertiesIface;

#define TYPE_FREE_DESKTOP_PROPERTIES_PROXY (free_desktop_properties_proxy_get_type ())
typedef GDBusProxy FreeDesktopPropertiesProxy;
typedef GDBusProxyClass FreeDesktopPropertiesProxyClass;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))

#define TYPE_MPRIS2_CONTROLLER (mpris2_controller_get_type ())
#define MPRIS2_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS2_CONTROLLER, Mpris2Controller))
#define MPRIS2_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MPRIS2_CONTROLLER, Mpris2ControllerClass))
#define IS_MPRIS2_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS2_CONTROLLER))
#define IS_MPRIS2_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MPRIS2_CONTROLLER))
#define MPRIS2_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MPRIS2_CONTROLLER, Mpris2ControllerClass))

typedef struct _Mpris2Controller Mpris2Controller;
typedef struct _Mpris2ControllerClass Mpris2ControllerClass;
typedef struct _Mpris2ControllerPrivate Mpris2ControllerPrivate;

#define TYPE_MPRIS_ROOT (mpris_root_get_type ())
#define MPRIS_ROOT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS_ROOT, MprisRoot))
#define IS_MPRIS_ROOT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS_ROOT))
#define MPRIS_ROOT_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_MPRIS_ROOT, MprisRootIface))

typedef struct _MprisRoot MprisRoot;
typedef struct _MprisRootIface MprisRootIface;

#define TYPE_MPRIS_ROOT_PROXY (mpris_root_proxy_get_type ())

#define TYPE_MPRIS_PLAYER (mpris_player_get_type ())
#define MPRIS_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS_PLAYER, MprisPlayer))
#define IS_MPRIS_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS_PLAYER))
#define MPRIS_PLAYER_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_MPRIS_PLAYER, MprisPlayerIface))

typedef struct _MprisPlayer MprisPlayer;
typedef struct _MprisPlayerIface MprisPlayerIface;

#define TYPE_MPRIS_PLAYER_PROXY (mpris_player_proxy_get_type ())

#define TYPE_MPRIS_PLAYLISTS (mpris_playlists_get_type ())
#define MPRIS_PLAYLISTS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS_PLAYLISTS, MprisPlaylists))
#define IS_MPRIS_PLAYLISTS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS_PLAYLISTS))
#define MPRIS_PLAYLISTS_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_MPRIS_PLAYLISTS, MprisPlaylistsIface))

typedef struct _MprisPlaylists MprisPlaylists;
typedef struct _MprisPlaylistsIface MprisPlaylistsIface;

#define TYPE_MPRIS_PLAYLISTS_PROXY (mpris_playlists_proxy_get_type ())

#define TYPE_PLAYLIST_DETAILS (playlist_details_get_type ())
typedef struct _PlaylistDetails PlaylistDetails;

#define TYPE_ACTIVE_PLAYLIST_CONTAINER (active_playlist_container_get_type ())
typedef struct _ActivePlaylistContainer ActivePlaylistContainer;

#define TYPE_PLAYER_CONTROLLER (player_controller_get_type ())
#define PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_CONTROLLER, PlayerController))
#define PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))
#define IS_PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_CONTROLLER))
#define IS_PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_CONTROLLER))
#define PLAYER_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))

typedef struct _PlayerController PlayerController;
typedef struct _PlayerControllerClass PlayerControllerClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TRANSPORT_MENUITEM_TYPE_STATE (transport_menuitem_state_get_type ())
typedef struct _PlayerControllerPrivate PlayerControllerPrivate;

#define TYPE_PLAYER_ITEM (player_item_get_type ())
#define PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_ITEM, PlayerItem))
#define PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_ITEM, PlayerItemClass))
#define IS_PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_ITEM))
#define IS_PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_ITEM))
#define PLAYER_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_ITEM, PlayerItemClass))

typedef struct _PlayerItem PlayerItem;
typedef struct _PlayerItemClass PlayerItemClass;

#define PLAYER_CONTROLLER_TYPE_WIDGET_ORDER (player_controller_widget_order_get_type ())

#define TYPE_TRANSPORT_MENUITEM (transport_menuitem_get_type ())
#define TRANSPORT_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TRANSPORT_MENUITEM, TransportMenuitem))
#define TRANSPORT_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TRANSPORT_MENUITEM, TransportMenuitemClass))
#define IS_TRANSPORT_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TRANSPORT_MENUITEM))
#define IS_TRANSPORT_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TRANSPORT_MENUITEM))
#define TRANSPORT_MENUITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TRANSPORT_MENUITEM, TransportMenuitemClass))

typedef struct _TransportMenuitem TransportMenuitem;
typedef struct _TransportMenuitemClass TransportMenuitemClass;
#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))

#define TRANSPORT_MENUITEM_TYPE_ACTION (transport_menuitem_action_get_type ())

#define TYPE_PLAYLISTS_MENUITEM (playlists_menuitem_get_type ())
#define PLAYLISTS_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYLISTS_MENUITEM, PlaylistsMenuitem))
#define PLAYLISTS_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYLISTS_MENUITEM, PlaylistsMenuitemClass))
#define IS_PLAYLISTS_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYLISTS_MENUITEM))
#define IS_PLAYLISTS_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYLISTS_MENUITEM))
#define PLAYLISTS_MENUITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYLISTS_MENUITEM, PlaylistsMenuitemClass))

typedef struct _PlaylistsMenuitem PlaylistsMenuitem;
typedef struct _PlaylistsMenuitemClass PlaylistsMenuitemClass;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _FreeDesktopPropertiesIface {
	GTypeInterface parent_iface;
};

struct _Mpris2Controller {
	GObject parent_instance;
	Mpris2ControllerPrivate * priv;
};

struct _Mpris2ControllerClass {
	GObjectClass parent_class;
};

struct _MprisRootIface {
	GTypeInterface parent_iface;
	void (*Quit) (MprisRoot* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*Quit_finish) (MprisRoot* self, GAsyncResult* _res_, GError** error);
	void (*Raise) (MprisRoot* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*Raise_finish) (MprisRoot* self, GAsyncResult* _res_, GError** error);
	gboolean (*get_HasTracklist) (MprisRoot* self);
	void (*set_HasTracklist) (MprisRoot* self, gboolean value);
	gboolean (*get_CanQuit) (MprisRoot* self);
	void (*set_CanQuit) (MprisRoot* self, gboolean value);
	gboolean (*get_CanRaise) (MprisRoot* self);
	void (*set_CanRaise) (MprisRoot* self, gboolean value);
	gchar* (*get_Identity) (MprisRoot* self);
	void (*set_Identity) (MprisRoot* self, const gchar* value);
	gchar* (*get_DesktopEntry) (MprisRoot* self);
	void (*set_DesktopEntry) (MprisRoot* self, const gchar* value);
};

struct _MprisPlayerIface {
	GTypeInterface parent_iface;
	void (*PlayPause) (MprisPlayer* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*PlayPause_finish) (MprisPlayer* self, GAsyncResult* _res_, GError** error);
	void (*Next) (MprisPlayer* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*Next_finish) (MprisPlayer* self, GAsyncResult* _res_, GError** error);
	void (*Previous) (MprisPlayer* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*Previous_finish) (MprisPlayer* self, GAsyncResult* _res_, GError** error);
	GHashTable* (*get_Metadata) (MprisPlayer* self);
	void (*set_Metadata) (MprisPlayer* self, GHashTable* value);
	gint32 (*get_Position) (MprisPlayer* self);
	void (*set_Position) (MprisPlayer* self, gint32 value);
	gchar* (*get_PlaybackStatus) (MprisPlayer* self);
	void (*set_PlaybackStatus) (MprisPlayer* self, const gchar* value);
};

struct _PlaylistDetails {
	char* path;
	gchar* name;
	gchar* icon_path;
};

struct _ActivePlaylistContainer {
	gboolean valid;
	PlaylistDetails details;
};

struct _MprisPlaylistsIface {
	GTypeInterface parent_iface;
	void (*ActivatePlaylist) (MprisPlaylists* self, const char* playlist_id, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*ActivatePlaylist_finish) (MprisPlaylists* self, GAsyncResult* _res_, GError** error);
	PlaylistDetails* (*GetPlaylists) (MprisPlaylists* self, guint32 index, guint32 max_count, const gchar* order, gboolean reverse_order, int* result_length1, GError** error);
	gchar** (*get_Orderings) (MprisPlaylists* self, int* result_length1);
	void (*set_Orderings) (MprisPlaylists* self, gchar** value, int value_length1);
	guint32 (*get_PlaylistCount) (MprisPlaylists* self);
	void (*set_PlaylistCount) (MprisPlaylists* self, guint32 value);
	void (*get_ActivePlaylist) (MprisPlaylists* self, ActivePlaylistContainer* value);
	void (*set_ActivePlaylist) (MprisPlaylists* self, ActivePlaylistContainer* value);
};

struct _Mpris2ControllerPrivate {
	MprisRoot* _mpris2_root;
	MprisPlayer* _player;
	MprisPlaylists* _playlists;
	FreeDesktopProperties* _properties_interface;
	PlayerController* _owner;
};

typedef enum  {
	TRANSPORT_MENUITEM_STATE_PLAYING,
	TRANSPORT_MENUITEM_STATE_PAUSED
} TransportMenuitemstate;

struct _PlayerController {
	GObject parent_instance;
	PlayerControllerPrivate * priv;
	gint current_state;
	GeeArrayList* custom_items;
	Mpris2Controller* mpris_bridge;
};

struct _PlayerControllerClass {
	GObjectClass parent_class;
};

typedef enum  {
	PLAYER_CONTROLLER_WIDGET_ORDER_SEPARATOR,
	PLAYER_CONTROLLER_WIDGET_ORDER_TITLE,
	PLAYER_CONTROLLER_WIDGET_ORDER_METADATA,
	PLAYER_CONTROLLER_WIDGET_ORDER_TRANSPORT,
	PLAYER_CONTROLLER_WIDGET_ORDER_PLAYLISTS
} PlayerControllerwidget_order;

typedef enum  {
	TRANSPORT_MENUITEM_ACTION_PREVIOUS,
	TRANSPORT_MENUITEM_ACTION_PLAY_PAUSE,
	TRANSPORT_MENUITEM_ACTION_NEXT
} TransportMenuitemaction;


static gpointer mpris2_controller_parent_class = NULL;

GType free_desktop_properties_get_type (void) G_GNUC_CONST;
GType free_desktop_properties_proxy_get_type (void) G_GNUC_CONST;
guint free_desktop_properties_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
static void g_cclosure_user_marshal_VOID__STRING_BOXED_BOXED_INT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void free_desktop_properties_proxy_g_signal (GDBusProxy* proxy, const gchar* sender_name, const gchar* signal_name, GVariant* parameters);
static void _dbus_handle_free_desktop_properties_properties_changed (FreeDesktopProperties* self, GVariant* parameters);
static void free_desktop_properties_proxy_free_desktop_properties_interface_init (FreeDesktopPropertiesIface* iface);
static void free_desktop_properties_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data);
static GVariant* free_desktop_properties_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data);
static gboolean free_desktop_properties_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data);
static void _dbus_free_desktop_properties_properties_changed (GObject* _sender, const gchar* source, GHashTable* changed_properties, gchar** invalid, int invalid_length1, gpointer* _data);
static void _free_desktop_properties_unregister_object (gpointer user_data);
GType mpris2_controller_get_type (void) G_GNUC_CONST;
GType mpris_root_proxy_get_type (void) G_GNUC_CONST;
guint mpris_root_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
GType mpris_root_get_type (void) G_GNUC_CONST;
GType mpris_player_proxy_get_type (void) G_GNUC_CONST;
guint mpris_player_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
GType mpris_player_get_type (void) G_GNUC_CONST;
GType mpris_playlists_proxy_get_type (void) G_GNUC_CONST;
guint mpris_playlists_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
GType playlist_details_get_type (void) G_GNUC_CONST;
PlaylistDetails* playlist_details_dup (const PlaylistDetails* self);
void playlist_details_free (PlaylistDetails* self);
void playlist_details_copy (const PlaylistDetails* self, PlaylistDetails* dest);
void playlist_details_destroy (PlaylistDetails* self);
GType active_playlist_container_get_type (void) G_GNUC_CONST;
ActivePlaylistContainer* active_playlist_container_dup (const ActivePlaylistContainer* self);
void active_playlist_container_free (ActivePlaylistContainer* self);
void active_playlist_container_copy (const ActivePlaylistContainer* self, ActivePlaylistContainer* dest);
void active_playlist_container_destroy (ActivePlaylistContainer* self);
GType mpris_playlists_get_type (void) G_GNUC_CONST;
GType player_controller_get_type (void) G_GNUC_CONST;
#define MPRIS2_CONTROLLER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_MPRIS2_CONTROLLER, Mpris2ControllerPrivate))
enum  {
	MPRIS2_CONTROLLER_DUMMY_PROPERTY,
	MPRIS2_CONTROLLER_MPRIS2_ROOT,
	MPRIS2_CONTROLLER_PLAYER,
	MPRIS2_CONTROLLER_PLAYLISTS,
	MPRIS2_CONTROLLER_PROPERTIES_INTERFACE,
	MPRIS2_CONTROLLER_OWNER
};
Mpris2Controller* mpris2_controller_new (PlayerController* ctrl);
Mpris2Controller* mpris2_controller_construct (GType object_type, PlayerController* ctrl);
void mpris2_controller_property_changed_cb (Mpris2Controller* self, const gchar* interface_source, GHashTable* changed_properties, gchar** invalid, int invalid_length1);
PlayerController* mpris2_controller_get_owner (Mpris2Controller* self);
const gchar* player_controller_get_dbus_name (PlayerController* self);
#define MPRIS2_WATCHER_MPRIS_PREFIX "org.mpris.MediaPlayer2."
MprisPlayer* mpris2_controller_get_player (Mpris2Controller* self);
gchar* mpris_player_get_PlaybackStatus (MprisPlayer* self);
static gboolean mpris2_controller_ensure_correct_playback_status (Mpris2Controller* self);
static gboolean _mpris2_controller_ensure_correct_playback_status_gsource_func (gpointer self);
GType transport_menuitem_state_get_type (void) G_GNUC_CONST;
static TransportMenuitemstate mpris2_controller_determine_play_state (Mpris2Controller* self, const gchar* status);
GType player_item_get_type (void) G_GNUC_CONST;
GType player_controller_widget_order_get_type (void) G_GNUC_CONST;
GType transport_menuitem_get_type (void) G_GNUC_CONST;
void transport_menuitem_change_play_state (TransportMenuitem* self, TransportMenuitemstate update);
static GHashTable* mpris2_controller_clean_metadata (Mpris2Controller* self);
void player_item_reset (PlayerItem* self, GeeHashSet* attrs);
GeeHashSet* metadata_menuitem_attributes_format (void);
void player_item_update (PlayerItem* self, GHashTable* data, GeeHashSet* attributes);
gboolean player_item_populated (PlayerItem* self, GeeHashSet* attrs);
static void mpris2_controller_fetch_active_playlist (Mpris2Controller* self);
gboolean mpris2_controller_playlists_support_exist (Mpris2Controller* self);
MprisPlaylists* mpris2_controller_get_playlists (Mpris2Controller* self);
guint32 mpris_playlists_get_PlaylistCount (MprisPlaylists* self);
static guint32* _uint32_dup (guint32* self);
GHashTable* mpris_player_get_Metadata (MprisPlayer* self);
static gchar** _variant_get1 (GVariant* value, int* result_length1);
static gchar** _vala_array_dup1 (gchar** self, int length);
static GVariant* _variant_new2 (const gchar* value);
static const gchar* _variant_get3 (GVariant* value);
static GVariant* _variant_new4 (gint64 value);
void mpris2_controller_initial_update (Mpris2Controller* self);
void mpris2_controller_fetch_playlists (Mpris2Controller* self);
GType transport_menuitem_action_get_type (void) G_GNUC_CONST;
void mpris2_controller_transport_update (Mpris2Controller* self, TransportMenuitemaction command);
void mpris_player_PlayPause (MprisPlayer* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void mpris_player_PlayPause_finish (MprisPlayer* self, GAsyncResult* _res_, GError** error);
void mpris_player_Previous (MprisPlayer* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void mpris_player_Previous_finish (MprisPlayer* self, GAsyncResult* _res_, GError** error);
void mpris_player_Next (MprisPlayer* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void mpris_player_Next_finish (MprisPlayer* self, GAsyncResult* _res_, GError** error);
PlaylistDetails* mpris_playlists_GetPlaylists (MprisPlaylists* self, guint32 index, guint32 max_count, const gchar* order, gboolean reverse_order, int* result_length1, GError** error);
GType playlists_menuitem_get_type (void) G_GNUC_CONST;
void playlists_menuitem_update (PlaylistsMenuitem* self, PlaylistDetails* playlists, int playlists_length1);
static void _vala_PlaylistDetails_array_free (PlaylistDetails* array, gint array_length);
void mpris_playlists_get_ActivePlaylist (MprisPlaylists* self, ActivePlaylistContainer* result);
void playlists_menuitem_update_active_playlist (PlaylistsMenuitem* self, PlaylistDetails* detail);
gboolean mpris2_controller_connected (Mpris2Controller* self);
MprisRoot* mpris2_controller_get_mpris2_root (Mpris2Controller* self);
void mpris2_controller_expose (Mpris2Controller* self);
void mpris_root_Raise (MprisRoot* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void mpris_root_Raise_finish (MprisRoot* self, GAsyncResult* _res_, GError** error);
void mpris2_controller_activate_playlist (Mpris2Controller* self, const char* path);
void mpris_playlists_ActivatePlaylist (MprisPlaylists* self, const char* playlist_id, GAsyncReadyCallback _callback_, gpointer _user_data_);
void mpris_playlists_ActivatePlaylist_finish (MprisPlaylists* self, GAsyncResult* _res_, GError** error);
static void mpris2_controller_set_mpris2_root (Mpris2Controller* self, MprisRoot* value);
static void mpris2_controller_set_player (Mpris2Controller* self, MprisPlayer* value);
static void mpris2_controller_set_playlists (Mpris2Controller* self, MprisPlaylists* value);
FreeDesktopProperties* mpris2_controller_get_properties_interface (Mpris2Controller* self);
static void mpris2_controller_set_properties_interface (Mpris2Controller* self, FreeDesktopProperties* value);
static void mpris2_controller_set_owner (Mpris2Controller* self, PlayerController* value);
static GObject * mpris2_controller_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void _mpris2_controller_property_changed_cb_free_desktop_properties_properties_changed (FreeDesktopProperties* _sender, const gchar* source, GHashTable* changed_properties, gchar** invalid, int invalid_length1, gpointer self);
static void mpris2_controller_finalize (GObject* obj);
static void _vala_mpris2_controller_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_mpris2_controller_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);

static const GDBusMethodInfo * const _free_desktop_properties_dbus_method_info[] = {NULL};
static const GDBusArgInfo _free_desktop_properties_dbus_arg_info_properties_changed_source = {-1, "source", "s"};
static const GDBusArgInfo _free_desktop_properties_dbus_arg_info_properties_changed_changed_properties = {-1, "changed_properties", "a{sv}"};
static const GDBusArgInfo _free_desktop_properties_dbus_arg_info_properties_changed_invalid = {-1, "invalid", "as"};
static const GDBusArgInfo * const _free_desktop_properties_dbus_arg_info_properties_changed[] = {&_free_desktop_properties_dbus_arg_info_properties_changed_source, &_free_desktop_properties_dbus_arg_info_properties_changed_changed_properties, &_free_desktop_properties_dbus_arg_info_properties_changed_invalid, NULL};
static const GDBusSignalInfo _free_desktop_properties_dbus_signal_info_properties_changed = {-1, "PropertiesChanged", (GDBusArgInfo **) (&_free_desktop_properties_dbus_arg_info_properties_changed)};
static const GDBusSignalInfo * const _free_desktop_properties_dbus_signal_info[] = {&_free_desktop_properties_dbus_signal_info_properties_changed, NULL};
static const GDBusPropertyInfo * const _free_desktop_properties_dbus_property_info[] = {NULL};
static const GDBusInterfaceInfo _free_desktop_properties_dbus_interface_info = {-1, "org.freedesktop.DBus.Properties", (GDBusMethodInfo **) (&_free_desktop_properties_dbus_method_info), (GDBusSignalInfo **) (&_free_desktop_properties_dbus_signal_info), (GDBusPropertyInfo **) (&_free_desktop_properties_dbus_property_info)};
static const GDBusInterfaceVTable _free_desktop_properties_dbus_interface_vtable = {free_desktop_properties_dbus_interface_method_call, free_desktop_properties_dbus_interface_get_property, free_desktop_properties_dbus_interface_set_property};

static void g_cclosure_user_marshal_VOID__STRING_BOXED_BOXED_INT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__STRING_BOXED_BOXED_INT) (gpointer data1, const char* arg_1, gpointer arg_2, gpointer arg_3, gint arg_4, gpointer data2);
	register GMarshalFunc_VOID__STRING_BOXED_BOXED_INT callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 5);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_BOXED_BOXED_INT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_boxed (param_values + 2), g_value_get_boxed (param_values + 3), g_value_get_int (param_values + 4), data2);
}


static void free_desktop_properties_base_init (FreeDesktopPropertiesIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
		g_signal_new ("properties_changed", TYPE_FREE_DESKTOP_PROPERTIES, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_BOXED_BOXED_INT, G_TYPE_NONE, 4, G_TYPE_STRING, G_TYPE_HASH_TABLE, G_TYPE_STRV, G_TYPE_INT);
		g_type_set_qdata (TYPE_FREE_DESKTOP_PROPERTIES, g_quark_from_static_string ("vala-dbus-register-object"), (void*) free_desktop_properties_register_object);
	}
}


GType free_desktop_properties_get_type (void) {
	static volatile gsize free_desktop_properties_type_id__volatile = 0;
	if (g_once_init_enter (&free_desktop_properties_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FreeDesktopPropertiesIface), (GBaseInitFunc) free_desktop_properties_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType free_desktop_properties_type_id;
		free_desktop_properties_type_id = g_type_register_static (G_TYPE_INTERFACE, "FreeDesktopProperties", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (free_desktop_properties_type_id, G_TYPE_OBJECT);
		g_once_init_leave (&free_desktop_properties_type_id__volatile, free_desktop_properties_type_id);
	}
	return free_desktop_properties_type_id__volatile;
}


G_DEFINE_TYPE_EXTENDED (FreeDesktopPropertiesProxy, free_desktop_properties_proxy, G_TYPE_DBUS_PROXY, 0, G_IMPLEMENT_INTERFACE (TYPE_FREE_DESKTOP_PROPERTIES, free_desktop_properties_proxy_free_desktop_properties_interface_init) );
static void free_desktop_properties_proxy_class_init (FreeDesktopPropertiesProxyClass* klass) {
	G_DBUS_PROXY_CLASS (klass)->g_signal = free_desktop_properties_proxy_g_signal;
}


static void _dbus_handle_free_desktop_properties_properties_changed (FreeDesktopProperties* self, GVariant* parameters) {
	GVariantIter _arguments_iter;
	gchar* source = NULL;
	GVariant* _tmp79_;
	GHashTable* changed_properties = NULL;
	GVariant* _tmp80_;
	GHashTable* _tmp81_;
	GVariantIter _tmp82_;
	GVariant* _tmp83_;
	GVariant* _tmp84_;
	gchar** invalid = NULL;
	int invalid_length1;
	GVariant* _tmp85_;
	gchar** _tmp86_;
	int _tmp86__length;
	int _tmp86__size;
	int _tmp86__length1;
	GVariantIter _tmp87_;
	GVariant* _tmp88_;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp79_ = g_variant_iter_next_value (&_arguments_iter);
	source = g_variant_dup_string (_tmp79_, NULL);
	g_variant_unref (_tmp79_);
	_tmp80_ = g_variant_iter_next_value (&_arguments_iter);
	_tmp81_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
	g_variant_iter_init (&_tmp82_, _tmp80_);
	while (g_variant_iter_loop (&_tmp82_, "{?*}", &_tmp83_, &_tmp84_)) {
		g_hash_table_insert (_tmp81_, g_variant_dup_string (_tmp83_, NULL), g_variant_get_variant (_tmp84_));
	}
	changed_properties = _tmp81_;
	g_variant_unref (_tmp80_);
	invalid_length1 = 0;
	_tmp85_ = g_variant_iter_next_value (&_arguments_iter);
	_tmp86_ = g_new (gchar*, 5);
	_tmp86__length = 0;
	_tmp86__size = 4;
	_tmp86__length1 = 0;
	g_variant_iter_init (&_tmp87_, _tmp85_);
	for (; _tmp88_ = g_variant_iter_next_value (&_tmp87_); _tmp86__length1++) {
		if (_tmp86__size == _tmp86__length) {
			_tmp86__size = 2 * _tmp86__size;
			_tmp86_ = g_renew (gchar*, _tmp86_, _tmp86__size + 1);
		}
		_tmp86_[_tmp86__length++] = g_variant_dup_string (_tmp88_, NULL);
		g_variant_unref (_tmp88_);
	}
	invalid_length1 = _tmp86__length1;
	_tmp86_[_tmp86__length] = NULL;
	invalid = _tmp86_;
	g_variant_unref (_tmp85_);
	g_signal_emit_by_name (self, "properties-changed", source, changed_properties, invalid, invalid_length1);
	_g_free0 (source);
	_g_hash_table_unref0 (changed_properties);
	invalid = (_vala_array_free (invalid, invalid_length1, (GDestroyNotify) g_free), NULL);
}


static void free_desktop_properties_proxy_g_signal (GDBusProxy* proxy, const gchar* sender_name, const gchar* signal_name, GVariant* parameters) {
	if (strcmp (signal_name, "PropertiesChanged") == 0) {
		_dbus_handle_free_desktop_properties_properties_changed (proxy, parameters);
	}
}


static void free_desktop_properties_proxy_init (FreeDesktopPropertiesProxy* self) {
}


static void free_desktop_properties_proxy_free_desktop_properties_interface_init (FreeDesktopPropertiesIface* iface) {
}


static void free_desktop_properties_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	g_object_unref (invocation);
}


static GVariant* free_desktop_properties_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return NULL;
}


static gboolean free_desktop_properties_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return FALSE;
}


static void _dbus_free_desktop_properties_properties_changed (GObject* _sender, const gchar* source, GHashTable* changed_properties, gchar** invalid, int invalid_length1, gpointer* _data) {
	GDBusConnection * _connection;
	const gchar * _path;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	GVariantBuilder _tmp89_;
	GHashTableIter _tmp90_;
	gpointer _tmp91_;
	gpointer _tmp92_;
	gchar** _tmp93_;
	GVariantBuilder _tmp94_;
	int _tmp95_;
	_connection = _data[1];
	_path = _data[2];
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (source));
	g_hash_table_iter_init (&_tmp90_, changed_properties);
	g_variant_builder_init (&_tmp89_, G_VARIANT_TYPE_DICTIONARY);
	while (g_hash_table_iter_next (&_tmp90_, &_tmp91_, &_tmp92_)) {
		gchar* _key;
		GVariant* _value;
		_key = (gchar*) _tmp91_;
		_value = (GVariant*) _tmp92_;
		g_variant_builder_add (&_tmp89_, "{?*}", g_variant_new_string (_key), g_variant_new_variant (_value));
	}
	g_variant_builder_add_value (&_arguments_builder, g_variant_builder_end (&_tmp89_));
	_tmp93_ = invalid;
	g_variant_builder_init (&_tmp94_, G_VARIANT_TYPE ("as"));
	for (_tmp95_ = 0; _tmp95_ < invalid_length1; _tmp95_++) {
		g_variant_builder_add_value (&_tmp94_, g_variant_new_string (*_tmp93_));
		_tmp93_++;
	}
	g_variant_builder_add_value (&_arguments_builder, g_variant_builder_end (&_tmp94_));
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_connection_emit_signal (_connection, NULL, _path, "org.freedesktop.DBus.Properties", "PropertiesChanged", _arguments, NULL);
}


guint free_desktop_properties_register_object (gpointer object, GDBusConnection* connection, const gchar* path, GError** error) {
	guint result;
	gpointer *data;
	data = g_new (gpointer, 3);
	data[0] = g_object_ref (object);
	data[1] = g_object_ref (connection);
	data[2] = g_strdup (path);
	result = g_dbus_connection_register_object (connection, path, &_free_desktop_properties_dbus_interface_info, &_free_desktop_properties_dbus_interface_vtable, data, _free_desktop_properties_unregister_object, error);
	if (!result) {
		return 0;
	}
	g_signal_connect (object, "properties-changed", (GCallback) _dbus_free_desktop_properties_properties_changed, data);
	return result;
}


static void _free_desktop_properties_unregister_object (gpointer user_data) {
	gpointer* data;
	data = user_data;
	g_object_unref (data[0]);
	g_object_unref (data[1]);
	g_free (data[2]);
	g_free (data);
}


Mpris2Controller* mpris2_controller_construct (GType object_type, PlayerController* ctrl) {
	Mpris2Controller * self = NULL;
	g_return_val_if_fail (ctrl != NULL, NULL);
	self = (Mpris2Controller*) g_object_new (object_type, "owner", ctrl, NULL);
	return self;
}


Mpris2Controller* mpris2_controller_new (PlayerController* ctrl) {
	return mpris2_controller_construct (TYPE_MPRIS2_CONTROLLER, ctrl);
}


static gpointer _g_variant_ref0 (gpointer self) {
	return self ? g_variant_ref (self) : NULL;
}


static gboolean _mpris2_controller_ensure_correct_playback_status_gsource_func (gpointer self) {
	gboolean result;
	result = mpris2_controller_ensure_correct_playback_status (self);
	return result;
}


void mpris2_controller_property_changed_cb (Mpris2Controller* self, const gchar* interface_source, GHashTable* changed_properties, gchar** invalid, int invalid_length1) {
	const gchar* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gconstpointer _tmp3_ = NULL;
	GVariant* _tmp4_;
	GVariant* play_v;
	gconstpointer _tmp10_ = NULL;
	GVariant* _tmp11_;
	GVariant* meta_v;
	gconstpointer _tmp21_ = NULL;
	GVariant* _tmp22_;
	GVariant* playlist_v;
	g_return_if_fail (self != NULL);
	g_return_if_fail (interface_source != NULL);
	g_return_if_fail (changed_properties != NULL);
	_tmp0_ = player_controller_get_dbus_name (self->priv->_owner);
	g_debug ("mpris2-controller.vala:71: properties-changed for interface %s and own" \
"er %s", interface_source, _tmp0_);
	if (changed_properties == NULL) {
		_tmp1_ = TRUE;
	} else {
		gboolean _tmp2_;
		_tmp2_ = g_str_has_prefix (interface_source, MPRIS2_WATCHER_MPRIS_PREFIX);
		_tmp1_ = _tmp2_ == FALSE;
	}
	if (_tmp1_) {
		g_warning ("mpris2-controller.vala:74: Property-changed hash is null or this is an" \
" interface that doesn't concerns us");
		return;
	}
	_tmp3_ = g_hash_table_lookup (changed_properties, "PlaybackStatus");
	_tmp4_ = _g_variant_ref0 ((GVariant*) _tmp3_);
	play_v = _tmp4_;
	if (play_v != NULL) {
		gchar* _tmp5_ = NULL;
		gchar* state;
		TransportMenuitemstate _tmp6_;
		TransportMenuitemstate p;
		gpointer _tmp7_ = NULL;
		PlayerItem* _tmp8_;
		TransportMenuitem* _tmp9_;
		_tmp5_ = mpris_player_get_PlaybackStatus (self->priv->_player);
		state = _tmp5_;
		g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 200, _mpris2_controller_ensure_correct_playback_status_gsource_func, g_object_ref (self), g_object_unref);
		_tmp6_ = mpris2_controller_determine_play_state (self, state);
		p = (TransportMenuitemstate) _tmp6_;
		_tmp7_ = gee_abstract_list_get ((GeeAbstractList*) self->priv->_owner->custom_items, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_TRANSPORT);
		_tmp9_ = (_tmp8_ = (PlayerItem*) _tmp7_, IS_TRANSPORT_MENUITEM (_tmp8_) ? ((TransportMenuitem*) _tmp8_) : NULL);
		transport_menuitem_change_play_state (_tmp9_, p);
		_g_object_unref0 (_tmp9_);
		_g_free0 (state);
	}
	_tmp10_ = g_hash_table_lookup (changed_properties, "Metadata");
	_tmp11_ = _g_variant_ref0 ((GVariant*) _tmp10_);
	meta_v = _tmp11_;
	if (meta_v != NULL) {
		GHashTable* _tmp12_ = NULL;
		GHashTable* changed_updates;
		gpointer _tmp13_ = NULL;
		PlayerItem* metadata;
		GeeHashSet* _tmp14_ = NULL;
		GeeHashSet* _tmp15_;
		GeeHashSet* _tmp16_ = NULL;
		GeeHashSet* _tmp17_;
		GeeHashSet* _tmp18_ = NULL;
		GeeHashSet* _tmp19_;
		gboolean _tmp20_;
		_tmp12_ = mpris2_controller_clean_metadata (self);
		changed_updates = _tmp12_;
		_tmp13_ = gee_abstract_list_get ((GeeAbstractList*) self->priv->_owner->custom_items, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_METADATA);
		metadata = (PlayerItem*) _tmp13_;
		_tmp14_ = metadata_menuitem_attributes_format ();
		_tmp15_ = _tmp14_;
		player_item_reset (metadata, _tmp15_);
		_g_object_unref0 (_tmp15_);
		_tmp16_ = metadata_menuitem_attributes_format ();
		_tmp17_ = _tmp16_;
		player_item_update (metadata, changed_updates, _tmp17_);
		_g_object_unref0 (_tmp17_);
		_tmp18_ = metadata_menuitem_attributes_format ();
		_tmp19_ = _tmp18_;
		_tmp20_ = player_item_populated (metadata, _tmp19_);
		dbusmenu_menuitem_property_set_bool ((DbusmenuMenuitem*) metadata, DBUSMENU_MENUITEM_PROP_VISIBLE, _tmp20_);
		_g_object_unref0 (_tmp19_);
		_g_object_unref0 (metadata);
		_g_hash_table_unref0 (changed_updates);
	}
	_tmp21_ = g_hash_table_lookup (changed_properties, "ActivePlaylist");
	_tmp22_ = _g_variant_ref0 ((GVariant*) _tmp21_);
	playlist_v = _tmp22_;
	if (playlist_v != NULL) {
		mpris2_controller_fetch_active_playlist (self);
	}
	_g_variant_unref0 (playlist_v);
	_g_variant_unref0 (meta_v);
	_g_variant_unref0 (play_v);
}


static guint32* _uint32_dup (guint32* self) {
	guint32* dup;
	dup = g_new0 (guint32, 1);
	memcpy (dup, self, sizeof (guint32));
	return dup;
}


static gpointer __uint32_dup0 (gpointer self) {
	return self ? _uint32_dup (self) : NULL;
}


gboolean mpris2_controller_playlists_support_exist (Mpris2Controller* self) {
	gboolean result = FALSE;
	guint32 _tmp0_;
	guint32* _tmp1_;
	guint32* count;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	if (self->priv->_playlists == NULL) {
		result = FALSE;
		return result;
	}
	_tmp0_ = mpris_playlists_get_PlaylistCount (self->priv->_playlists);
	_tmp1_ = __uint32_dup0 (&_tmp0_);
	count = _tmp1_;
	if (count == NULL) {
		_tmp2_ = TRUE;
	} else {
		_tmp2_ = (*count) <= 0;
	}
	if (_tmp2_) {
		result = FALSE;
		_g_free0 (count);
		return result;
	}
	result = TRUE;
	_g_free0 (count);
	return result;
}


static gboolean mpris2_controller_ensure_correct_playback_status (Mpris2Controller* self) {
	gboolean result = FALSE;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	TransportMenuitemstate _tmp4_;
	TransportMenuitemstate _tmp5_;
	TransportMenuitemstate p;
	gpointer _tmp6_ = NULL;
	PlayerItem* _tmp7_;
	TransportMenuitem* _tmp8_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = mpris_player_get_PlaybackStatus (self->priv->_player);
	_tmp1_ = _tmp0_;
	g_debug ("mpris2-controller.vala:113: TEST playback status = %s", _tmp1_);
	_g_free0 (_tmp1_);
	_tmp2_ = mpris_player_get_PlaybackStatus (self->priv->_player);
	_tmp3_ = _tmp2_;
	_tmp4_ = mpris2_controller_determine_play_state (self, _tmp3_);
	p = (_tmp5_ = (TransportMenuitemstate) _tmp4_, _g_free0 (_tmp3_), _tmp5_);
	_tmp6_ = gee_abstract_list_get ((GeeAbstractList*) self->priv->_owner->custom_items, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_TRANSPORT);
	_tmp8_ = (_tmp7_ = (PlayerItem*) _tmp6_, IS_TRANSPORT_MENUITEM (_tmp7_) ? ((TransportMenuitem*) _tmp7_) : NULL);
	transport_menuitem_change_play_state (_tmp8_, p);
	_g_object_unref0 (_tmp8_);
	result = FALSE;
	return result;
}


static gchar** _variant_get1 (GVariant* value, int* result_length1) {
	gchar** _tmp10_;
	int _tmp10__length;
	int _tmp10__size;
	int _tmp10__length1;
	GVariantIter _tmp11_;
	GVariant* _tmp12_;
	_tmp10_ = g_new (gchar*, 5);
	_tmp10__length = 0;
	_tmp10__size = 4;
	_tmp10__length1 = 0;
	g_variant_iter_init (&_tmp11_, value);
	for (; _tmp12_ = g_variant_iter_next_value (&_tmp11_); _tmp10__length1++) {
		if (_tmp10__size == _tmp10__length) {
			_tmp10__size = 2 * _tmp10__size;
			_tmp10_ = g_renew (gchar*, _tmp10_, _tmp10__size + 1);
		}
		_tmp10_[_tmp10__length++] = g_variant_dup_string (_tmp12_, NULL);
		g_variant_unref (_tmp12_);
	}
	*result_length1 = _tmp10__length1;
	_tmp10_[_tmp10__length] = NULL;
	return _tmp10_;
}


static gchar** _vala_array_dup1 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		result[i] = g_strdup (self[i]);
	}
	return result;
}


static GVariant* _variant_new2 (const gchar* value) {
	return g_variant_ref_sink (g_variant_new_string (value));
}


static const gchar* _variant_get3 (GVariant* value) {
	return g_variant_dup_string (value, NULL);
}


static GVariant* _variant_new4 (gint64 value) {
	return g_variant_ref_sink (g_variant_new_int64 (value));
}


static GHashTable* mpris2_controller_clean_metadata (Mpris2Controller* self) {
	GHashTable* result = NULL;
	GHashTable* _tmp0_ = NULL;
	GHashTable* changed_updates;
	GHashTable* _tmp1_ = NULL;
	GHashTable* _tmp2_;
	gconstpointer _tmp3_ = NULL;
	GVariant* _tmp4_;
	GVariant* _tmp5_;
	GVariant* artist_v;
	GHashTable* _tmp20_ = NULL;
	GHashTable* _tmp21_;
	gconstpointer _tmp22_ = NULL;
	GVariant* _tmp23_;
	GVariant* _tmp24_;
	GVariant* length_v;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = mpris_player_get_Metadata (self->priv->_player);
	changed_updates = _tmp0_;
	_tmp1_ = mpris_player_get_Metadata (self->priv->_player);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_hash_table_lookup (_tmp2_, "xesam:artist");
	_tmp4_ = _g_variant_ref0 ((GVariant*) _tmp3_);
	artist_v = (_tmp5_ = _tmp4_, _g_hash_table_unref0 (_tmp2_), _tmp5_);
	if (artist_v != NULL) {
		GHashTable* _tmp6_ = NULL;
		GHashTable* _tmp7_;
		gconstpointer _tmp8_ = NULL;
		gint _tmp9_;
		gchar** _tmp13_;
		gchar** _tmp14_;
		gchar** _tmp15_;
		gint artists_length1;
		gint _artists_size_;
		gchar** _tmp16_;
		gchar** artists;
		gchar* _tmp17_ = NULL;
		gchar* display_artists;
		gchar* _tmp18_;
		gconstpointer _tmp19_ = NULL;
		_tmp6_ = mpris_player_get_Metadata (self->priv->_player);
		_tmp7_ = _tmp6_;
		_tmp8_ = g_hash_table_lookup (_tmp7_, "xesam:artist");
		_tmp13_ = (_tmp14_ = _variant_get1 ((GVariant*) _tmp8_, &_tmp9_), (_tmp14_ == NULL) ? ((gpointer) _tmp14_) : _vala_array_dup1 (_tmp14_, _tmp9_));
		_tmp16_ = (_tmp15_ = _tmp13_, _g_hash_table_unref0 (_tmp7_), _tmp15_);
		artists_length1 = _tmp9_;
		_artists_size_ = artists_length1;
		artists = _tmp16_;
		_tmp17_ = g_strjoinv (", ", artists);
		display_artists = _tmp17_;
		_tmp18_ = g_strdup ("xesam:artist");
		g_hash_table_replace (changed_updates, _tmp18_, _variant_new2 (display_artists));
		_tmp19_ = g_hash_table_lookup (changed_updates, "xesam:artist");
		g_debug ("mpris2-controller.vala:127: artist : %s", _variant_get3 ((GVariant*) _tmp19_));
		_g_free0 (display_artists);
		artists = (_vala_array_free (artists, artists_length1, (GDestroyNotify) g_free), NULL);
	}
	_tmp20_ = mpris_player_get_Metadata (self->priv->_player);
	_tmp21_ = _tmp20_;
	_tmp22_ = g_hash_table_lookup (_tmp21_, "mpris:length");
	_tmp23_ = _g_variant_ref0 ((GVariant*) _tmp22_);
	length_v = (_tmp24_ = _tmp23_, _g_hash_table_unref0 (_tmp21_), _tmp24_);
	if (length_v != NULL) {
		GHashTable* _tmp25_ = NULL;
		GHashTable* _tmp26_;
		gconstpointer _tmp27_ = NULL;
		gint64 _tmp28_;
		gint64 _tmp29_;
		gint64 duration;
		gchar* _tmp30_;
		_tmp25_ = mpris_player_get_Metadata (self->priv->_player);
		_tmp26_ = _tmp25_;
		_tmp27_ = g_hash_table_lookup (_tmp26_, "mpris:length");
		_tmp28_ = g_variant_get_int64 ((GVariant*) _tmp27_);
		duration = (_tmp29_ = _tmp28_, _g_hash_table_unref0 (_tmp26_), _tmp29_);
		_tmp30_ = g_strdup ("mpris:length");
		g_hash_table_replace (changed_updates, _tmp30_, _variant_new4 (duration / 1000000));
	}
	result = changed_updates;
	_g_variant_unref0 (length_v);
	_g_variant_unref0 (artist_v);
	return result;
}


static TransportMenuitemstate mpris2_controller_determine_play_state (Mpris2Controller* self, const gchar* status) {
	TransportMenuitemstate result = 0;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, 0);
	if (status != NULL) {
		_tmp0_ = g_strcmp0 (status, "Playing") == 0;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		result = TRANSPORT_MENUITEM_STATE_PLAYING;
		return result;
	}
	result = TRANSPORT_MENUITEM_STATE_PAUSED;
	return result;
}


void mpris2_controller_initial_update (Mpris2Controller* self) {
	TransportMenuitemstate update = 0;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gboolean _tmp2_;
	TransportMenuitemstate _tmp3_;
	gpointer _tmp4_ = NULL;
	PlayerItem* _tmp5_;
	TransportMenuitem* _tmp6_;
	GHashTable* _tmp7_ = NULL;
	GHashTable* cleaned_metadata;
	gpointer _tmp8_ = NULL;
	PlayerItem* _tmp9_;
	GeeHashSet* _tmp10_ = NULL;
	GeeHashSet* _tmp11_;
	g_return_if_fail (self != NULL);
	_tmp0_ = mpris_player_get_PlaybackStatus (self->priv->_player);
	_tmp1_ = _tmp0_;
	if ((_tmp2_ = _tmp1_ == NULL, _g_free0 (_tmp1_), _tmp2_)) {
		update = TRANSPORT_MENUITEM_STATE_PAUSED;
	}
	_tmp3_ = mpris2_controller_determine_play_state (self, NULL);
	update = _tmp3_;
	_tmp4_ = gee_abstract_list_get ((GeeAbstractList*) self->priv->_owner->custom_items, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_TRANSPORT);
	_tmp6_ = (_tmp5_ = (PlayerItem*) _tmp4_, IS_TRANSPORT_MENUITEM (_tmp5_) ? ((TransportMenuitem*) _tmp5_) : NULL);
	transport_menuitem_change_play_state (_tmp6_, TRANSPORT_MENUITEM_STATE_PAUSED);
	_g_object_unref0 (_tmp6_);
	_tmp7_ = mpris2_controller_clean_metadata (self);
	cleaned_metadata = _tmp7_;
	_tmp8_ = gee_abstract_list_get ((GeeAbstractList*) self->priv->_owner->custom_items, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_METADATA);
	_tmp9_ = (PlayerItem*) _tmp8_;
	_tmp10_ = metadata_menuitem_attributes_format ();
	_tmp11_ = _tmp10_;
	player_item_update (_tmp9_, cleaned_metadata, _tmp11_);
	_g_object_unref0 (_tmp11_);
	_g_object_unref0 (_tmp9_);
	mpris2_controller_fetch_playlists (self);
	mpris2_controller_fetch_active_playlist (self);
	_g_hash_table_unref0 (cleaned_metadata);
}


void mpris2_controller_transport_update (Mpris2Controller* self, TransportMenuitemaction command) {
	g_return_if_fail (self != NULL);
	g_debug ("mpris2-controller.vala:163: transport_event input = %i", (gint) command);
	if (command == TRANSPORT_MENUITEM_ACTION_PLAY_PAUSE) {
		mpris_player_PlayPause (self->priv->_player, NULL, NULL);
	} else {
		if (command == TRANSPORT_MENUITEM_ACTION_PREVIOUS) {
			mpris_player_Previous (self->priv->_player, NULL, NULL);
		} else {
			if (command == TRANSPORT_MENUITEM_ACTION_NEXT) {
				mpris_player_Next (self->priv->_player, NULL, NULL);
			}
		}
	}
}


static void _vala_PlaylistDetails_array_free (PlaylistDetails* array, gint array_length) {
	if (array != NULL) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			playlist_details_destroy (&array[i]);
		}
	}
	g_free (array);
}


void mpris2_controller_fetch_playlists (Mpris2Controller* self) {
	gint _tmp0_;
	PlaylistDetails* _tmp1_ = NULL;
	gint current_playlists_length1;
	gint _current_playlists_size_;
	PlaylistDetails* _tmp2_;
	PlaylistDetails* current_playlists;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	if (self->priv->_playlists == NULL) {
		return;
	}
	_tmp1_ = mpris_playlists_GetPlaylists (self->priv->_playlists, (guint32) 0, (guint32) 10, "Alphabetical", FALSE, &_tmp0_, &_inner_error_);
	_tmp2_ = _tmp1_;
	current_playlists_length1 = _tmp0_;
	_current_playlists_size_ = current_playlists_length1;
	current_playlists = _tmp2_;
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	if (current_playlists != NULL) {
		gpointer _tmp3_ = NULL;
		PlayerItem* _tmp4_;
		PlaylistsMenuitem* playlists_item;
		g_debug ("mpris2-controller.vala:184: Size of the playlist array = %i", current_playlists_length1);
		_tmp3_ = gee_abstract_list_get ((GeeAbstractList*) self->priv->_owner->custom_items, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_PLAYLISTS);
		playlists_item = (_tmp4_ = (PlayerItem*) _tmp3_, IS_PLAYLISTS_MENUITEM (_tmp4_) ? ((PlaylistsMenuitem*) _tmp4_) : NULL);
		playlists_menuitem_update (playlists_item, current_playlists, current_playlists_length1);
		_g_object_unref0 (playlists_item);
	}
	current_playlists = (_vala_PlaylistDetails_array_free (current_playlists, current_playlists_length1), NULL);
	return;
}


static void mpris2_controller_fetch_active_playlist (Mpris2Controller* self) {
	gboolean _tmp0_ = FALSE;
	gpointer _tmp3_ = NULL;
	PlayerItem* _tmp4_;
	PlaylistsMenuitem* playlists_item;
	ActivePlaylistContainer _tmp5_ = {0};
	ActivePlaylistContainer _tmp6_;
	g_return_if_fail (self != NULL);
	if (self->priv->_playlists == NULL) {
		ActivePlaylistContainer _tmp1_ = {0};
		ActivePlaylistContainer _tmp2_;
		mpris_playlists_get_ActivePlaylist (self->priv->_playlists, &_tmp1_);
		_tmp2_ = _tmp1_;
		_tmp0_ = _tmp2_.valid == FALSE;
		active_playlist_container_destroy (&_tmp2_);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		g_warning ("mpris2-controller.vala:194: Playlists object is null or we don't have " \
"an active playlist");
	}
	_tmp3_ = gee_abstract_list_get ((GeeAbstractList*) self->priv->_owner->custom_items, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_PLAYLISTS);
	playlists_item = (_tmp4_ = (PlayerItem*) _tmp3_, IS_PLAYLISTS_MENUITEM (_tmp4_) ? ((PlaylistsMenuitem*) _tmp4_) : NULL);
	mpris_playlists_get_ActivePlaylist (self->priv->_playlists, &_tmp5_);
	_tmp6_ = _tmp5_;
	playlists_menuitem_update_active_playlist (playlists_item, &_tmp6_.details);
	active_playlist_container_destroy (&_tmp6_);
	_g_object_unref0 (playlists_item);
}


gboolean mpris2_controller_connected (Mpris2Controller* self) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	if (self->priv->_player != NULL) {
		_tmp0_ = self->priv->_mpris2_root != NULL;
	} else {
		_tmp0_ = FALSE;
	}
	result = _tmp0_;
	return result;
}


void mpris2_controller_expose (Mpris2Controller* self) {
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = mpris2_controller_connected (self);
	if (_tmp0_ == TRUE) {
		mpris_root_Raise (self->priv->_mpris2_root, NULL, NULL);
	}
}


void mpris2_controller_activate_playlist (Mpris2Controller* self, const char* path) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (path != NULL);
	if (self->priv->_playlists == NULL) {
		g_warning ("mpris2-controller.vala:216: playlists mpris instance is null !");
		return;
	}
	mpris_playlists_ActivatePlaylist (self->priv->_playlists, path, NULL, NULL);
	goto __finally10;
	__catch10_g_io_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_debug ("mpris2-controller.vala:223: Could not activate playlist %s because %s", (const gchar*) path, e->message);
		_g_error_free0 (e);
	}
	__finally10:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


MprisRoot* mpris2_controller_get_mpris2_root (Mpris2Controller* self) {
	MprisRoot* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_mpris2_root;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void mpris2_controller_set_mpris2_root (Mpris2Controller* self, MprisRoot* value) {
	MprisRoot* _tmp0_;
	MprisRoot* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = _g_object_ref0 (value);
	_tmp1_ = _tmp0_;
	_g_object_unref0 (self->priv->_mpris2_root);
	self->priv->_mpris2_root = _tmp1_;
	g_object_notify ((GObject *) self, "mpris2-root");
}


MprisPlayer* mpris2_controller_get_player (Mpris2Controller* self) {
	MprisPlayer* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_player;
	return result;
}


static void mpris2_controller_set_player (Mpris2Controller* self, MprisPlayer* value) {
	MprisPlayer* _tmp0_;
	MprisPlayer* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = _g_object_ref0 (value);
	_tmp1_ = _tmp0_;
	_g_object_unref0 (self->priv->_player);
	self->priv->_player = _tmp1_;
	g_object_notify ((GObject *) self, "player");
}


MprisPlaylists* mpris2_controller_get_playlists (Mpris2Controller* self) {
	MprisPlaylists* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_playlists;
	return result;
}


static void mpris2_controller_set_playlists (Mpris2Controller* self, MprisPlaylists* value) {
	MprisPlaylists* _tmp0_;
	MprisPlaylists* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = _g_object_ref0 (value);
	_tmp1_ = _tmp0_;
	_g_object_unref0 (self->priv->_playlists);
	self->priv->_playlists = _tmp1_;
	g_object_notify ((GObject *) self, "playlists");
}


FreeDesktopProperties* mpris2_controller_get_properties_interface (Mpris2Controller* self) {
	FreeDesktopProperties* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_properties_interface;
	return result;
}


static void mpris2_controller_set_properties_interface (Mpris2Controller* self, FreeDesktopProperties* value) {
	FreeDesktopProperties* _tmp0_;
	FreeDesktopProperties* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = _g_object_ref0 (value);
	_tmp1_ = _tmp0_;
	_g_object_unref0 (self->priv->_properties_interface);
	self->priv->_properties_interface = _tmp1_;
	g_object_notify ((GObject *) self, "properties-interface");
}


PlayerController* mpris2_controller_get_owner (Mpris2Controller* self) {
	PlayerController* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_owner;
	return result;
}


static void mpris2_controller_set_owner (Mpris2Controller* self, PlayerController* value) {
	PlayerController* _tmp0_;
	PlayerController* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = _g_object_ref0 (value);
	_tmp1_ = _tmp0_;
	_g_object_unref0 (self->priv->_owner);
	self->priv->_owner = _tmp1_;
	g_object_notify ((GObject *) self, "owner");
}


static void _mpris2_controller_property_changed_cb_free_desktop_properties_properties_changed (FreeDesktopProperties* _sender, const gchar* source, GHashTable* changed_properties, gchar** invalid, int invalid_length1, gpointer self) {
	mpris2_controller_property_changed_cb (self, source, changed_properties, invalid, invalid_length1);
}


static GObject * mpris2_controller_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	Mpris2Controller * self;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	MprisRoot* _tmp2_;
	MprisRoot* _tmp3_;
	const gchar* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	MprisPlayer* _tmp6_;
	MprisPlayer* _tmp7_;
	const gchar* _tmp8_ = NULL;
	const gchar* _tmp9_ = NULL;
	MprisPlaylists* _tmp10_;
	MprisPlaylists* _tmp11_;
	FreeDesktopProperties* _tmp12_;
	FreeDesktopProperties* _tmp13_;
	GError * _inner_error_ = NULL;
	parent_class = G_OBJECT_CLASS (mpris2_controller_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = MPRIS2_CONTROLLER (obj);
	_tmp0_ = player_controller_get_dbus_name (self->priv->_owner);
	_tmp1_ = player_controller_get_dbus_name (self->priv->_owner);
	_tmp2_ = (MprisRoot*) g_initable_new (TYPE_MPRIS_ROOT_PROXY, NULL, &_inner_error_, "g-flags", 0, "g-name", _tmp1_, "g-bus-type", G_BUS_TYPE_SESSION, "g-object-path", "/org/mpris/MediaPlayer2", "g-interface-name", "org.mpris.MediaPlayer2", NULL);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_IO_ERROR) {
			goto __catch11_g_io_error;
		}
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
	}
	_tmp3_ = _tmp2_;
	mpris2_controller_set_mpris2_root (self, _tmp3_);
	_g_object_unref0 (_tmp3_);
	_tmp4_ = player_controller_get_dbus_name (self->priv->_owner);
	_tmp5_ = player_controller_get_dbus_name (self->priv->_owner);
	_tmp6_ = (MprisPlayer*) g_initable_new (TYPE_MPRIS_PLAYER_PROXY, NULL, &_inner_error_, "g-flags", 0, "g-name", _tmp5_, "g-bus-type", G_BUS_TYPE_SESSION, "g-object-path", "/org/mpris/MediaPlayer2", "g-interface-name", "org.mpris.MediaPlayer2.Player", NULL);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_IO_ERROR) {
			goto __catch11_g_io_error;
		}
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
	}
	_tmp7_ = _tmp6_;
	mpris2_controller_set_player (self, _tmp7_);
	_g_object_unref0 (_tmp7_);
	_tmp8_ = player_controller_get_dbus_name (self->priv->_owner);
	_tmp9_ = player_controller_get_dbus_name (self->priv->_owner);
	_tmp10_ = (MprisPlaylists*) g_initable_new (TYPE_MPRIS_PLAYLISTS_PROXY, NULL, &_inner_error_, "g-flags", 0, "g-name", _tmp9_, "g-bus-type", G_BUS_TYPE_SESSION, "g-object-path", "/org/mpris/MediaPlayer2", "g-interface-name", "org.mpris.MediaPlayer2.Playlists", NULL);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_IO_ERROR) {
			goto __catch11_g_io_error;
		}
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
	}
	_tmp11_ = _tmp10_;
	mpris2_controller_set_playlists (self, _tmp11_);
	_g_object_unref0 (_tmp11_);
	_tmp12_ = (FreeDesktopProperties*) g_initable_new (TYPE_FREE_DESKTOP_PROPERTIES_PROXY, NULL, &_inner_error_, "g-flags", 0, "g-name", "org.freedesktop.Properties.PropertiesChanged", "g-bus-type", G_BUS_TYPE_SESSION, "g-object-path", "/org/mpris/MediaPlayer2", "g-interface-name", "org.freedesktop.DBus.Properties", NULL);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_IO_ERROR) {
			goto __catch11_g_io_error;
		}
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
	}
	_tmp13_ = _tmp12_;
	mpris2_controller_set_properties_interface (self, _tmp13_);
	_g_object_unref0 (_tmp13_);
	g_signal_connect_object (self->priv->_properties_interface, "properties-changed", (GCallback) _mpris2_controller_property_changed_cb_free_desktop_properties_properties_changed, self, 0);
	goto __finally11;
	__catch11_g_io_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_error ("mpris2-controller.vala:63: Problems connecting to the session bus - %s", e->message);
		_g_error_free0 (e);
	}
	__finally11:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
	}
	return obj;
}


static void mpris2_controller_class_init (Mpris2ControllerClass * klass) {
	mpris2_controller_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (Mpris2ControllerPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_mpris2_controller_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_mpris2_controller_set_property;
	G_OBJECT_CLASS (klass)->constructor = mpris2_controller_constructor;
	G_OBJECT_CLASS (klass)->finalize = mpris2_controller_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), MPRIS2_CONTROLLER_MPRIS2_ROOT, g_param_spec_object ("mpris2-root", "mpris2-root", "mpris2-root", TYPE_MPRIS_ROOT, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MPRIS2_CONTROLLER_PLAYER, g_param_spec_object ("player", "player", "player", TYPE_MPRIS_PLAYER, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MPRIS2_CONTROLLER_PLAYLISTS, g_param_spec_object ("playlists", "playlists", "playlists", TYPE_MPRIS_PLAYLISTS, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MPRIS2_CONTROLLER_PROPERTIES_INTERFACE, g_param_spec_object ("properties-interface", "properties-interface", "properties-interface", TYPE_FREE_DESKTOP_PROPERTIES, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MPRIS2_CONTROLLER_OWNER, g_param_spec_object ("owner", "owner", "owner", TYPE_PLAYER_CONTROLLER, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
}


static void mpris2_controller_instance_init (Mpris2Controller * self) {
	self->priv = MPRIS2_CONTROLLER_GET_PRIVATE (self);
}


static void mpris2_controller_finalize (GObject* obj) {
	Mpris2Controller * self;
	self = MPRIS2_CONTROLLER (obj);
	_g_object_unref0 (self->priv->_mpris2_root);
	_g_object_unref0 (self->priv->_player);
	_g_object_unref0 (self->priv->_playlists);
	_g_object_unref0 (self->priv->_properties_interface);
	_g_object_unref0 (self->priv->_owner);
	G_OBJECT_CLASS (mpris2_controller_parent_class)->finalize (obj);
}


GType mpris2_controller_get_type (void) {
	static volatile gsize mpris2_controller_type_id__volatile = 0;
	if (g_once_init_enter (&mpris2_controller_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (Mpris2ControllerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) mpris2_controller_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Mpris2Controller), 0, (GInstanceInitFunc) mpris2_controller_instance_init, NULL };
		GType mpris2_controller_type_id;
		mpris2_controller_type_id = g_type_register_static (G_TYPE_OBJECT, "Mpris2Controller", &g_define_type_info, 0);
		g_once_init_leave (&mpris2_controller_type_id__volatile, mpris2_controller_type_id);
	}
	return mpris2_controller_type_id__volatile;
}


static void _vala_mpris2_controller_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	Mpris2Controller * self;
	self = MPRIS2_CONTROLLER (object);
	switch (property_id) {
		case MPRIS2_CONTROLLER_MPRIS2_ROOT:
		g_value_set_object (value, mpris2_controller_get_mpris2_root (self));
		break;
		case MPRIS2_CONTROLLER_PLAYER:
		g_value_set_object (value, mpris2_controller_get_player (self));
		break;
		case MPRIS2_CONTROLLER_PLAYLISTS:
		g_value_set_object (value, mpris2_controller_get_playlists (self));
		break;
		case MPRIS2_CONTROLLER_PROPERTIES_INTERFACE:
		g_value_set_object (value, mpris2_controller_get_properties_interface (self));
		break;
		case MPRIS2_CONTROLLER_OWNER:
		g_value_set_object (value, mpris2_controller_get_owner (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_mpris2_controller_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	Mpris2Controller * self;
	self = MPRIS2_CONTROLLER (object);
	switch (property_id) {
		case MPRIS2_CONTROLLER_MPRIS2_ROOT:
		mpris2_controller_set_mpris2_root (self, g_value_get_object (value));
		break;
		case MPRIS2_CONTROLLER_PLAYER:
		mpris2_controller_set_player (self, g_value_get_object (value));
		break;
		case MPRIS2_CONTROLLER_PLAYLISTS:
		mpris2_controller_set_playlists (self, g_value_get_object (value));
		break;
		case MPRIS2_CONTROLLER_PROPERTIES_INTERFACE:
		mpris2_controller_set_properties_interface (self, g_value_get_object (value));
		break;
		case MPRIS2_CONTROLLER_OWNER:
		mpris2_controller_set_owner (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



