/* mpris2-controller.c generated by valac 0.9.5, the Vala compiler
 * generated from mpris2-controller.vala, do not modify */

/*
This service primarily controls PulseAudio and is driven by the sound indicator menu on the panel.
Copyright 2010 Canonical Ltd.

Authors:
    Conor Curran <conor.curran@canonical.com>

This program is free software: you can redistribute it and/or modify it 
under the terms of the GNU General Public License version 3, as published 
by the Free Software Foundation.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranties of 
MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along 
with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <glib.h>
#include <glib-object.h>
#include <dbus/dbus-glib-lowlevel.h>
#include <dbus/dbus-glib.h>
#include <stdlib.h>
#include <string.h>
#include <dbus/dbus.h>
#include <gee.h>
#include <libdbusmenu-glib/client.h>
#include <libdbusmenu-glib/menuitem-proxy.h>
#include <libdbusmenu-glib/menuitem.h>
#include <libdbusmenu-glib/server.h>
#include <float.h>
#include <math.h>


#define TYPE_MPRIS_ROOT (mpris_root_get_type ())
#define MPRIS_ROOT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS_ROOT, MprisRoot))
#define IS_MPRIS_ROOT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS_ROOT))
#define MPRIS_ROOT_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_MPRIS_ROOT, MprisRootIface))

typedef struct _MprisRoot MprisRoot;
typedef struct _MprisRootIface MprisRootIface;
typedef struct _DBusObjectVTable _DBusObjectVTable;
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _MprisRootDBusProxy MprisRootDBusProxy;
typedef DBusGProxyClass MprisRootDBusProxyClass;

#define TYPE_MPRIS_PLAYER (mpris_player_get_type ())
#define MPRIS_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS_PLAYER, MprisPlayer))
#define IS_MPRIS_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS_PLAYER))
#define MPRIS_PLAYER_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_MPRIS_PLAYER, MprisPlayerIface))

typedef struct _MprisPlayer MprisPlayer;
typedef struct _MprisPlayerIface MprisPlayerIface;
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
typedef struct _MprisPlayerDBusProxy MprisPlayerDBusProxy;
typedef DBusGProxyClass MprisPlayerDBusProxyClass;

#define TYPE_FREE_DESKTOP_PROPERTIES (free_desktop_properties_get_type ())
#define FREE_DESKTOP_PROPERTIES(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FREE_DESKTOP_PROPERTIES, FreeDesktopProperties))
#define IS_FREE_DESKTOP_PROPERTIES(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FREE_DESKTOP_PROPERTIES))
#define FREE_DESKTOP_PROPERTIES_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_FREE_DESKTOP_PROPERTIES, FreeDesktopPropertiesIface))

typedef struct _FreeDesktopProperties FreeDesktopProperties;
typedef struct _FreeDesktopPropertiesIface FreeDesktopPropertiesIface;
typedef struct _FreeDesktopPropertiesDBusProxy FreeDesktopPropertiesDBusProxy;
typedef DBusGProxyClass FreeDesktopPropertiesDBusProxyClass;

#define TYPE_MPRIS2_CONTROLLER (mpris2_controller_get_type ())
#define MPRIS2_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS2_CONTROLLER, Mpris2Controller))
#define MPRIS2_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MPRIS2_CONTROLLER, Mpris2ControllerClass))
#define IS_MPRIS2_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS2_CONTROLLER))
#define IS_MPRIS2_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MPRIS2_CONTROLLER))
#define MPRIS2_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MPRIS2_CONTROLLER, Mpris2ControllerClass))

typedef struct _Mpris2Controller Mpris2Controller;
typedef struct _Mpris2ControllerClass Mpris2ControllerClass;
typedef struct _Mpris2ControllerPrivate Mpris2ControllerPrivate;

#define TYPE_PLAYER_CONTROLLER (player_controller_get_type ())
#define PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_CONTROLLER, PlayerController))
#define PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))
#define IS_PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_CONTROLLER))
#define IS_PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_CONTROLLER))
#define PLAYER_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))

typedef struct _PlayerController PlayerController;
typedef struct _PlayerControllerClass PlayerControllerClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _PlayerControllerPrivate PlayerControllerPrivate;

#define TYPE_PLAYER_ITEM (player_item_get_type ())
#define PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_ITEM, PlayerItem))
#define PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_ITEM, PlayerItemClass))
#define IS_PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_ITEM))
#define IS_PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_ITEM))
#define PLAYER_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_ITEM, PlayerItemClass))

typedef struct _PlayerItem PlayerItem;
typedef struct _PlayerItemClass PlayerItemClass;

#define TYPE_MPRIS_BRIDGE (mpris_bridge_get_type ())
#define MPRIS_BRIDGE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS_BRIDGE, MprisBridge))
#define MPRIS_BRIDGE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MPRIS_BRIDGE, MprisBridgeClass))
#define IS_MPRIS_BRIDGE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS_BRIDGE))
#define IS_MPRIS_BRIDGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MPRIS_BRIDGE))
#define MPRIS_BRIDGE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MPRIS_BRIDGE, MprisBridgeClass))

typedef struct _MprisBridge MprisBridge;
typedef struct _MprisBridgeClass MprisBridgeClass;

#define PLAYER_CONTROLLER_TYPE_WIDGET_ORDER (player_controller_widget_order_get_type ())

#define TYPE_TRANSPORT_MENUITEM (transport_menuitem_get_type ())
#define TRANSPORT_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TRANSPORT_MENUITEM, TransportMenuitem))
#define TRANSPORT_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TRANSPORT_MENUITEM, TransportMenuitemClass))
#define IS_TRANSPORT_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TRANSPORT_MENUITEM))
#define IS_TRANSPORT_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TRANSPORT_MENUITEM))
#define TRANSPORT_MENUITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TRANSPORT_MENUITEM, TransportMenuitemClass))

typedef struct _TransportMenuitem TransportMenuitem;
typedef struct _TransportMenuitemClass TransportMenuitemClass;

#define TYPE_SCRUB_MENUITEM (scrub_menuitem_get_type ())
#define SCRUB_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCRUB_MENUITEM, ScrubMenuitem))
#define SCRUB_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCRUB_MENUITEM, ScrubMenuitemClass))
#define IS_SCRUB_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCRUB_MENUITEM))
#define IS_SCRUB_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCRUB_MENUITEM))
#define SCRUB_MENUITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCRUB_MENUITEM, ScrubMenuitemClass))

typedef struct _ScrubMenuitem ScrubMenuitem;
typedef struct _ScrubMenuitemClass ScrubMenuitemClass;

#define TRANSPORT_MENUITEM_TYPE_ACTION (transport_menuitem_action_get_type ())
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _dbus_g_connection_unref0(var) ((var == NULL) ? NULL : (var = (dbus_g_connection_unref (var), NULL)))

struct _MprisRootIface {
	GTypeInterface parent_iface;
	void (*Quit) (MprisRoot* self, GError** error);
	void (*Raise) (MprisRoot* self, GError** error);
	gboolean (*get_HasTracklist) (MprisRoot* self);
	void (*set_HasTracklist) (MprisRoot* self, gboolean value);
	gboolean (*get_CanQuit) (MprisRoot* self);
	void (*set_CanQuit) (MprisRoot* self, gboolean value);
	gboolean (*get_CanRaise) (MprisRoot* self);
	void (*set_CanRaise) (MprisRoot* self, gboolean value);
	char* (*get_Identity) (MprisRoot* self);
	void (*set_Identity) (MprisRoot* self, const char* value);
	char* (*get_DesktopEntry) (MprisRoot* self);
	void (*set_DesktopEntry) (MprisRoot* self, const char* value);
};

struct _DBusObjectVTable {
	void (*register_object) (DBusConnection*, const char*, void*);
};

struct _MprisRootDBusProxy {
	DBusGProxy parent_instance;
	gboolean disposed;
};

struct _MprisPlayerIface {
	GTypeInterface parent_iface;
	void (*SetPosition) (MprisPlayer* self, const char* path, gint64 pos, GError** error);
	void (*PlayPause) (MprisPlayer* self, GError** error);
	void (*Pause) (MprisPlayer* self, GError** error);
	void (*Next) (MprisPlayer* self, GError** error);
	void (*Previous) (MprisPlayer* self, GError** error);
	GHashTable* (*get_Metadata) (MprisPlayer* self);
	void (*set_Metadata) (MprisPlayer* self, GHashTable* value);
	gint32 (*get_Position) (MprisPlayer* self);
	void (*set_Position) (MprisPlayer* self, gint32 value);
	char* (*get_PlaybackStatus) (MprisPlayer* self);
	void (*set_PlaybackStatus) (MprisPlayer* self, const char* value);
};

struct _MprisPlayerDBusProxy {
	DBusGProxy parent_instance;
	gboolean disposed;
};

struct _FreeDesktopPropertiesIface {
	GTypeInterface parent_iface;
};

struct _FreeDesktopPropertiesDBusProxy {
	DBusGProxy parent_instance;
	gboolean disposed;
};

struct _Mpris2Controller {
	GObject parent_instance;
	Mpris2ControllerPrivate * priv;
};

struct _Mpris2ControllerClass {
	GObjectClass parent_class;
};

struct _Mpris2ControllerPrivate {
	MprisRoot* _mpris2_root;
	MprisPlayer* _player;
	PlayerController* _owner;
	FreeDesktopProperties* _properties_interface;
};

struct _PlayerController {
	GObject parent_instance;
	PlayerControllerPrivate * priv;
	gint current_state;
	GeeArrayList* custom_items;
	MprisBridge* mpris_bridge;
};

struct _PlayerControllerClass {
	GObjectClass parent_class;
};

typedef enum  {
	PLAYER_CONTROLLER_WIDGET_ORDER_SEPARATOR,
	PLAYER_CONTROLLER_WIDGET_ORDER_TITLE,
	PLAYER_CONTROLLER_WIDGET_ORDER_METADATA,
	PLAYER_CONTROLLER_WIDGET_ORDER_SCRUB,
	PLAYER_CONTROLLER_WIDGET_ORDER_TRANSPORT
} PlayerControllerwidget_order;

typedef enum  {
	TRANSPORT_MENUITEM_ACTION_PREVIOUS,
	TRANSPORT_MENUITEM_ACTION_PLAY_PAUSE,
	TRANSPORT_MENUITEM_ACTION_NEXT
} TransportMenuitemaction;


static gpointer mpris2_controller_parent_class = NULL;

MprisRoot* mpris_root_dbus_proxy_new (DBusGConnection* connection, const char* name, const char* path);
GType mpris_root_get_type (void) G_GNUC_CONST;
void mpris_root_Quit (MprisRoot* self, GError** error);
void mpris_root_Raise (MprisRoot* self, GError** error);
gboolean mpris_root_get_HasTracklist (MprisRoot* self);
void mpris_root_set_HasTracklist (MprisRoot* self, gboolean value);
gboolean mpris_root_get_CanQuit (MprisRoot* self);
void mpris_root_set_CanQuit (MprisRoot* self, gboolean value);
gboolean mpris_root_get_CanRaise (MprisRoot* self);
void mpris_root_set_CanRaise (MprisRoot* self, gboolean value);
char* mpris_root_get_Identity (MprisRoot* self);
void mpris_root_set_Identity (MprisRoot* self, const char* value);
char* mpris_root_get_DesktopEntry (MprisRoot* self);
void mpris_root_set_DesktopEntry (MprisRoot* self, const char* value);
static void _vala_dbus_register_object (DBusConnection* connection, const char* path, void* object);
static void _vala_dbus_unregister_object (gpointer connection, GObject* object);
void mpris_root_dbus_register_object (DBusConnection* connection, const char* path, void* object);
void _mpris_root_dbus_unregister (DBusConnection* connection, void* _user_data_);
DBusHandlerResult mpris_root_dbus_message (DBusConnection* connection, DBusMessage* message, void* object);
static DBusHandlerResult _dbus_mpris_root_introspect (MprisRoot* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_mpris_root_property_get (MprisRoot* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_mpris_root_property_set (MprisRoot* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_mpris_root_property_get_all (MprisRoot* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_mpris_root_Quit (MprisRoot* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_mpris_root_Raise (MprisRoot* self, DBusConnection* connection, DBusMessage* message);
GType mpris_root_dbus_proxy_get_type (void) G_GNUC_CONST;
DBusHandlerResult mpris_root_dbus_proxy_filter (DBusConnection* connection, DBusMessage* message, void* user_data);
enum  {
	MPRIS_ROOT_DBUS_PROXY_DUMMY_PROPERTY,
	MPRIS_ROOT_DBUS_PROXY_HAS_TRACKLIST,
	MPRIS_ROOT_DBUS_PROXY_CAN_QUIT,
	MPRIS_ROOT_DBUS_PROXY_CAN_RAISE,
	MPRIS_ROOT_DBUS_PROXY_IDENTITY,
	MPRIS_ROOT_DBUS_PROXY_DESKTOP_ENTRY
};
static void mpris_root_dbus_proxy_Quit (MprisRoot* self, GError** error);
static void mpris_root_dbus_proxy_Raise (MprisRoot* self, GError** error);
static gboolean mpris_root_dbus_proxy_get_HasTracklist (MprisRoot* self);
static void mpris_root_dbus_proxy_set_HasTracklist (MprisRoot* self, gboolean value);
static gboolean mpris_root_dbus_proxy_get_CanQuit (MprisRoot* self);
static void mpris_root_dbus_proxy_set_CanQuit (MprisRoot* self, gboolean value);
static gboolean mpris_root_dbus_proxy_get_CanRaise (MprisRoot* self);
static void mpris_root_dbus_proxy_set_CanRaise (MprisRoot* self, gboolean value);
static char* mpris_root_dbus_proxy_get_Identity (MprisRoot* self);
static void mpris_root_dbus_proxy_set_Identity (MprisRoot* self, const char* value);
static char* mpris_root_dbus_proxy_get_DesktopEntry (MprisRoot* self);
static void mpris_root_dbus_proxy_set_DesktopEntry (MprisRoot* self, const char* value);
static void mpris_root_dbus_proxy_mpris_root__interface_init (MprisRootIface* iface);
static void mpris_root_dbus_proxy_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void mpris_root_dbus_proxy_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
MprisPlayer* mpris_player_dbus_proxy_new (DBusGConnection* connection, const char* name, const char* path);
GType mpris_player_get_type (void) G_GNUC_CONST;
void mpris_player_SetPosition (MprisPlayer* self, const char* path, gint64 pos, GError** error);
void mpris_player_PlayPause (MprisPlayer* self, GError** error);
void mpris_player_Pause (MprisPlayer* self, GError** error);
void mpris_player_Next (MprisPlayer* self, GError** error);
void mpris_player_Previous (MprisPlayer* self, GError** error);
GHashTable* mpris_player_get_Metadata (MprisPlayer* self);
void mpris_player_set_Metadata (MprisPlayer* self, GHashTable* value);
gint32 mpris_player_get_Position (MprisPlayer* self);
void mpris_player_set_Position (MprisPlayer* self, gint32 value);
char* mpris_player_get_PlaybackStatus (MprisPlayer* self);
void mpris_player_set_PlaybackStatus (MprisPlayer* self, const char* value);
void mpris_player_dbus_register_object (DBusConnection* connection, const char* path, void* object);
void _mpris_player_dbus_unregister (DBusConnection* connection, void* _user_data_);
DBusHandlerResult mpris_player_dbus_message (DBusConnection* connection, DBusMessage* message, void* object);
static DBusHandlerResult _dbus_mpris_player_introspect (MprisPlayer* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_mpris_player_property_get (MprisPlayer* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_mpris_player_property_set (MprisPlayer* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_mpris_player_property_get_all (MprisPlayer* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_mpris_player_SetPosition (MprisPlayer* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_mpris_player_PlayPause (MprisPlayer* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_mpris_player_Pause (MprisPlayer* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_mpris_player_Next (MprisPlayer* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_mpris_player_Previous (MprisPlayer* self, DBusConnection* connection, DBusMessage* message);
static void _dbus_mpris_player_seeked (GObject* _sender, gint64 new_position, DBusConnection* _connection);
GType mpris_player_dbus_proxy_get_type (void) G_GNUC_CONST;
static void _dbus_handle_mpris_player_seeked (MprisPlayer* self, DBusConnection* connection, DBusMessage* message);
DBusHandlerResult mpris_player_dbus_proxy_filter (DBusConnection* connection, DBusMessage* message, void* user_data);
enum  {
	MPRIS_PLAYER_DBUS_PROXY_DUMMY_PROPERTY,
	MPRIS_PLAYER_DBUS_PROXY_METADATA,
	MPRIS_PLAYER_DBUS_PROXY_POSITION,
	MPRIS_PLAYER_DBUS_PROXY_PLAYBACK_STATUS
};
static void mpris_player_dbus_proxy_SetPosition (MprisPlayer* self, const char* path, gint64 pos, GError** error);
static void mpris_player_dbus_proxy_PlayPause (MprisPlayer* self, GError** error);
static void mpris_player_dbus_proxy_Pause (MprisPlayer* self, GError** error);
static void mpris_player_dbus_proxy_Next (MprisPlayer* self, GError** error);
static void mpris_player_dbus_proxy_Previous (MprisPlayer* self, GError** error);
static GHashTable* mpris_player_dbus_proxy_get_Metadata (MprisPlayer* self);
static void mpris_player_dbus_proxy_set_Metadata (MprisPlayer* self, GHashTable* value);
static gint32 mpris_player_dbus_proxy_get_Position (MprisPlayer* self);
static void mpris_player_dbus_proxy_set_Position (MprisPlayer* self, gint32 value);
static char* mpris_player_dbus_proxy_get_PlaybackStatus (MprisPlayer* self);
static void mpris_player_dbus_proxy_set_PlaybackStatus (MprisPlayer* self, const char* value);
static void mpris_player_dbus_proxy_mpris_player__interface_init (MprisPlayerIface* iface);
static void mpris_player_dbus_proxy_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void mpris_player_dbus_proxy_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType free_desktop_properties_get_type (void) G_GNUC_CONST;
FreeDesktopProperties* free_desktop_properties_dbus_proxy_new (DBusGConnection* connection, const char* name, const char* path);
void free_desktop_properties_dbus_register_object (DBusConnection* connection, const char* path, void* object);
void _free_desktop_properties_dbus_unregister (DBusConnection* connection, void* _user_data_);
DBusHandlerResult free_desktop_properties_dbus_message (DBusConnection* connection, DBusMessage* message, void* object);
static DBusHandlerResult _dbus_free_desktop_properties_introspect (FreeDesktopProperties* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_free_desktop_properties_property_get_all (FreeDesktopProperties* self, DBusConnection* connection, DBusMessage* message);
static void _dbus_free_desktop_properties_properties_changed (GObject* _sender, const char* source, GHashTable* changed_properties, char** invalid, int invalid_length1, DBusConnection* _connection);
GType free_desktop_properties_dbus_proxy_get_type (void) G_GNUC_CONST;
static void _dbus_handle_free_desktop_properties_properties_changed (FreeDesktopProperties* self, DBusConnection* connection, DBusMessage* message);
DBusHandlerResult free_desktop_properties_dbus_proxy_filter (DBusConnection* connection, DBusMessage* message, void* user_data);
enum  {
	FREE_DESKTOP_PROPERTIES_DBUS_PROXY_DUMMY_PROPERTY
};
static void free_desktop_properties_dbus_proxy_free_desktop_properties__interface_init (FreeDesktopPropertiesIface* iface);
static void free_desktop_properties_dbus_proxy_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void free_desktop_properties_dbus_proxy_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType mpris2_controller_get_type (void) G_GNUC_CONST;
GType player_controller_get_type (void) G_GNUC_CONST;
#define MPRIS2_CONTROLLER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_MPRIS2_CONTROLLER, Mpris2ControllerPrivate))
enum  {
	MPRIS2_CONTROLLER_DUMMY_PROPERTY,
	MPRIS2_CONTROLLER_MPRIS2_ROOT,
	MPRIS2_CONTROLLER_PLAYER,
	MPRIS2_CONTROLLER_OWNER,
	MPRIS2_CONTROLLER_PROPERTIES_INTERFACE
};
#define MPRIS2_CONTROLLER_root_interface "org.mpris.MediaPlayer2"
Mpris2Controller* mpris2_controller_new (PlayerController* ctrl);
Mpris2Controller* mpris2_controller_construct (GType object_type, PlayerController* ctrl);
static GValue* _g_value_dup (GValue* self);
static gint mpris2_controller_determine_play_state (Mpris2Controller* self, const char* status);
PlayerController* mpris2_controller_get_owner (Mpris2Controller* self);
GType player_item_get_type (void) G_GNUC_CONST;
GType mpris_bridge_get_type (void) G_GNUC_CONST;
GType player_controller_widget_order_get_type (void) G_GNUC_CONST;
GType transport_menuitem_get_type (void) G_GNUC_CONST;
void transport_menuitem_change_play_state (TransportMenuitem* self, gint state);
GType scrub_menuitem_get_type (void) G_GNUC_CONST;
void scrub_menuitem_update_playstate (ScrubMenuitem* self, gint state);
void scrub_menuitem_update_position (ScrubMenuitem* self, gint32 new_position);
MprisPlayer* mpris2_controller_get_player (Mpris2Controller* self);
void player_item_reset (PlayerItem* self, GeeHashSet* attrs);
GeeHashSet* metadata_menuitem_attributes_format (void);
void player_item_update (PlayerItem* self, GHashTable* data, GeeHashSet* attributes);
GeeHashSet* scrub_menuitem_attributes_format (void);
void mpris2_controller_property_changed_cb (Mpris2Controller* self, const char* interface_source, GHashTable* changed_properties, char** invalid, int invalid_length1);
void mpris2_controller_initial_update (Mpris2Controller* self);
GType transport_menuitem_action_get_type (void) G_GNUC_CONST;
void mpris2_controller_transport_event (Mpris2Controller* self, TransportMenuitemaction command);
void mpris2_controller_set_position (Mpris2Controller* self, double position);
void mpris2_controller_onSeeked (Mpris2Controller* self, gint64 position);
MprisRoot* mpris2_controller_get_mpris2_root (Mpris2Controller* self);
gboolean mpris2_controller_connected (Mpris2Controller* self);
gboolean mpris2_controller_was_successfull (Mpris2Controller* self);
void mpris2_controller_expose (Mpris2Controller* self);
static void mpris2_controller_set_mpris2_root (Mpris2Controller* self, MprisRoot* value);
static void mpris2_controller_set_player (Mpris2Controller* self, MprisPlayer* value);
static void mpris2_controller_set_owner (Mpris2Controller* self, PlayerController* value);
FreeDesktopProperties* mpris2_controller_get_properties_interface (Mpris2Controller* self);
static void mpris2_controller_set_properties_interface (Mpris2Controller* self, FreeDesktopProperties* value);
const char* player_controller_get_name (PlayerController* self);
static void _mpris2_controller_onSeeked_mpris_player_seeked (MprisPlayer* _sender, gint64 new_position, gpointer self);
static void _mpris2_controller_property_changed_cb_free_desktop_properties_properties_changed (FreeDesktopProperties* _sender, const char* source, GHashTable* changed_properties, char** invalid, int invalid_length1, gpointer self);
static GObject * mpris2_controller_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void mpris2_controller_finalize (GObject* obj);
static void mpris2_controller_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void mpris2_controller_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static int _vala_strcmp0 (const char * str1, const char * str2);

static const DBusObjectPathVTable _mpris_root_dbus_path_vtable = {_mpris_root_dbus_unregister, mpris_root_dbus_message};
static const _DBusObjectVTable _mpris_root_dbus_vtable = {mpris_root_dbus_register_object};
static const DBusObjectPathVTable _mpris_player_dbus_path_vtable = {_mpris_player_dbus_unregister, mpris_player_dbus_message};
static const _DBusObjectVTable _mpris_player_dbus_vtable = {mpris_player_dbus_register_object};
static const DBusObjectPathVTable _free_desktop_properties_dbus_path_vtable = {_free_desktop_properties_dbus_unregister, free_desktop_properties_dbus_message};
static const _DBusObjectVTable _free_desktop_properties_dbus_vtable = {free_desktop_properties_dbus_register_object};

static void g_cclosure_user_marshal_VOID__INT64 (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void g_cclosure_user_marshal_VOID__STRING_BOXED_BOXED_INT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);

void mpris_root_Quit (MprisRoot* self, GError** error) {
	MPRIS_ROOT_GET_INTERFACE (self)->Quit (self, error);
}


void mpris_root_Raise (MprisRoot* self, GError** error) {
	MPRIS_ROOT_GET_INTERFACE (self)->Raise (self, error);
}


gboolean mpris_root_get_HasTracklist (MprisRoot* self) {
	return MPRIS_ROOT_GET_INTERFACE (self)->get_HasTracklist (self);
}


void mpris_root_set_HasTracklist (MprisRoot* self, gboolean value) {
	MPRIS_ROOT_GET_INTERFACE (self)->set_HasTracklist (self, value);
}


gboolean mpris_root_get_CanQuit (MprisRoot* self) {
	return MPRIS_ROOT_GET_INTERFACE (self)->get_CanQuit (self);
}


void mpris_root_set_CanQuit (MprisRoot* self, gboolean value) {
	MPRIS_ROOT_GET_INTERFACE (self)->set_CanQuit (self, value);
}


gboolean mpris_root_get_CanRaise (MprisRoot* self) {
	return MPRIS_ROOT_GET_INTERFACE (self)->get_CanRaise (self);
}


void mpris_root_set_CanRaise (MprisRoot* self, gboolean value) {
	MPRIS_ROOT_GET_INTERFACE (self)->set_CanRaise (self, value);
}


char* mpris_root_get_Identity (MprisRoot* self) {
	return MPRIS_ROOT_GET_INTERFACE (self)->get_Identity (self);
}


void mpris_root_set_Identity (MprisRoot* self, const char* value) {
	MPRIS_ROOT_GET_INTERFACE (self)->set_Identity (self, value);
}


char* mpris_root_get_DesktopEntry (MprisRoot* self) {
	return MPRIS_ROOT_GET_INTERFACE (self)->get_DesktopEntry (self);
}


void mpris_root_set_DesktopEntry (MprisRoot* self, const char* value) {
	MPRIS_ROOT_GET_INTERFACE (self)->set_DesktopEntry (self, value);
}


static void _vala_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
	const _DBusObjectVTable * vtable;
	vtable = g_type_get_qdata (G_TYPE_FROM_INSTANCE (object), g_quark_from_static_string ("DBusObjectVTable"));
	if (vtable) {
		vtable->register_object (connection, path, object);
	} else {
		g_warning ("Object does not implement any D-Bus interface");
	}
}


static void _vala_dbus_unregister_object (gpointer connection, GObject* object) {
	char* path;
	path = g_object_steal_data ((GObject*) object, "dbus_object_path");
	dbus_connection_unregister_object_path (connection, path);
	g_free (path);
}


void _mpris_root_dbus_unregister (DBusConnection* connection, void* _user_data_) {
}


static DBusHandlerResult _dbus_mpris_root_introspect (MprisRoot* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter;
	GString* xml_data;
	char** children;
	int i;
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	xml_data = g_string_new ("<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\" \"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n");
	g_string_append (xml_data, "<node>\n<interface name=\"org.freedesktop.DBus.Introspectable\">\n  <method name=\"Introspect\">\n    <arg name=\"data\" direction=\"out\" type=\"s\"/>\n  </method>\n</interface>\n<interface name=\"org.freedesktop.DBus.Properties\">\n  <method name=\"Get\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"out\" type=\"v\"/>\n  </method>\n  <method name=\"Set\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"in\" type=\"v\"/>\n  </method>\n  <method name=\"GetAll\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"props\" direction=\"out\" type=\"a{sv}\"/>\n  </method>\n</interface>\n<interface name=\"org.mpris.MediaPlayer2\">\n  <method name=\"Quit\">\n  </method>\n  <method name=\"Raise\">\n  </method>\n  <property name=\"HasTracklist\" type=\"b\" access=\"readwrite\"/>\n  <property name=\"CanQuit\" type=\"b\" access=\"readwrite\"/>\n  <property name=\"CanRaise\" type=\"b\" access=\"readwrite\"/>\n  <property name=\"Identity\" type=\"s\" access=\"readwrite\"/>\n  <property name=\"DesktopEntry\" type=\"s\" access=\"readwrite\"/>\n</interface>\n");
	dbus_connection_list_registered (connection, g_object_get_data ((GObject *) self, "dbus_object_path"), &children);
	for (i = 0; children[i]; i++) {
		g_string_append_printf (xml_data, "<node name=\"%s\"/>\n", children[i]);
	}
	dbus_free_string_array (children);
	g_string_append (xml_data, "</node>\n");
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &xml_data->str);
	g_string_free (xml_data, TRUE);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_mpris_root_property_get (MprisRoot* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter, reply_iter, subiter;
	char* interface_name;
	const char* _tmp0_;
	char* property_name;
	const char* _tmp1_;
	if (strcmp (dbus_message_get_signature (message), "ss")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &reply_iter);
	dbus_message_iter_get_basic (&iter, &_tmp0_);
	dbus_message_iter_next (&iter);
	interface_name = g_strdup (_tmp0_);
	dbus_message_iter_get_basic (&iter, &_tmp1_);
	dbus_message_iter_next (&iter);
	property_name = g_strdup (_tmp1_);
	if ((strcmp (interface_name, "org.mpris.MediaPlayer2") == 0) && (strcmp (property_name, "HasTracklist") == 0)) {
		gboolean result;
		dbus_bool_t _tmp2_;
		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_VARIANT, "b", &subiter);
		result = mpris_root_get_HasTracklist (self);
		_tmp2_ = result;
		dbus_message_iter_append_basic (&subiter, DBUS_TYPE_BOOLEAN, &_tmp2_);
		dbus_message_iter_close_container (&reply_iter, &subiter);
	} else if ((strcmp (interface_name, "org.mpris.MediaPlayer2") == 0) && (strcmp (property_name, "CanQuit") == 0)) {
		gboolean result;
		dbus_bool_t _tmp3_;
		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_VARIANT, "b", &subiter);
		result = mpris_root_get_CanQuit (self);
		_tmp3_ = result;
		dbus_message_iter_append_basic (&subiter, DBUS_TYPE_BOOLEAN, &_tmp3_);
		dbus_message_iter_close_container (&reply_iter, &subiter);
	} else if ((strcmp (interface_name, "org.mpris.MediaPlayer2") == 0) && (strcmp (property_name, "CanRaise") == 0)) {
		gboolean result;
		dbus_bool_t _tmp4_;
		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_VARIANT, "b", &subiter);
		result = mpris_root_get_CanRaise (self);
		_tmp4_ = result;
		dbus_message_iter_append_basic (&subiter, DBUS_TYPE_BOOLEAN, &_tmp4_);
		dbus_message_iter_close_container (&reply_iter, &subiter);
	} else if ((strcmp (interface_name, "org.mpris.MediaPlayer2") == 0) && (strcmp (property_name, "Identity") == 0)) {
		char* result;
		const char* _tmp5_;
		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_VARIANT, "s", &subiter);
		result = mpris_root_get_Identity (self);
		_tmp5_ = result;
		dbus_message_iter_append_basic (&subiter, DBUS_TYPE_STRING, &_tmp5_);
		_g_free0 (result);
		dbus_message_iter_close_container (&reply_iter, &subiter);
	} else if ((strcmp (interface_name, "org.mpris.MediaPlayer2") == 0) && (strcmp (property_name, "DesktopEntry") == 0)) {
		char* result;
		const char* _tmp6_;
		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_VARIANT, "s", &subiter);
		result = mpris_root_get_DesktopEntry (self);
		_tmp6_ = result;
		dbus_message_iter_append_basic (&subiter, DBUS_TYPE_STRING, &_tmp6_);
		_g_free0 (result);
		dbus_message_iter_close_container (&reply_iter, &subiter);
	} else {
		dbus_message_unref (reply);
		reply = NULL;
	}
	g_free (interface_name);
	g_free (property_name);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_mpris_root_property_set (MprisRoot* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter, subiter;
	char* interface_name;
	const char* _tmp7_;
	char* property_name;
	const char* _tmp8_;
	if (strcmp (dbus_message_get_signature (message), "ssv")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_get_basic (&iter, &_tmp7_);
	dbus_message_iter_next (&iter);
	interface_name = g_strdup (_tmp7_);
	dbus_message_iter_get_basic (&iter, &_tmp8_);
	dbus_message_iter_next (&iter);
	property_name = g_strdup (_tmp8_);
	dbus_message_iter_recurse (&iter, &subiter);
	if ((strcmp (interface_name, "org.mpris.MediaPlayer2") == 0) && (strcmp (property_name, "HasTracklist") == 0)) {
		gboolean value;
		dbus_bool_t _tmp9_;
		dbus_message_iter_get_basic (&subiter, &_tmp9_);
		dbus_message_iter_next (&subiter);
		value = _tmp9_;
		mpris_root_set_HasTracklist (self, value);
	} else if ((strcmp (interface_name, "org.mpris.MediaPlayer2") == 0) && (strcmp (property_name, "CanQuit") == 0)) {
		gboolean value;
		dbus_bool_t _tmp10_;
		dbus_message_iter_get_basic (&subiter, &_tmp10_);
		dbus_message_iter_next (&subiter);
		value = _tmp10_;
		mpris_root_set_CanQuit (self, value);
	} else if ((strcmp (interface_name, "org.mpris.MediaPlayer2") == 0) && (strcmp (property_name, "CanRaise") == 0)) {
		gboolean value;
		dbus_bool_t _tmp11_;
		dbus_message_iter_get_basic (&subiter, &_tmp11_);
		dbus_message_iter_next (&subiter);
		value = _tmp11_;
		mpris_root_set_CanRaise (self, value);
	} else if ((strcmp (interface_name, "org.mpris.MediaPlayer2") == 0) && (strcmp (property_name, "Identity") == 0)) {
		char* value;
		const char* _tmp12_;
		dbus_message_iter_get_basic (&subiter, &_tmp12_);
		dbus_message_iter_next (&subiter);
		value = g_strdup (_tmp12_);
		mpris_root_set_Identity (self, value);
		_g_free0 (value);
	} else if ((strcmp (interface_name, "org.mpris.MediaPlayer2") == 0) && (strcmp (property_name, "DesktopEntry") == 0)) {
		char* value;
		const char* _tmp13_;
		dbus_message_iter_get_basic (&subiter, &_tmp13_);
		dbus_message_iter_next (&subiter);
		value = g_strdup (_tmp13_);
		mpris_root_set_DesktopEntry (self, value);
		_g_free0 (value);
	} else {
		dbus_message_unref (reply);
		reply = NULL;
	}
	g_free (interface_name);
	g_free (property_name);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_mpris_root_property_get_all (MprisRoot* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter, reply_iter, subiter, entry_iter, value_iter;
	char* interface_name;
	const char* _tmp14_;
	const char* property_name;
	if (strcmp (dbus_message_get_signature (message), "s")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &reply_iter);
	dbus_message_iter_get_basic (&iter, &_tmp14_);
	dbus_message_iter_next (&iter);
	interface_name = g_strdup (_tmp14_);
	if (strcmp (interface_name, "org.mpris.MediaPlayer2") == 0) {
		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_ARRAY, "{sv}", &subiter);
		{
			gboolean result;
			dbus_bool_t _tmp15_;
			dbus_message_iter_open_container (&subiter, DBUS_TYPE_DICT_ENTRY, NULL, &entry_iter);
			property_name = "HasTracklist";
			dbus_message_iter_append_basic (&entry_iter, DBUS_TYPE_STRING, &property_name);
			dbus_message_iter_open_container (&entry_iter, DBUS_TYPE_VARIANT, "b", &value_iter);
			result = mpris_root_get_HasTracklist (self);
			_tmp15_ = result;
			dbus_message_iter_append_basic (&value_iter, DBUS_TYPE_BOOLEAN, &_tmp15_);
			dbus_message_iter_close_container (&entry_iter, &value_iter);
			dbus_message_iter_close_container (&subiter, &entry_iter);
		}
		{
			gboolean result;
			dbus_bool_t _tmp16_;
			dbus_message_iter_open_container (&subiter, DBUS_TYPE_DICT_ENTRY, NULL, &entry_iter);
			property_name = "CanQuit";
			dbus_message_iter_append_basic (&entry_iter, DBUS_TYPE_STRING, &property_name);
			dbus_message_iter_open_container (&entry_iter, DBUS_TYPE_VARIANT, "b", &value_iter);
			result = mpris_root_get_CanQuit (self);
			_tmp16_ = result;
			dbus_message_iter_append_basic (&value_iter, DBUS_TYPE_BOOLEAN, &_tmp16_);
			dbus_message_iter_close_container (&entry_iter, &value_iter);
			dbus_message_iter_close_container (&subiter, &entry_iter);
		}
		{
			gboolean result;
			dbus_bool_t _tmp17_;
			dbus_message_iter_open_container (&subiter, DBUS_TYPE_DICT_ENTRY, NULL, &entry_iter);
			property_name = "CanRaise";
			dbus_message_iter_append_basic (&entry_iter, DBUS_TYPE_STRING, &property_name);
			dbus_message_iter_open_container (&entry_iter, DBUS_TYPE_VARIANT, "b", &value_iter);
			result = mpris_root_get_CanRaise (self);
			_tmp17_ = result;
			dbus_message_iter_append_basic (&value_iter, DBUS_TYPE_BOOLEAN, &_tmp17_);
			dbus_message_iter_close_container (&entry_iter, &value_iter);
			dbus_message_iter_close_container (&subiter, &entry_iter);
		}
		{
			char* result;
			const char* _tmp18_;
			dbus_message_iter_open_container (&subiter, DBUS_TYPE_DICT_ENTRY, NULL, &entry_iter);
			property_name = "Identity";
			dbus_message_iter_append_basic (&entry_iter, DBUS_TYPE_STRING, &property_name);
			dbus_message_iter_open_container (&entry_iter, DBUS_TYPE_VARIANT, "s", &value_iter);
			result = mpris_root_get_Identity (self);
			_tmp18_ = result;
			dbus_message_iter_append_basic (&value_iter, DBUS_TYPE_STRING, &_tmp18_);
			_g_free0 (result);
			dbus_message_iter_close_container (&entry_iter, &value_iter);
			dbus_message_iter_close_container (&subiter, &entry_iter);
		}
		{
			char* result;
			const char* _tmp19_;
			dbus_message_iter_open_container (&subiter, DBUS_TYPE_DICT_ENTRY, NULL, &entry_iter);
			property_name = "DesktopEntry";
			dbus_message_iter_append_basic (&entry_iter, DBUS_TYPE_STRING, &property_name);
			dbus_message_iter_open_container (&entry_iter, DBUS_TYPE_VARIANT, "s", &value_iter);
			result = mpris_root_get_DesktopEntry (self);
			_tmp19_ = result;
			dbus_message_iter_append_basic (&value_iter, DBUS_TYPE_STRING, &_tmp19_);
			_g_free0 (result);
			dbus_message_iter_close_container (&entry_iter, &value_iter);
			dbus_message_iter_close_container (&subiter, &entry_iter);
		}
		dbus_message_iter_close_container (&reply_iter, &subiter);
	} else {
		dbus_message_unref (reply);
		reply = NULL;
	}
	g_free (interface_name);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_mpris_root_Quit (MprisRoot* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	DBusMessage* reply;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	mpris_root_Quit (self, &error);
	if (error) {
		if (error->domain == DBUS_GERROR) {
			switch (error->code) {
				case DBUS_GERROR_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Failed", error->message);
				break;
				case DBUS_GERROR_NO_MEMORY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoMemory", error->message);
				break;
				case DBUS_GERROR_SERVICE_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.ServiceUnknown", error->message);
				break;
				case DBUS_GERROR_NAME_HAS_NO_OWNER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NameHasNoOwner", error->message);
				break;
				case DBUS_GERROR_NO_REPLY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoReply", error->message);
				break;
				case DBUS_GERROR_IO_ERROR:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.IOError", error->message);
				break;
				case DBUS_GERROR_BAD_ADDRESS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.BadAddress", error->message);
				break;
				case DBUS_GERROR_NOT_SUPPORTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NotSupported", error->message);
				break;
				case DBUS_GERROR_LIMITS_EXCEEDED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.LimitsExceeded", error->message);
				break;
				case DBUS_GERROR_ACCESS_DENIED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AccessDenied", error->message);
				break;
				case DBUS_GERROR_AUTH_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AuthFailed", error->message);
				break;
				case DBUS_GERROR_NO_SERVER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoServer", error->message);
				break;
				case DBUS_GERROR_TIMEOUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Timeout", error->message);
				break;
				case DBUS_GERROR_NO_NETWORK:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoNetwork", error->message);
				break;
				case DBUS_GERROR_ADDRESS_IN_USE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AddressInUse", error->message);
				break;
				case DBUS_GERROR_DISCONNECTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Disconnected", error->message);
				break;
				case DBUS_GERROR_INVALID_ARGS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidArgs", error->message);
				break;
				case DBUS_GERROR_FILE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileNotFound", error->message);
				break;
				case DBUS_GERROR_FILE_EXISTS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileExists", error->message);
				break;
				case DBUS_GERROR_UNKNOWN_METHOD:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnknownMethod", error->message);
				break;
				case DBUS_GERROR_TIMED_OUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.TimedOut", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleNotFound", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_INVALID:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleInvalid", error->message);
				break;
				case DBUS_GERROR_SPAWN_EXEC_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ExecFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_FORK_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ForkFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_EXITED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildExited", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_SIGNALED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildSignaled", error->message);
				break;
				case DBUS_GERROR_SPAWN_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.Failed", error->message);
				break;
				case DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnixProcessIdUnknown", error->message);
				break;
				case DBUS_GERROR_INVALID_SIGNATURE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidSignature", error->message);
				break;
				case DBUS_GERROR_INVALID_FILE_CONTENT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidFileContent", error->message);
				break;
				case DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.SELinuxSecurityContextUnknown", error->message);
				break;
				case DBUS_GERROR_REMOTE_EXCEPTION:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.RemoteException", error->message);
				break;
			}
		}
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	}
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_mpris_root_Raise (MprisRoot* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	DBusMessage* reply;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	mpris_root_Raise (self, &error);
	if (error) {
		if (error->domain == DBUS_GERROR) {
			switch (error->code) {
				case DBUS_GERROR_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Failed", error->message);
				break;
				case DBUS_GERROR_NO_MEMORY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoMemory", error->message);
				break;
				case DBUS_GERROR_SERVICE_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.ServiceUnknown", error->message);
				break;
				case DBUS_GERROR_NAME_HAS_NO_OWNER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NameHasNoOwner", error->message);
				break;
				case DBUS_GERROR_NO_REPLY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoReply", error->message);
				break;
				case DBUS_GERROR_IO_ERROR:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.IOError", error->message);
				break;
				case DBUS_GERROR_BAD_ADDRESS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.BadAddress", error->message);
				break;
				case DBUS_GERROR_NOT_SUPPORTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NotSupported", error->message);
				break;
				case DBUS_GERROR_LIMITS_EXCEEDED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.LimitsExceeded", error->message);
				break;
				case DBUS_GERROR_ACCESS_DENIED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AccessDenied", error->message);
				break;
				case DBUS_GERROR_AUTH_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AuthFailed", error->message);
				break;
				case DBUS_GERROR_NO_SERVER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoServer", error->message);
				break;
				case DBUS_GERROR_TIMEOUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Timeout", error->message);
				break;
				case DBUS_GERROR_NO_NETWORK:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoNetwork", error->message);
				break;
				case DBUS_GERROR_ADDRESS_IN_USE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AddressInUse", error->message);
				break;
				case DBUS_GERROR_DISCONNECTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Disconnected", error->message);
				break;
				case DBUS_GERROR_INVALID_ARGS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidArgs", error->message);
				break;
				case DBUS_GERROR_FILE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileNotFound", error->message);
				break;
				case DBUS_GERROR_FILE_EXISTS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileExists", error->message);
				break;
				case DBUS_GERROR_UNKNOWN_METHOD:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnknownMethod", error->message);
				break;
				case DBUS_GERROR_TIMED_OUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.TimedOut", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleNotFound", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_INVALID:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleInvalid", error->message);
				break;
				case DBUS_GERROR_SPAWN_EXEC_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ExecFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_FORK_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ForkFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_EXITED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildExited", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_SIGNALED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildSignaled", error->message);
				break;
				case DBUS_GERROR_SPAWN_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.Failed", error->message);
				break;
				case DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnixProcessIdUnknown", error->message);
				break;
				case DBUS_GERROR_INVALID_SIGNATURE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidSignature", error->message);
				break;
				case DBUS_GERROR_INVALID_FILE_CONTENT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidFileContent", error->message);
				break;
				case DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.SELinuxSecurityContextUnknown", error->message);
				break;
				case DBUS_GERROR_REMOTE_EXCEPTION:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.RemoteException", error->message);
				break;
			}
		}
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	}
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


DBusHandlerResult mpris_root_dbus_message (DBusConnection* connection, DBusMessage* message, void* object) {
	DBusHandlerResult result;
	result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Introspectable", "Introspect")) {
		result = _dbus_mpris_root_introspect (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Properties", "Get")) {
		result = _dbus_mpris_root_property_get (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Properties", "Set")) {
		result = _dbus_mpris_root_property_set (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Properties", "GetAll")) {
		result = _dbus_mpris_root_property_get_all (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.mpris.MediaPlayer2", "Quit")) {
		result = _dbus_mpris_root_Quit (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.mpris.MediaPlayer2", "Raise")) {
		result = _dbus_mpris_root_Raise (object, connection, message);
	}
	if (result == DBUS_HANDLER_RESULT_HANDLED) {
		return result;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


void mpris_root_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
	if (!g_object_get_data (object, "dbus_object_path")) {
		g_object_set_data (object, "dbus_object_path", g_strdup (path));
		dbus_connection_register_object_path (connection, path, &_mpris_root_dbus_path_vtable, object);
		g_object_weak_ref (object, _vala_dbus_unregister_object, connection);
	}
}


static void mpris_root_base_init (MprisRootIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
		g_object_interface_install_property (iface, g_param_spec_boolean ("HasTracklist", "HasTracklist", "HasTracklist", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
		g_object_interface_install_property (iface, g_param_spec_boolean ("CanQuit", "CanQuit", "CanQuit", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
		g_object_interface_install_property (iface, g_param_spec_boolean ("CanRaise", "CanRaise", "CanRaise", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
		g_object_interface_install_property (iface, g_param_spec_string ("Identity", "Identity", "Identity", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
		g_object_interface_install_property (iface, g_param_spec_string ("DesktopEntry", "DesktopEntry", "DesktopEntry", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
		g_type_set_qdata (TYPE_MPRIS_ROOT, g_quark_from_static_string ("DBusObjectVTable"), (void*) (&_mpris_root_dbus_vtable));
	}
}


GType mpris_root_get_type (void) {
	static volatile gsize mpris_root_type_id__volatile = 0;
	if (g_once_init_enter (&mpris_root_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (MprisRootIface), (GBaseInitFunc) mpris_root_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType mpris_root_type_id;
		mpris_root_type_id = g_type_register_static (G_TYPE_INTERFACE, "MprisRoot", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (mpris_root_type_id, DBUS_TYPE_G_PROXY);
		g_type_set_qdata (mpris_root_type_id, g_quark_from_string ("ValaDBusInterfaceProxyType"), &mpris_root_dbus_proxy_get_type);
		g_once_init_leave (&mpris_root_type_id__volatile, mpris_root_type_id);
	}
	return mpris_root_type_id__volatile;
}


G_DEFINE_TYPE_EXTENDED (MprisRootDBusProxy, mpris_root_dbus_proxy, DBUS_TYPE_G_PROXY, 0, G_IMPLEMENT_INTERFACE (TYPE_MPRIS_ROOT, mpris_root_dbus_proxy_mpris_root__interface_init) );
MprisRoot* mpris_root_dbus_proxy_new (DBusGConnection* connection, const char* name, const char* path) {
	MprisRoot* self;
	self = g_object_new (mpris_root_dbus_proxy_get_type (), "connection", connection, "name", name, "path", path, "interface", "org.mpris.MediaPlayer2", NULL);
	return self;
}


static GObject* mpris_root_dbus_proxy_construct (GType gtype, guint n_properties, GObjectConstructParam* properties) {
	GObject* self;
	DBusGConnection *connection;
	char* path;
	char* filter;
	self = G_OBJECT_CLASS (mpris_root_dbus_proxy_parent_class)->constructor (gtype, n_properties, properties);
	g_object_get (self, "connection", &connection, NULL);
	g_object_get (self, "path", &path, NULL);
	dbus_connection_add_filter (dbus_g_connection_get_connection (connection), mpris_root_dbus_proxy_filter, self, NULL);
	filter = g_strdup_printf ("type='signal',path='%s'", path);
	dbus_bus_add_match (dbus_g_connection_get_connection (connection), filter, NULL);
	dbus_g_connection_unref (connection);
	g_free (path);
	g_free (filter);
	return self;
}


DBusHandlerResult mpris_root_dbus_proxy_filter (DBusConnection* connection, DBusMessage* message, void* user_data) {
	if (dbus_message_has_path (message, dbus_g_proxy_get_path (user_data))) {
	}
	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
}


static void mpris_root_dbus_proxy_dispose (GObject* self) {
	DBusGConnection *connection;
	if (((MprisRootDBusProxy*) self)->disposed) {
		return;
	}
	((MprisRootDBusProxy*) self)->disposed = TRUE;
	g_object_get (self, "connection", &connection, NULL);
	dbus_connection_remove_filter (dbus_g_connection_get_connection (connection), mpris_root_dbus_proxy_filter, self);
	G_OBJECT_CLASS (mpris_root_dbus_proxy_parent_class)->dispose (self);
}


static void mpris_root_dbus_proxy_class_init (MprisRootDBusProxyClass* klass) {
	G_OBJECT_CLASS (klass)->constructor = mpris_root_dbus_proxy_construct;
	G_OBJECT_CLASS (klass)->dispose = mpris_root_dbus_proxy_dispose;
	G_OBJECT_CLASS (klass)->get_property = mpris_root_dbus_proxy_get_property;
	G_OBJECT_CLASS (klass)->set_property = mpris_root_dbus_proxy_set_property;
	g_object_class_override_property (G_OBJECT_CLASS (klass), MPRIS_ROOT_DBUS_PROXY_HAS_TRACKLIST, "HasTracklist");
	g_object_class_override_property (G_OBJECT_CLASS (klass), MPRIS_ROOT_DBUS_PROXY_CAN_QUIT, "CanQuit");
	g_object_class_override_property (G_OBJECT_CLASS (klass), MPRIS_ROOT_DBUS_PROXY_CAN_RAISE, "CanRaise");
	g_object_class_override_property (G_OBJECT_CLASS (klass), MPRIS_ROOT_DBUS_PROXY_IDENTITY, "Identity");
	g_object_class_override_property (G_OBJECT_CLASS (klass), MPRIS_ROOT_DBUS_PROXY_DESKTOP_ENTRY, "DesktopEntry");
}


static void mpris_root_dbus_proxy_init (MprisRootDBusProxy* self) {
}


static void mpris_root_dbus_proxy_Quit (MprisRoot* self, GError** error) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter;
	if (((MprisRootDBusProxy*) self)->disposed) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
		return;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.mpris.MediaPlayer2", "Quit");
	dbus_message_iter_init_append (_message, &_iter);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		GQuark _edomain;
		gint _ecode;
		if (strstr (_dbus_error.name, "org.freedesktop.DBus.Error") == _dbus_error.name) {
			const char* _tmp20_;
			_edomain = DBUS_GERROR;
			_tmp20_ = _dbus_error.name + 27;
			if (strcmp (_tmp20_, "Failed") == 0) {
				_ecode = DBUS_GERROR_FAILED;
			} else if (strcmp (_tmp20_, "NoMemory") == 0) {
				_ecode = DBUS_GERROR_NO_MEMORY;
			} else if (strcmp (_tmp20_, "ServiceUnknown") == 0) {
				_ecode = DBUS_GERROR_SERVICE_UNKNOWN;
			} else if (strcmp (_tmp20_, "NameHasNoOwner") == 0) {
				_ecode = DBUS_GERROR_NAME_HAS_NO_OWNER;
			} else if (strcmp (_tmp20_, "NoReply") == 0) {
				_ecode = DBUS_GERROR_NO_REPLY;
			} else if (strcmp (_tmp20_, "IOError") == 0) {
				_ecode = DBUS_GERROR_IO_ERROR;
			} else if (strcmp (_tmp20_, "BadAddress") == 0) {
				_ecode = DBUS_GERROR_BAD_ADDRESS;
			} else if (strcmp (_tmp20_, "NotSupported") == 0) {
				_ecode = DBUS_GERROR_NOT_SUPPORTED;
			} else if (strcmp (_tmp20_, "LimitsExceeded") == 0) {
				_ecode = DBUS_GERROR_LIMITS_EXCEEDED;
			} else if (strcmp (_tmp20_, "AccessDenied") == 0) {
				_ecode = DBUS_GERROR_ACCESS_DENIED;
			} else if (strcmp (_tmp20_, "AuthFailed") == 0) {
				_ecode = DBUS_GERROR_AUTH_FAILED;
			} else if (strcmp (_tmp20_, "NoServer") == 0) {
				_ecode = DBUS_GERROR_NO_SERVER;
			} else if (strcmp (_tmp20_, "Timeout") == 0) {
				_ecode = DBUS_GERROR_TIMEOUT;
			} else if (strcmp (_tmp20_, "NoNetwork") == 0) {
				_ecode = DBUS_GERROR_NO_NETWORK;
			} else if (strcmp (_tmp20_, "AddressInUse") == 0) {
				_ecode = DBUS_GERROR_ADDRESS_IN_USE;
			} else if (strcmp (_tmp20_, "Disconnected") == 0) {
				_ecode = DBUS_GERROR_DISCONNECTED;
			} else if (strcmp (_tmp20_, "InvalidArgs") == 0) {
				_ecode = DBUS_GERROR_INVALID_ARGS;
			} else if (strcmp (_tmp20_, "FileNotFound") == 0) {
				_ecode = DBUS_GERROR_FILE_NOT_FOUND;
			} else if (strcmp (_tmp20_, "FileExists") == 0) {
				_ecode = DBUS_GERROR_FILE_EXISTS;
			} else if (strcmp (_tmp20_, "UnknownMethod") == 0) {
				_ecode = DBUS_GERROR_UNKNOWN_METHOD;
			} else if (strcmp (_tmp20_, "TimedOut") == 0) {
				_ecode = DBUS_GERROR_TIMED_OUT;
			} else if (strcmp (_tmp20_, "MatchRuleNotFound") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_NOT_FOUND;
			} else if (strcmp (_tmp20_, "MatchRuleInvalid") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_INVALID;
			} else if (strcmp (_tmp20_, "Spawn.ExecFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_EXEC_FAILED;
			} else if (strcmp (_tmp20_, "Spawn.ForkFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FORK_FAILED;
			} else if (strcmp (_tmp20_, "Spawn.ChildExited") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_EXITED;
			} else if (strcmp (_tmp20_, "Spawn.ChildSignaled") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_SIGNALED;
			} else if (strcmp (_tmp20_, "Spawn.Failed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FAILED;
			} else if (strcmp (_tmp20_, "UnixProcessIdUnknown") == 0) {
				_ecode = DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN;
			} else if (strcmp (_tmp20_, "InvalidSignature") == 0) {
				_ecode = DBUS_GERROR_INVALID_SIGNATURE;
			} else if (strcmp (_tmp20_, "InvalidFileContent") == 0) {
				_ecode = DBUS_GERROR_INVALID_FILE_CONTENT;
			} else if (strcmp (_tmp20_, "SELinuxSecurityContextUnknown") == 0) {
				_ecode = DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN;
			} else if (strcmp (_tmp20_, "RemoteException") == 0) {
				_ecode = DBUS_GERROR_REMOTE_EXCEPTION;
			}
		}
		g_set_error (error, _edomain, _ecode, "%s", _dbus_error.message);
		dbus_error_free (&_dbus_error);
		return;
	}
	if (strcmp (dbus_message_get_signature (_reply), "")) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_unref (_reply);
}


static void mpris_root_dbus_proxy_Raise (MprisRoot* self, GError** error) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter;
	if (((MprisRootDBusProxy*) self)->disposed) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
		return;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.mpris.MediaPlayer2", "Raise");
	dbus_message_iter_init_append (_message, &_iter);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		GQuark _edomain;
		gint _ecode;
		if (strstr (_dbus_error.name, "org.freedesktop.DBus.Error") == _dbus_error.name) {
			const char* _tmp21_;
			_edomain = DBUS_GERROR;
			_tmp21_ = _dbus_error.name + 27;
			if (strcmp (_tmp21_, "Failed") == 0) {
				_ecode = DBUS_GERROR_FAILED;
			} else if (strcmp (_tmp21_, "NoMemory") == 0) {
				_ecode = DBUS_GERROR_NO_MEMORY;
			} else if (strcmp (_tmp21_, "ServiceUnknown") == 0) {
				_ecode = DBUS_GERROR_SERVICE_UNKNOWN;
			} else if (strcmp (_tmp21_, "NameHasNoOwner") == 0) {
				_ecode = DBUS_GERROR_NAME_HAS_NO_OWNER;
			} else if (strcmp (_tmp21_, "NoReply") == 0) {
				_ecode = DBUS_GERROR_NO_REPLY;
			} else if (strcmp (_tmp21_, "IOError") == 0) {
				_ecode = DBUS_GERROR_IO_ERROR;
			} else if (strcmp (_tmp21_, "BadAddress") == 0) {
				_ecode = DBUS_GERROR_BAD_ADDRESS;
			} else if (strcmp (_tmp21_, "NotSupported") == 0) {
				_ecode = DBUS_GERROR_NOT_SUPPORTED;
			} else if (strcmp (_tmp21_, "LimitsExceeded") == 0) {
				_ecode = DBUS_GERROR_LIMITS_EXCEEDED;
			} else if (strcmp (_tmp21_, "AccessDenied") == 0) {
				_ecode = DBUS_GERROR_ACCESS_DENIED;
			} else if (strcmp (_tmp21_, "AuthFailed") == 0) {
				_ecode = DBUS_GERROR_AUTH_FAILED;
			} else if (strcmp (_tmp21_, "NoServer") == 0) {
				_ecode = DBUS_GERROR_NO_SERVER;
			} else if (strcmp (_tmp21_, "Timeout") == 0) {
				_ecode = DBUS_GERROR_TIMEOUT;
			} else if (strcmp (_tmp21_, "NoNetwork") == 0) {
				_ecode = DBUS_GERROR_NO_NETWORK;
			} else if (strcmp (_tmp21_, "AddressInUse") == 0) {
				_ecode = DBUS_GERROR_ADDRESS_IN_USE;
			} else if (strcmp (_tmp21_, "Disconnected") == 0) {
				_ecode = DBUS_GERROR_DISCONNECTED;
			} else if (strcmp (_tmp21_, "InvalidArgs") == 0) {
				_ecode = DBUS_GERROR_INVALID_ARGS;
			} else if (strcmp (_tmp21_, "FileNotFound") == 0) {
				_ecode = DBUS_GERROR_FILE_NOT_FOUND;
			} else if (strcmp (_tmp21_, "FileExists") == 0) {
				_ecode = DBUS_GERROR_FILE_EXISTS;
			} else if (strcmp (_tmp21_, "UnknownMethod") == 0) {
				_ecode = DBUS_GERROR_UNKNOWN_METHOD;
			} else if (strcmp (_tmp21_, "TimedOut") == 0) {
				_ecode = DBUS_GERROR_TIMED_OUT;
			} else if (strcmp (_tmp21_, "MatchRuleNotFound") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_NOT_FOUND;
			} else if (strcmp (_tmp21_, "MatchRuleInvalid") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_INVALID;
			} else if (strcmp (_tmp21_, "Spawn.ExecFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_EXEC_FAILED;
			} else if (strcmp (_tmp21_, "Spawn.ForkFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FORK_FAILED;
			} else if (strcmp (_tmp21_, "Spawn.ChildExited") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_EXITED;
			} else if (strcmp (_tmp21_, "Spawn.ChildSignaled") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_SIGNALED;
			} else if (strcmp (_tmp21_, "Spawn.Failed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FAILED;
			} else if (strcmp (_tmp21_, "UnixProcessIdUnknown") == 0) {
				_ecode = DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN;
			} else if (strcmp (_tmp21_, "InvalidSignature") == 0) {
				_ecode = DBUS_GERROR_INVALID_SIGNATURE;
			} else if (strcmp (_tmp21_, "InvalidFileContent") == 0) {
				_ecode = DBUS_GERROR_INVALID_FILE_CONTENT;
			} else if (strcmp (_tmp21_, "SELinuxSecurityContextUnknown") == 0) {
				_ecode = DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN;
			} else if (strcmp (_tmp21_, "RemoteException") == 0) {
				_ecode = DBUS_GERROR_REMOTE_EXCEPTION;
			}
		}
		g_set_error (error, _edomain, _ecode, "%s", _dbus_error.message);
		dbus_error_free (&_dbus_error);
		return;
	}
	if (strcmp (dbus_message_get_signature (_reply), "")) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_unref (_reply);
}


static gboolean mpris_root_dbus_proxy_get_HasTracklist (MprisRoot* self) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp22_;
	const char* _tmp23_;
	gboolean _result;
	dbus_bool_t _tmp24_;
	if (((MprisRootDBusProxy*) self)->disposed) {
		return FALSE;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Get");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp22_ = "org.mpris.MediaPlayer2";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp22_);
	_tmp23_ = "HasTracklist";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp23_);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s)", __FILE__, __LINE__, _dbus_error.message, _dbus_error.name);
		dbus_error_free (&_dbus_error);
		return FALSE;
	}
	if (strcmp (dbus_message_get_signature (_reply), "v")) {
		g_critical ("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "v", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return FALSE;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_iter_recurse (&_iter, &_subiter);
	if (strcmp (dbus_message_iter_get_signature (&_subiter), "b")) {
		g_critical ("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "b", dbus_message_iter_get_signature (&_subiter));
		dbus_message_unref (_reply);
		return FALSE;
	}
	dbus_message_iter_get_basic (&_subiter, &_tmp24_);
	dbus_message_iter_next (&_subiter);
	_result = _tmp24_;
	dbus_message_unref (_reply);
	return _result;
}


static void mpris_root_dbus_proxy_set_HasTracklist (MprisRoot* self, gboolean value) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp25_;
	const char* _tmp26_;
	dbus_bool_t _tmp27_;
	if (((MprisRootDBusProxy*) self)->disposed) {
		return;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Set");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp25_ = "org.mpris.MediaPlayer2";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp25_);
	_tmp26_ = "HasTracklist";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp26_);
	dbus_message_iter_open_container (&_iter, DBUS_TYPE_VARIANT, "b", &_subiter);
	_tmp27_ = value;
	dbus_message_iter_append_basic (&_subiter, DBUS_TYPE_BOOLEAN, &_tmp27_);
	dbus_message_iter_close_container (&_iter, &_subiter);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s)", __FILE__, __LINE__, _dbus_error.message, _dbus_error.name);
		dbus_error_free (&_dbus_error);
		return;
	}
	if (strcmp (dbus_message_get_signature (_reply), "")) {
		g_critical ("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_unref (_reply);
}


static gboolean mpris_root_dbus_proxy_get_CanQuit (MprisRoot* self) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp28_;
	const char* _tmp29_;
	gboolean _result;
	dbus_bool_t _tmp30_;
	if (((MprisRootDBusProxy*) self)->disposed) {
		return FALSE;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Get");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp28_ = "org.mpris.MediaPlayer2";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp28_);
	_tmp29_ = "CanQuit";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp29_);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s)", __FILE__, __LINE__, _dbus_error.message, _dbus_error.name);
		dbus_error_free (&_dbus_error);
		return FALSE;
	}
	if (strcmp (dbus_message_get_signature (_reply), "v")) {
		g_critical ("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "v", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return FALSE;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_iter_recurse (&_iter, &_subiter);
	if (strcmp (dbus_message_iter_get_signature (&_subiter), "b")) {
		g_critical ("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "b", dbus_message_iter_get_signature (&_subiter));
		dbus_message_unref (_reply);
		return FALSE;
	}
	dbus_message_iter_get_basic (&_subiter, &_tmp30_);
	dbus_message_iter_next (&_subiter);
	_result = _tmp30_;
	dbus_message_unref (_reply);
	return _result;
}


static void mpris_root_dbus_proxy_set_CanQuit (MprisRoot* self, gboolean value) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp31_;
	const char* _tmp32_;
	dbus_bool_t _tmp33_;
	if (((MprisRootDBusProxy*) self)->disposed) {
		return;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Set");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp31_ = "org.mpris.MediaPlayer2";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp31_);
	_tmp32_ = "CanQuit";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp32_);
	dbus_message_iter_open_container (&_iter, DBUS_TYPE_VARIANT, "b", &_subiter);
	_tmp33_ = value;
	dbus_message_iter_append_basic (&_subiter, DBUS_TYPE_BOOLEAN, &_tmp33_);
	dbus_message_iter_close_container (&_iter, &_subiter);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s)", __FILE__, __LINE__, _dbus_error.message, _dbus_error.name);
		dbus_error_free (&_dbus_error);
		return;
	}
	if (strcmp (dbus_message_get_signature (_reply), "")) {
		g_critical ("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_unref (_reply);
}


static gboolean mpris_root_dbus_proxy_get_CanRaise (MprisRoot* self) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp34_;
	const char* _tmp35_;
	gboolean _result;
	dbus_bool_t _tmp36_;
	if (((MprisRootDBusProxy*) self)->disposed) {
		return FALSE;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Get");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp34_ = "org.mpris.MediaPlayer2";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp34_);
	_tmp35_ = "CanRaise";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp35_);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s)", __FILE__, __LINE__, _dbus_error.message, _dbus_error.name);
		dbus_error_free (&_dbus_error);
		return FALSE;
	}
	if (strcmp (dbus_message_get_signature (_reply), "v")) {
		g_critical ("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "v", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return FALSE;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_iter_recurse (&_iter, &_subiter);
	if (strcmp (dbus_message_iter_get_signature (&_subiter), "b")) {
		g_critical ("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "b", dbus_message_iter_get_signature (&_subiter));
		dbus_message_unref (_reply);
		return FALSE;
	}
	dbus_message_iter_get_basic (&_subiter, &_tmp36_);
	dbus_message_iter_next (&_subiter);
	_result = _tmp36_;
	dbus_message_unref (_reply);
	return _result;
}


static void mpris_root_dbus_proxy_set_CanRaise (MprisRoot* self, gboolean value) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp37_;
	const char* _tmp38_;
	dbus_bool_t _tmp39_;
	if (((MprisRootDBusProxy*) self)->disposed) {
		return;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Set");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp37_ = "org.mpris.MediaPlayer2";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp37_);
	_tmp38_ = "CanRaise";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp38_);
	dbus_message_iter_open_container (&_iter, DBUS_TYPE_VARIANT, "b", &_subiter);
	_tmp39_ = value;
	dbus_message_iter_append_basic (&_subiter, DBUS_TYPE_BOOLEAN, &_tmp39_);
	dbus_message_iter_close_container (&_iter, &_subiter);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s)", __FILE__, __LINE__, _dbus_error.message, _dbus_error.name);
		dbus_error_free (&_dbus_error);
		return;
	}
	if (strcmp (dbus_message_get_signature (_reply), "")) {
		g_critical ("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_unref (_reply);
}


static char* mpris_root_dbus_proxy_get_Identity (MprisRoot* self) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp40_;
	const char* _tmp41_;
	char* _result;
	const char* _tmp42_;
	if (((MprisRootDBusProxy*) self)->disposed) {
		return NULL;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Get");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp40_ = "org.mpris.MediaPlayer2";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp40_);
	_tmp41_ = "Identity";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp41_);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s)", __FILE__, __LINE__, _dbus_error.message, _dbus_error.name);
		dbus_error_free (&_dbus_error);
		return NULL;
	}
	if (strcmp (dbus_message_get_signature (_reply), "v")) {
		g_critical ("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "v", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return NULL;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_iter_recurse (&_iter, &_subiter);
	if (strcmp (dbus_message_iter_get_signature (&_subiter), "s")) {
		g_critical ("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "s", dbus_message_iter_get_signature (&_subiter));
		dbus_message_unref (_reply);
		return NULL;
	}
	dbus_message_iter_get_basic (&_subiter, &_tmp42_);
	dbus_message_iter_next (&_subiter);
	_result = g_strdup (_tmp42_);
	dbus_message_unref (_reply);
	return _result;
}


static void mpris_root_dbus_proxy_set_Identity (MprisRoot* self, const char* value) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp43_;
	const char* _tmp44_;
	const char* _tmp45_;
	if (((MprisRootDBusProxy*) self)->disposed) {
		return;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Set");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp43_ = "org.mpris.MediaPlayer2";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp43_);
	_tmp44_ = "Identity";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp44_);
	dbus_message_iter_open_container (&_iter, DBUS_TYPE_VARIANT, "s", &_subiter);
	_tmp45_ = value;
	dbus_message_iter_append_basic (&_subiter, DBUS_TYPE_STRING, &_tmp45_);
	dbus_message_iter_close_container (&_iter, &_subiter);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s)", __FILE__, __LINE__, _dbus_error.message, _dbus_error.name);
		dbus_error_free (&_dbus_error);
		return;
	}
	if (strcmp (dbus_message_get_signature (_reply), "")) {
		g_critical ("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_unref (_reply);
}


static char* mpris_root_dbus_proxy_get_DesktopEntry (MprisRoot* self) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp46_;
	const char* _tmp47_;
	char* _result;
	const char* _tmp48_;
	if (((MprisRootDBusProxy*) self)->disposed) {
		return NULL;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Get");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp46_ = "org.mpris.MediaPlayer2";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp46_);
	_tmp47_ = "DesktopEntry";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp47_);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s)", __FILE__, __LINE__, _dbus_error.message, _dbus_error.name);
		dbus_error_free (&_dbus_error);
		return NULL;
	}
	if (strcmp (dbus_message_get_signature (_reply), "v")) {
		g_critical ("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "v", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return NULL;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_iter_recurse (&_iter, &_subiter);
	if (strcmp (dbus_message_iter_get_signature (&_subiter), "s")) {
		g_critical ("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "s", dbus_message_iter_get_signature (&_subiter));
		dbus_message_unref (_reply);
		return NULL;
	}
	dbus_message_iter_get_basic (&_subiter, &_tmp48_);
	dbus_message_iter_next (&_subiter);
	_result = g_strdup (_tmp48_);
	dbus_message_unref (_reply);
	return _result;
}


static void mpris_root_dbus_proxy_set_DesktopEntry (MprisRoot* self, const char* value) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp49_;
	const char* _tmp50_;
	const char* _tmp51_;
	if (((MprisRootDBusProxy*) self)->disposed) {
		return;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Set");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp49_ = "org.mpris.MediaPlayer2";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp49_);
	_tmp50_ = "DesktopEntry";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp50_);
	dbus_message_iter_open_container (&_iter, DBUS_TYPE_VARIANT, "s", &_subiter);
	_tmp51_ = value;
	dbus_message_iter_append_basic (&_subiter, DBUS_TYPE_STRING, &_tmp51_);
	dbus_message_iter_close_container (&_iter, &_subiter);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s)", __FILE__, __LINE__, _dbus_error.message, _dbus_error.name);
		dbus_error_free (&_dbus_error);
		return;
	}
	if (strcmp (dbus_message_get_signature (_reply), "")) {
		g_critical ("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_unref (_reply);
}


static void mpris_root_dbus_proxy_mpris_root__interface_init (MprisRootIface* iface) {
	iface->Quit = mpris_root_dbus_proxy_Quit;
	iface->Raise = mpris_root_dbus_proxy_Raise;
	iface->get_HasTracklist = mpris_root_dbus_proxy_get_HasTracklist;
	iface->set_HasTracklist = mpris_root_dbus_proxy_set_HasTracklist;
	iface->get_CanQuit = mpris_root_dbus_proxy_get_CanQuit;
	iface->set_CanQuit = mpris_root_dbus_proxy_set_CanQuit;
	iface->get_CanRaise = mpris_root_dbus_proxy_get_CanRaise;
	iface->set_CanRaise = mpris_root_dbus_proxy_set_CanRaise;
	iface->get_Identity = mpris_root_dbus_proxy_get_Identity;
	iface->set_Identity = mpris_root_dbus_proxy_set_Identity;
	iface->get_DesktopEntry = mpris_root_dbus_proxy_get_DesktopEntry;
	iface->set_DesktopEntry = mpris_root_dbus_proxy_set_DesktopEntry;
}


static void mpris_root_dbus_proxy_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
}


static void mpris_root_dbus_proxy_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
}


void mpris_player_SetPosition (MprisPlayer* self, const char* path, gint64 pos, GError** error) {
	MPRIS_PLAYER_GET_INTERFACE (self)->SetPosition (self, path, pos, error);
}


void mpris_player_PlayPause (MprisPlayer* self, GError** error) {
	MPRIS_PLAYER_GET_INTERFACE (self)->PlayPause (self, error);
}


void mpris_player_Pause (MprisPlayer* self, GError** error) {
	MPRIS_PLAYER_GET_INTERFACE (self)->Pause (self, error);
}


void mpris_player_Next (MprisPlayer* self, GError** error) {
	MPRIS_PLAYER_GET_INTERFACE (self)->Next (self, error);
}


void mpris_player_Previous (MprisPlayer* self, GError** error) {
	MPRIS_PLAYER_GET_INTERFACE (self)->Previous (self, error);
}


GHashTable* mpris_player_get_Metadata (MprisPlayer* self) {
	return MPRIS_PLAYER_GET_INTERFACE (self)->get_Metadata (self);
}


void mpris_player_set_Metadata (MprisPlayer* self, GHashTable* value) {
	MPRIS_PLAYER_GET_INTERFACE (self)->set_Metadata (self, value);
}


gint32 mpris_player_get_Position (MprisPlayer* self) {
	return MPRIS_PLAYER_GET_INTERFACE (self)->get_Position (self);
}


void mpris_player_set_Position (MprisPlayer* self, gint32 value) {
	MPRIS_PLAYER_GET_INTERFACE (self)->set_Position (self, value);
}


char* mpris_player_get_PlaybackStatus (MprisPlayer* self) {
	return MPRIS_PLAYER_GET_INTERFACE (self)->get_PlaybackStatus (self);
}


void mpris_player_set_PlaybackStatus (MprisPlayer* self, const char* value) {
	MPRIS_PLAYER_GET_INTERFACE (self)->set_PlaybackStatus (self, value);
}


void _mpris_player_dbus_unregister (DBusConnection* connection, void* _user_data_) {
}


static DBusHandlerResult _dbus_mpris_player_introspect (MprisPlayer* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter;
	GString* xml_data;
	char** children;
	int i;
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	xml_data = g_string_new ("<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\" \"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n");
	g_string_append (xml_data, "<node>\n<interface name=\"org.freedesktop.DBus.Introspectable\">\n  <method name=\"Introspect\">\n    <arg name=\"data\" direction=\"out\" type=\"s\"/>\n  </method>\n</interface>\n<interface name=\"org.freedesktop.DBus.Properties\">\n  <method name=\"Get\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"out\" type=\"v\"/>\n  </method>\n  <method name=\"Set\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"in\" type=\"v\"/>\n  </method>\n  <method name=\"GetAll\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"props\" direction=\"out\" type=\"a{sv}\"/>\n  </method>\n</interface>\n<interface name=\"org.mpris.MediaPlayer2.Player\">\n  <method name=\"SetPosition\">\n    <arg name=\"path\" type=\"o\" direction=\"in\"/>\n    <arg name=\"pos\" type=\"x\" direction=\"in\"/>\n  </method>\n  <method name=\"PlayPause\">\n  </method>\n  <method name=\"Pause\">\n  </method>\n  <method name=\"Next\">\n  </method>\n  <method name=\"Previous\">\n  </method>\n  <property name=\"Metadata\" type=\"a{sv}\" access=\"readwrite\"/>\n  <property name=\"Position\" type=\"i\" access=\"readwrite\"/>\n  <property name=\"PlaybackStatus\" type=\"s\" access=\"readwrite\"/>\n  <signal name=\"Seeked\">\n    <arg name=\"new_position\" type=\"x\"/>\n  </signal>\n</interface>\n");
	dbus_connection_list_registered (connection, g_object_get_data ((GObject *) self, "dbus_object_path"), &children);
	for (i = 0; children[i]; i++) {
		g_string_append_printf (xml_data, "<node name=\"%s\"/>\n", children[i]);
	}
	dbus_free_string_array (children);
	g_string_append (xml_data, "</node>\n");
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &xml_data->str);
	g_string_free (xml_data, TRUE);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_mpris_player_property_get (MprisPlayer* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter, reply_iter, subiter;
	char* interface_name;
	const char* _tmp52_;
	char* property_name;
	const char* _tmp53_;
	if (strcmp (dbus_message_get_signature (message), "ss")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &reply_iter);
	dbus_message_iter_get_basic (&iter, &_tmp52_);
	dbus_message_iter_next (&iter);
	interface_name = g_strdup (_tmp52_);
	dbus_message_iter_get_basic (&iter, &_tmp53_);
	dbus_message_iter_next (&iter);
	property_name = g_strdup (_tmp53_);
	if ((strcmp (interface_name, "org.mpris.MediaPlayer2.Player") == 0) && (strcmp (property_name, "Metadata") == 0)) {
		GHashTable* result;
		DBusMessageIter _tmp54_, _tmp55_;
		GHashTableIter _tmp56_;
		gpointer _tmp57_, _tmp58_;
		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_VARIANT, "a{sv}", &subiter);
		result = mpris_player_get_Metadata (self);
		dbus_message_iter_open_container (&subiter, DBUS_TYPE_ARRAY, "{sv}", &_tmp54_);
		g_hash_table_iter_init (&_tmp56_, result);
		while (g_hash_table_iter_next (&_tmp56_, &_tmp57_, &_tmp58_)) {
			char* _key;
			GValue* _value;
			const char* _tmp59_;
			DBusMessageIter _tmp60_;
			dbus_message_iter_open_container (&_tmp54_, DBUS_TYPE_DICT_ENTRY, NULL, &_tmp55_);
			_key = (char*) _tmp57_;
			_value = (GValue*) _tmp58_;
			_tmp59_ = _key;
			dbus_message_iter_append_basic (&_tmp55_, DBUS_TYPE_STRING, &_tmp59_);
			if (G_VALUE_TYPE (_value) == G_TYPE_UCHAR) {
				guint8 _tmp61_;
				dbus_message_iter_open_container (&_tmp55_, DBUS_TYPE_VARIANT, "y", &_tmp60_);
				_tmp61_ = g_value_get_uchar (_value);
				dbus_message_iter_append_basic (&_tmp60_, DBUS_TYPE_BYTE, &_tmp61_);
				dbus_message_iter_close_container (&_tmp55_, &_tmp60_);
			} else if (G_VALUE_TYPE (_value) == G_TYPE_BOOLEAN) {
				dbus_bool_t _tmp62_;
				dbus_message_iter_open_container (&_tmp55_, DBUS_TYPE_VARIANT, "b", &_tmp60_);
				_tmp62_ = g_value_get_boolean (_value);
				dbus_message_iter_append_basic (&_tmp60_, DBUS_TYPE_BOOLEAN, &_tmp62_);
				dbus_message_iter_close_container (&_tmp55_, &_tmp60_);
			} else if (G_VALUE_TYPE (_value) == G_TYPE_INT) {
				dbus_int32_t _tmp63_;
				dbus_message_iter_open_container (&_tmp55_, DBUS_TYPE_VARIANT, "i", &_tmp60_);
				_tmp63_ = g_value_get_int (_value);
				dbus_message_iter_append_basic (&_tmp60_, DBUS_TYPE_INT32, &_tmp63_);
				dbus_message_iter_close_container (&_tmp55_, &_tmp60_);
			} else if (G_VALUE_TYPE (_value) == G_TYPE_UINT) {
				dbus_uint32_t _tmp64_;
				dbus_message_iter_open_container (&_tmp55_, DBUS_TYPE_VARIANT, "u", &_tmp60_);
				_tmp64_ = g_value_get_uint (_value);
				dbus_message_iter_append_basic (&_tmp60_, DBUS_TYPE_UINT32, &_tmp64_);
				dbus_message_iter_close_container (&_tmp55_, &_tmp60_);
			} else if (G_VALUE_TYPE (_value) == G_TYPE_INT64) {
				dbus_int64_t _tmp65_;
				dbus_message_iter_open_container (&_tmp55_, DBUS_TYPE_VARIANT, "x", &_tmp60_);
				_tmp65_ = g_value_get_int64 (_value);
				dbus_message_iter_append_basic (&_tmp60_, DBUS_TYPE_INT64, &_tmp65_);
				dbus_message_iter_close_container (&_tmp55_, &_tmp60_);
			} else if (G_VALUE_TYPE (_value) == G_TYPE_UINT64) {
				dbus_uint64_t _tmp66_;
				dbus_message_iter_open_container (&_tmp55_, DBUS_TYPE_VARIANT, "t", &_tmp60_);
				_tmp66_ = g_value_get_uint64 (_value);
				dbus_message_iter_append_basic (&_tmp60_, DBUS_TYPE_UINT64, &_tmp66_);
				dbus_message_iter_close_container (&_tmp55_, &_tmp60_);
			} else if (G_VALUE_TYPE (_value) == G_TYPE_DOUBLE) {
				double _tmp67_;
				dbus_message_iter_open_container (&_tmp55_, DBUS_TYPE_VARIANT, "d", &_tmp60_);
				_tmp67_ = g_value_get_double (_value);
				dbus_message_iter_append_basic (&_tmp60_, DBUS_TYPE_DOUBLE, &_tmp67_);
				dbus_message_iter_close_container (&_tmp55_, &_tmp60_);
			} else if (G_VALUE_TYPE (_value) == G_TYPE_STRING) {
				const char* _tmp68_;
				dbus_message_iter_open_container (&_tmp55_, DBUS_TYPE_VARIANT, "s", &_tmp60_);
				_tmp68_ = g_value_get_string (_value);
				dbus_message_iter_append_basic (&_tmp60_, DBUS_TYPE_STRING, &_tmp68_);
				dbus_message_iter_close_container (&_tmp55_, &_tmp60_);
			} else if (G_VALUE_TYPE (_value) == G_TYPE_STRV) {
				const char** _tmp69_;
				DBusMessageIter _tmp70_;
				int _tmp71_;
				dbus_message_iter_open_container (&_tmp55_, DBUS_TYPE_VARIANT, "as", &_tmp60_);
				_tmp69_ = g_value_get_boxed (_value);
				dbus_message_iter_open_container (&_tmp60_, DBUS_TYPE_ARRAY, "s", &_tmp70_);
				for (_tmp71_ = 0; _tmp71_ < g_strv_length (g_value_get_boxed (_value)); _tmp71_++) {
					const char* _tmp72_;
					_tmp72_ = *_tmp69_;
					dbus_message_iter_append_basic (&_tmp70_, DBUS_TYPE_STRING, &_tmp72_);
					_tmp69_++;
				}
				dbus_message_iter_close_container (&_tmp60_, &_tmp70_);
				dbus_message_iter_close_container (&_tmp55_, &_tmp60_);
			}
			dbus_message_iter_close_container (&_tmp54_, &_tmp55_);
		}
		dbus_message_iter_close_container (&subiter, &_tmp54_);
		_g_hash_table_unref0 (result);
		dbus_message_iter_close_container (&reply_iter, &subiter);
	} else if ((strcmp (interface_name, "org.mpris.MediaPlayer2.Player") == 0) && (strcmp (property_name, "Position") == 0)) {
		gint32 result;
		dbus_int32_t _tmp73_;
		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_VARIANT, "i", &subiter);
		result = mpris_player_get_Position (self);
		_tmp73_ = result;
		dbus_message_iter_append_basic (&subiter, DBUS_TYPE_INT32, &_tmp73_);
		dbus_message_iter_close_container (&reply_iter, &subiter);
	} else if ((strcmp (interface_name, "org.mpris.MediaPlayer2.Player") == 0) && (strcmp (property_name, "PlaybackStatus") == 0)) {
		char* result;
		const char* _tmp74_;
		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_VARIANT, "s", &subiter);
		result = mpris_player_get_PlaybackStatus (self);
		_tmp74_ = result;
		dbus_message_iter_append_basic (&subiter, DBUS_TYPE_STRING, &_tmp74_);
		_g_free0 (result);
		dbus_message_iter_close_container (&reply_iter, &subiter);
	} else {
		dbus_message_unref (reply);
		reply = NULL;
	}
	g_free (interface_name);
	g_free (property_name);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_mpris_player_property_set (MprisPlayer* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter, subiter;
	char* interface_name;
	const char* _tmp75_;
	char* property_name;
	const char* _tmp76_;
	if (strcmp (dbus_message_get_signature (message), "ssv")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_get_basic (&iter, &_tmp75_);
	dbus_message_iter_next (&iter);
	interface_name = g_strdup (_tmp75_);
	dbus_message_iter_get_basic (&iter, &_tmp76_);
	dbus_message_iter_next (&iter);
	property_name = g_strdup (_tmp76_);
	dbus_message_iter_recurse (&iter, &subiter);
	if ((strcmp (interface_name, "org.mpris.MediaPlayer2.Player") == 0) && (strcmp (property_name, "Metadata") == 0)) {
		GHashTable* value;
		GHashTable* _tmp77_;
		DBusMessageIter _tmp78_;
		DBusMessageIter _tmp79_;
		_tmp77_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
		dbus_message_iter_recurse (&subiter, &_tmp78_);
		while (dbus_message_iter_get_arg_type (&_tmp78_)) {
			char* _key;
			GValue* _value;
			const char* _tmp80_;
			GValue _tmp81_ = {0};
			DBusMessageIter _tmp82_;
			dbus_message_iter_recurse (&_tmp78_, &_tmp79_);
			dbus_message_iter_get_basic (&_tmp79_, &_tmp80_);
			dbus_message_iter_next (&_tmp79_);
			_key = g_strdup (_tmp80_);
			dbus_message_iter_recurse (&_tmp79_, &_tmp82_);
			if (dbus_message_iter_get_arg_type (&_tmp82_) == DBUS_TYPE_BYTE) {
				guint8 _tmp83_;
				dbus_message_iter_get_basic (&_tmp82_, &_tmp83_);
				g_value_init (&_tmp81_, G_TYPE_UCHAR);
				g_value_set_uchar (&_tmp81_, _tmp83_);
			} else if (dbus_message_iter_get_arg_type (&_tmp82_) == DBUS_TYPE_BOOLEAN) {
				dbus_bool_t _tmp84_;
				dbus_message_iter_get_basic (&_tmp82_, &_tmp84_);
				g_value_init (&_tmp81_, G_TYPE_BOOLEAN);
				g_value_set_boolean (&_tmp81_, _tmp84_);
			} else if (dbus_message_iter_get_arg_type (&_tmp82_) == DBUS_TYPE_INT16) {
				dbus_int16_t _tmp85_;
				dbus_message_iter_get_basic (&_tmp82_, &_tmp85_);
				g_value_init (&_tmp81_, G_TYPE_INT);
				g_value_set_int (&_tmp81_, _tmp85_);
			} else if (dbus_message_iter_get_arg_type (&_tmp82_) == DBUS_TYPE_UINT16) {
				dbus_uint16_t _tmp86_;
				dbus_message_iter_get_basic (&_tmp82_, &_tmp86_);
				g_value_init (&_tmp81_, G_TYPE_UINT);
				g_value_set_uint (&_tmp81_, _tmp86_);
			} else if (dbus_message_iter_get_arg_type (&_tmp82_) == DBUS_TYPE_INT32) {
				dbus_int32_t _tmp87_;
				dbus_message_iter_get_basic (&_tmp82_, &_tmp87_);
				g_value_init (&_tmp81_, G_TYPE_INT);
				g_value_set_int (&_tmp81_, _tmp87_);
			} else if (dbus_message_iter_get_arg_type (&_tmp82_) == DBUS_TYPE_UINT32) {
				dbus_uint32_t _tmp88_;
				dbus_message_iter_get_basic (&_tmp82_, &_tmp88_);
				g_value_init (&_tmp81_, G_TYPE_UINT);
				g_value_set_uint (&_tmp81_, _tmp88_);
			} else if (dbus_message_iter_get_arg_type (&_tmp82_) == DBUS_TYPE_INT64) {
				dbus_int64_t _tmp89_;
				dbus_message_iter_get_basic (&_tmp82_, &_tmp89_);
				g_value_init (&_tmp81_, G_TYPE_INT64);
				g_value_set_int64 (&_tmp81_, _tmp89_);
			} else if (dbus_message_iter_get_arg_type (&_tmp82_) == DBUS_TYPE_UINT64) {
				dbus_uint64_t _tmp90_;
				dbus_message_iter_get_basic (&_tmp82_, &_tmp90_);
				g_value_init (&_tmp81_, G_TYPE_UINT64);
				g_value_set_uint64 (&_tmp81_, _tmp90_);
			} else if (dbus_message_iter_get_arg_type (&_tmp82_) == DBUS_TYPE_DOUBLE) {
				double _tmp91_;
				dbus_message_iter_get_basic (&_tmp82_, &_tmp91_);
				g_value_init (&_tmp81_, G_TYPE_DOUBLE);
				g_value_set_double (&_tmp81_, _tmp91_);
			} else if (dbus_message_iter_get_arg_type (&_tmp82_) == DBUS_TYPE_STRING) {
				const char* _tmp92_;
				dbus_message_iter_get_basic (&_tmp82_, &_tmp92_);
				g_value_init (&_tmp81_, G_TYPE_STRING);
				g_value_take_string (&_tmp81_, g_strdup (_tmp92_));
			} else if (dbus_message_iter_get_arg_type (&_tmp82_) == DBUS_TYPE_OBJECT_PATH) {
				const char* _tmp93_;
				dbus_message_iter_get_basic (&_tmp82_, &_tmp93_);
				g_value_init (&_tmp81_, G_TYPE_STRING);
				g_value_take_string (&_tmp81_, g_strdup (_tmp93_));
			} else if (dbus_message_iter_get_arg_type (&_tmp82_) == DBUS_TYPE_SIGNATURE) {
				const char* _tmp94_;
				dbus_message_iter_get_basic (&_tmp82_, &_tmp94_);
				g_value_init (&_tmp81_, G_TYPE_STRING);
				g_value_take_string (&_tmp81_, g_strdup (_tmp94_));
			} else if ((dbus_message_iter_get_arg_type (&_tmp82_) == DBUS_TYPE_ARRAY) && (dbus_message_iter_get_element_type (&_tmp82_) == DBUS_TYPE_STRING)) {
				const char** _tmp95_;
				int _tmp95__length;
				int _tmp95__size;
				int _tmp95__length1;
				DBusMessageIter _tmp96_;
				_tmp95_ = g_new (const char*, 5);
				_tmp95__length = 0;
				_tmp95__size = 4;
				_tmp95__length1 = 0;
				dbus_message_iter_recurse (&_tmp82_, &_tmp96_);
				for (; dbus_message_iter_get_arg_type (&_tmp96_); _tmp95__length1++) {
					const char* _tmp97_;
					if (_tmp95__size == _tmp95__length) {
						_tmp95__size = 2 * _tmp95__size;
						_tmp95_ = g_renew (const char*, _tmp95_, _tmp95__size + 1);
					}
					dbus_message_iter_get_basic (&_tmp96_, &_tmp97_);
					dbus_message_iter_next (&_tmp96_);
					_tmp95_[_tmp95__length++] = g_strdup (_tmp97_);
				}
				_tmp95_[_tmp95__length] = NULL;
				g_value_init (&_tmp81_, G_TYPE_STRV);
				g_value_take_boxed (&_tmp81_, _tmp95_);
			}
			dbus_message_iter_next (&_tmp79_);
			_value = g_memdup (&_tmp81_, sizeof (GValue));
			g_hash_table_insert (_tmp77_, _key, _value);
			dbus_message_iter_next (&_tmp78_);
		}
		dbus_message_iter_next (&subiter);
		value = _tmp77_;
		mpris_player_set_Metadata (self, value);
		_g_hash_table_unref0 (value);
	} else if ((strcmp (interface_name, "org.mpris.MediaPlayer2.Player") == 0) && (strcmp (property_name, "Position") == 0)) {
		gint32 value;
		dbus_int32_t _tmp98_;
		dbus_message_iter_get_basic (&subiter, &_tmp98_);
		dbus_message_iter_next (&subiter);
		value = _tmp98_;
		mpris_player_set_Position (self, value);
	} else if ((strcmp (interface_name, "org.mpris.MediaPlayer2.Player") == 0) && (strcmp (property_name, "PlaybackStatus") == 0)) {
		char* value;
		const char* _tmp99_;
		dbus_message_iter_get_basic (&subiter, &_tmp99_);
		dbus_message_iter_next (&subiter);
		value = g_strdup (_tmp99_);
		mpris_player_set_PlaybackStatus (self, value);
		_g_free0 (value);
	} else {
		dbus_message_unref (reply);
		reply = NULL;
	}
	g_free (interface_name);
	g_free (property_name);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_mpris_player_property_get_all (MprisPlayer* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter, reply_iter, subiter, entry_iter, value_iter;
	char* interface_name;
	const char* _tmp100_;
	const char* property_name;
	if (strcmp (dbus_message_get_signature (message), "s")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &reply_iter);
	dbus_message_iter_get_basic (&iter, &_tmp100_);
	dbus_message_iter_next (&iter);
	interface_name = g_strdup (_tmp100_);
	if (strcmp (interface_name, "org.mpris.MediaPlayer2.Player") == 0) {
		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_ARRAY, "{sv}", &subiter);
		{
			GHashTable* result;
			DBusMessageIter _tmp101_, _tmp102_;
			GHashTableIter _tmp103_;
			gpointer _tmp104_, _tmp105_;
			dbus_message_iter_open_container (&subiter, DBUS_TYPE_DICT_ENTRY, NULL, &entry_iter);
			property_name = "Metadata";
			dbus_message_iter_append_basic (&entry_iter, DBUS_TYPE_STRING, &property_name);
			dbus_message_iter_open_container (&entry_iter, DBUS_TYPE_VARIANT, "a{sv}", &value_iter);
			result = mpris_player_get_Metadata (self);
			dbus_message_iter_open_container (&value_iter, DBUS_TYPE_ARRAY, "{sv}", &_tmp101_);
			g_hash_table_iter_init (&_tmp103_, result);
			while (g_hash_table_iter_next (&_tmp103_, &_tmp104_, &_tmp105_)) {
				char* _key;
				GValue* _value;
				const char* _tmp106_;
				DBusMessageIter _tmp107_;
				dbus_message_iter_open_container (&_tmp101_, DBUS_TYPE_DICT_ENTRY, NULL, &_tmp102_);
				_key = (char*) _tmp104_;
				_value = (GValue*) _tmp105_;
				_tmp106_ = _key;
				dbus_message_iter_append_basic (&_tmp102_, DBUS_TYPE_STRING, &_tmp106_);
				if (G_VALUE_TYPE (_value) == G_TYPE_UCHAR) {
					guint8 _tmp108_;
					dbus_message_iter_open_container (&_tmp102_, DBUS_TYPE_VARIANT, "y", &_tmp107_);
					_tmp108_ = g_value_get_uchar (_value);
					dbus_message_iter_append_basic (&_tmp107_, DBUS_TYPE_BYTE, &_tmp108_);
					dbus_message_iter_close_container (&_tmp102_, &_tmp107_);
				} else if (G_VALUE_TYPE (_value) == G_TYPE_BOOLEAN) {
					dbus_bool_t _tmp109_;
					dbus_message_iter_open_container (&_tmp102_, DBUS_TYPE_VARIANT, "b", &_tmp107_);
					_tmp109_ = g_value_get_boolean (_value);
					dbus_message_iter_append_basic (&_tmp107_, DBUS_TYPE_BOOLEAN, &_tmp109_);
					dbus_message_iter_close_container (&_tmp102_, &_tmp107_);
				} else if (G_VALUE_TYPE (_value) == G_TYPE_INT) {
					dbus_int32_t _tmp110_;
					dbus_message_iter_open_container (&_tmp102_, DBUS_TYPE_VARIANT, "i", &_tmp107_);
					_tmp110_ = g_value_get_int (_value);
					dbus_message_iter_append_basic (&_tmp107_, DBUS_TYPE_INT32, &_tmp110_);
					dbus_message_iter_close_container (&_tmp102_, &_tmp107_);
				} else if (G_VALUE_TYPE (_value) == G_TYPE_UINT) {
					dbus_uint32_t _tmp111_;
					dbus_message_iter_open_container (&_tmp102_, DBUS_TYPE_VARIANT, "u", &_tmp107_);
					_tmp111_ = g_value_get_uint (_value);
					dbus_message_iter_append_basic (&_tmp107_, DBUS_TYPE_UINT32, &_tmp111_);
					dbus_message_iter_close_container (&_tmp102_, &_tmp107_);
				} else if (G_VALUE_TYPE (_value) == G_TYPE_INT64) {
					dbus_int64_t _tmp112_;
					dbus_message_iter_open_container (&_tmp102_, DBUS_TYPE_VARIANT, "x", &_tmp107_);
					_tmp112_ = g_value_get_int64 (_value);
					dbus_message_iter_append_basic (&_tmp107_, DBUS_TYPE_INT64, &_tmp112_);
					dbus_message_iter_close_container (&_tmp102_, &_tmp107_);
				} else if (G_VALUE_TYPE (_value) == G_TYPE_UINT64) {
					dbus_uint64_t _tmp113_;
					dbus_message_iter_open_container (&_tmp102_, DBUS_TYPE_VARIANT, "t", &_tmp107_);
					_tmp113_ = g_value_get_uint64 (_value);
					dbus_message_iter_append_basic (&_tmp107_, DBUS_TYPE_UINT64, &_tmp113_);
					dbus_message_iter_close_container (&_tmp102_, &_tmp107_);
				} else if (G_VALUE_TYPE (_value) == G_TYPE_DOUBLE) {
					double _tmp114_;
					dbus_message_iter_open_container (&_tmp102_, DBUS_TYPE_VARIANT, "d", &_tmp107_);
					_tmp114_ = g_value_get_double (_value);
					dbus_message_iter_append_basic (&_tmp107_, DBUS_TYPE_DOUBLE, &_tmp114_);
					dbus_message_iter_close_container (&_tmp102_, &_tmp107_);
				} else if (G_VALUE_TYPE (_value) == G_TYPE_STRING) {
					const char* _tmp115_;
					dbus_message_iter_open_container (&_tmp102_, DBUS_TYPE_VARIANT, "s", &_tmp107_);
					_tmp115_ = g_value_get_string (_value);
					dbus_message_iter_append_basic (&_tmp107_, DBUS_TYPE_STRING, &_tmp115_);
					dbus_message_iter_close_container (&_tmp102_, &_tmp107_);
				} else if (G_VALUE_TYPE (_value) == G_TYPE_STRV) {
					const char** _tmp116_;
					DBusMessageIter _tmp117_;
					int _tmp118_;
					dbus_message_iter_open_container (&_tmp102_, DBUS_TYPE_VARIANT, "as", &_tmp107_);
					_tmp116_ = g_value_get_boxed (_value);
					dbus_message_iter_open_container (&_tmp107_, DBUS_TYPE_ARRAY, "s", &_tmp117_);
					for (_tmp118_ = 0; _tmp118_ < g_strv_length (g_value_get_boxed (_value)); _tmp118_++) {
						const char* _tmp119_;
						_tmp119_ = *_tmp116_;
						dbus_message_iter_append_basic (&_tmp117_, DBUS_TYPE_STRING, &_tmp119_);
						_tmp116_++;
					}
					dbus_message_iter_close_container (&_tmp107_, &_tmp117_);
					dbus_message_iter_close_container (&_tmp102_, &_tmp107_);
				}
				dbus_message_iter_close_container (&_tmp101_, &_tmp102_);
			}
			dbus_message_iter_close_container (&value_iter, &_tmp101_);
			_g_hash_table_unref0 (result);
			dbus_message_iter_close_container (&entry_iter, &value_iter);
			dbus_message_iter_close_container (&subiter, &entry_iter);
		}
		{
			gint32 result;
			dbus_int32_t _tmp120_;
			dbus_message_iter_open_container (&subiter, DBUS_TYPE_DICT_ENTRY, NULL, &entry_iter);
			property_name = "Position";
			dbus_message_iter_append_basic (&entry_iter, DBUS_TYPE_STRING, &property_name);
			dbus_message_iter_open_container (&entry_iter, DBUS_TYPE_VARIANT, "i", &value_iter);
			result = mpris_player_get_Position (self);
			_tmp120_ = result;
			dbus_message_iter_append_basic (&value_iter, DBUS_TYPE_INT32, &_tmp120_);
			dbus_message_iter_close_container (&entry_iter, &value_iter);
			dbus_message_iter_close_container (&subiter, &entry_iter);
		}
		{
			char* result;
			const char* _tmp121_;
			dbus_message_iter_open_container (&subiter, DBUS_TYPE_DICT_ENTRY, NULL, &entry_iter);
			property_name = "PlaybackStatus";
			dbus_message_iter_append_basic (&entry_iter, DBUS_TYPE_STRING, &property_name);
			dbus_message_iter_open_container (&entry_iter, DBUS_TYPE_VARIANT, "s", &value_iter);
			result = mpris_player_get_PlaybackStatus (self);
			_tmp121_ = result;
			dbus_message_iter_append_basic (&value_iter, DBUS_TYPE_STRING, &_tmp121_);
			_g_free0 (result);
			dbus_message_iter_close_container (&entry_iter, &value_iter);
			dbus_message_iter_close_container (&subiter, &entry_iter);
		}
		dbus_message_iter_close_container (&reply_iter, &subiter);
	} else {
		dbus_message_unref (reply);
		reply = NULL;
	}
	g_free (interface_name);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_mpris_player_SetPosition (MprisPlayer* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	char* path = NULL;
	const char* _tmp122_;
	gint64 pos = 0LL;
	dbus_int64_t _tmp123_;
	DBusMessage* reply;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "ox")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp122_);
	dbus_message_iter_next (&iter);
	path = g_strdup (_tmp122_);
	dbus_message_iter_get_basic (&iter, &_tmp123_);
	dbus_message_iter_next (&iter);
	pos = _tmp123_;
	mpris_player_SetPosition (self, path, pos, &error);
	if (error) {
		if (error->domain == DBUS_GERROR) {
			switch (error->code) {
				case DBUS_GERROR_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Failed", error->message);
				break;
				case DBUS_GERROR_NO_MEMORY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoMemory", error->message);
				break;
				case DBUS_GERROR_SERVICE_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.ServiceUnknown", error->message);
				break;
				case DBUS_GERROR_NAME_HAS_NO_OWNER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NameHasNoOwner", error->message);
				break;
				case DBUS_GERROR_NO_REPLY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoReply", error->message);
				break;
				case DBUS_GERROR_IO_ERROR:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.IOError", error->message);
				break;
				case DBUS_GERROR_BAD_ADDRESS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.BadAddress", error->message);
				break;
				case DBUS_GERROR_NOT_SUPPORTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NotSupported", error->message);
				break;
				case DBUS_GERROR_LIMITS_EXCEEDED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.LimitsExceeded", error->message);
				break;
				case DBUS_GERROR_ACCESS_DENIED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AccessDenied", error->message);
				break;
				case DBUS_GERROR_AUTH_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AuthFailed", error->message);
				break;
				case DBUS_GERROR_NO_SERVER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoServer", error->message);
				break;
				case DBUS_GERROR_TIMEOUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Timeout", error->message);
				break;
				case DBUS_GERROR_NO_NETWORK:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoNetwork", error->message);
				break;
				case DBUS_GERROR_ADDRESS_IN_USE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AddressInUse", error->message);
				break;
				case DBUS_GERROR_DISCONNECTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Disconnected", error->message);
				break;
				case DBUS_GERROR_INVALID_ARGS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidArgs", error->message);
				break;
				case DBUS_GERROR_FILE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileNotFound", error->message);
				break;
				case DBUS_GERROR_FILE_EXISTS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileExists", error->message);
				break;
				case DBUS_GERROR_UNKNOWN_METHOD:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnknownMethod", error->message);
				break;
				case DBUS_GERROR_TIMED_OUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.TimedOut", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleNotFound", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_INVALID:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleInvalid", error->message);
				break;
				case DBUS_GERROR_SPAWN_EXEC_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ExecFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_FORK_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ForkFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_EXITED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildExited", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_SIGNALED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildSignaled", error->message);
				break;
				case DBUS_GERROR_SPAWN_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.Failed", error->message);
				break;
				case DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnixProcessIdUnknown", error->message);
				break;
				case DBUS_GERROR_INVALID_SIGNATURE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidSignature", error->message);
				break;
				case DBUS_GERROR_INVALID_FILE_CONTENT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidFileContent", error->message);
				break;
				case DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.SELinuxSecurityContextUnknown", error->message);
				break;
				case DBUS_GERROR_REMOTE_EXCEPTION:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.RemoteException", error->message);
				break;
			}
		}
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	}
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (path);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_mpris_player_PlayPause (MprisPlayer* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	DBusMessage* reply;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	mpris_player_PlayPause (self, &error);
	if (error) {
		if (error->domain == DBUS_GERROR) {
			switch (error->code) {
				case DBUS_GERROR_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Failed", error->message);
				break;
				case DBUS_GERROR_NO_MEMORY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoMemory", error->message);
				break;
				case DBUS_GERROR_SERVICE_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.ServiceUnknown", error->message);
				break;
				case DBUS_GERROR_NAME_HAS_NO_OWNER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NameHasNoOwner", error->message);
				break;
				case DBUS_GERROR_NO_REPLY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoReply", error->message);
				break;
				case DBUS_GERROR_IO_ERROR:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.IOError", error->message);
				break;
				case DBUS_GERROR_BAD_ADDRESS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.BadAddress", error->message);
				break;
				case DBUS_GERROR_NOT_SUPPORTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NotSupported", error->message);
				break;
				case DBUS_GERROR_LIMITS_EXCEEDED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.LimitsExceeded", error->message);
				break;
				case DBUS_GERROR_ACCESS_DENIED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AccessDenied", error->message);
				break;
				case DBUS_GERROR_AUTH_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AuthFailed", error->message);
				break;
				case DBUS_GERROR_NO_SERVER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoServer", error->message);
				break;
				case DBUS_GERROR_TIMEOUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Timeout", error->message);
				break;
				case DBUS_GERROR_NO_NETWORK:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoNetwork", error->message);
				break;
				case DBUS_GERROR_ADDRESS_IN_USE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AddressInUse", error->message);
				break;
				case DBUS_GERROR_DISCONNECTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Disconnected", error->message);
				break;
				case DBUS_GERROR_INVALID_ARGS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidArgs", error->message);
				break;
				case DBUS_GERROR_FILE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileNotFound", error->message);
				break;
				case DBUS_GERROR_FILE_EXISTS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileExists", error->message);
				break;
				case DBUS_GERROR_UNKNOWN_METHOD:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnknownMethod", error->message);
				break;
				case DBUS_GERROR_TIMED_OUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.TimedOut", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleNotFound", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_INVALID:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleInvalid", error->message);
				break;
				case DBUS_GERROR_SPAWN_EXEC_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ExecFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_FORK_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ForkFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_EXITED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildExited", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_SIGNALED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildSignaled", error->message);
				break;
				case DBUS_GERROR_SPAWN_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.Failed", error->message);
				break;
				case DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnixProcessIdUnknown", error->message);
				break;
				case DBUS_GERROR_INVALID_SIGNATURE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidSignature", error->message);
				break;
				case DBUS_GERROR_INVALID_FILE_CONTENT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidFileContent", error->message);
				break;
				case DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.SELinuxSecurityContextUnknown", error->message);
				break;
				case DBUS_GERROR_REMOTE_EXCEPTION:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.RemoteException", error->message);
				break;
			}
		}
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	}
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_mpris_player_Pause (MprisPlayer* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	DBusMessage* reply;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	mpris_player_Pause (self, &error);
	if (error) {
		if (error->domain == DBUS_GERROR) {
			switch (error->code) {
				case DBUS_GERROR_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Failed", error->message);
				break;
				case DBUS_GERROR_NO_MEMORY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoMemory", error->message);
				break;
				case DBUS_GERROR_SERVICE_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.ServiceUnknown", error->message);
				break;
				case DBUS_GERROR_NAME_HAS_NO_OWNER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NameHasNoOwner", error->message);
				break;
				case DBUS_GERROR_NO_REPLY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoReply", error->message);
				break;
				case DBUS_GERROR_IO_ERROR:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.IOError", error->message);
				break;
				case DBUS_GERROR_BAD_ADDRESS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.BadAddress", error->message);
				break;
				case DBUS_GERROR_NOT_SUPPORTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NotSupported", error->message);
				break;
				case DBUS_GERROR_LIMITS_EXCEEDED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.LimitsExceeded", error->message);
				break;
				case DBUS_GERROR_ACCESS_DENIED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AccessDenied", error->message);
				break;
				case DBUS_GERROR_AUTH_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AuthFailed", error->message);
				break;
				case DBUS_GERROR_NO_SERVER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoServer", error->message);
				break;
				case DBUS_GERROR_TIMEOUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Timeout", error->message);
				break;
				case DBUS_GERROR_NO_NETWORK:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoNetwork", error->message);
				break;
				case DBUS_GERROR_ADDRESS_IN_USE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AddressInUse", error->message);
				break;
				case DBUS_GERROR_DISCONNECTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Disconnected", error->message);
				break;
				case DBUS_GERROR_INVALID_ARGS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidArgs", error->message);
				break;
				case DBUS_GERROR_FILE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileNotFound", error->message);
				break;
				case DBUS_GERROR_FILE_EXISTS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileExists", error->message);
				break;
				case DBUS_GERROR_UNKNOWN_METHOD:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnknownMethod", error->message);
				break;
				case DBUS_GERROR_TIMED_OUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.TimedOut", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleNotFound", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_INVALID:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleInvalid", error->message);
				break;
				case DBUS_GERROR_SPAWN_EXEC_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ExecFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_FORK_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ForkFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_EXITED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildExited", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_SIGNALED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildSignaled", error->message);
				break;
				case DBUS_GERROR_SPAWN_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.Failed", error->message);
				break;
				case DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnixProcessIdUnknown", error->message);
				break;
				case DBUS_GERROR_INVALID_SIGNATURE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidSignature", error->message);
				break;
				case DBUS_GERROR_INVALID_FILE_CONTENT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidFileContent", error->message);
				break;
				case DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.SELinuxSecurityContextUnknown", error->message);
				break;
				case DBUS_GERROR_REMOTE_EXCEPTION:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.RemoteException", error->message);
				break;
			}
		}
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	}
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_mpris_player_Next (MprisPlayer* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	DBusMessage* reply;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	mpris_player_Next (self, &error);
	if (error) {
		if (error->domain == DBUS_GERROR) {
			switch (error->code) {
				case DBUS_GERROR_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Failed", error->message);
				break;
				case DBUS_GERROR_NO_MEMORY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoMemory", error->message);
				break;
				case DBUS_GERROR_SERVICE_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.ServiceUnknown", error->message);
				break;
				case DBUS_GERROR_NAME_HAS_NO_OWNER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NameHasNoOwner", error->message);
				break;
				case DBUS_GERROR_NO_REPLY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoReply", error->message);
				break;
				case DBUS_GERROR_IO_ERROR:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.IOError", error->message);
				break;
				case DBUS_GERROR_BAD_ADDRESS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.BadAddress", error->message);
				break;
				case DBUS_GERROR_NOT_SUPPORTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NotSupported", error->message);
				break;
				case DBUS_GERROR_LIMITS_EXCEEDED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.LimitsExceeded", error->message);
				break;
				case DBUS_GERROR_ACCESS_DENIED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AccessDenied", error->message);
				break;
				case DBUS_GERROR_AUTH_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AuthFailed", error->message);
				break;
				case DBUS_GERROR_NO_SERVER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoServer", error->message);
				break;
				case DBUS_GERROR_TIMEOUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Timeout", error->message);
				break;
				case DBUS_GERROR_NO_NETWORK:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoNetwork", error->message);
				break;
				case DBUS_GERROR_ADDRESS_IN_USE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AddressInUse", error->message);
				break;
				case DBUS_GERROR_DISCONNECTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Disconnected", error->message);
				break;
				case DBUS_GERROR_INVALID_ARGS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidArgs", error->message);
				break;
				case DBUS_GERROR_FILE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileNotFound", error->message);
				break;
				case DBUS_GERROR_FILE_EXISTS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileExists", error->message);
				break;
				case DBUS_GERROR_UNKNOWN_METHOD:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnknownMethod", error->message);
				break;
				case DBUS_GERROR_TIMED_OUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.TimedOut", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleNotFound", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_INVALID:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleInvalid", error->message);
				break;
				case DBUS_GERROR_SPAWN_EXEC_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ExecFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_FORK_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ForkFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_EXITED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildExited", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_SIGNALED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildSignaled", error->message);
				break;
				case DBUS_GERROR_SPAWN_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.Failed", error->message);
				break;
				case DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnixProcessIdUnknown", error->message);
				break;
				case DBUS_GERROR_INVALID_SIGNATURE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidSignature", error->message);
				break;
				case DBUS_GERROR_INVALID_FILE_CONTENT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidFileContent", error->message);
				break;
				case DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.SELinuxSecurityContextUnknown", error->message);
				break;
				case DBUS_GERROR_REMOTE_EXCEPTION:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.RemoteException", error->message);
				break;
			}
		}
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	}
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_mpris_player_Previous (MprisPlayer* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	DBusMessage* reply;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	mpris_player_Previous (self, &error);
	if (error) {
		if (error->domain == DBUS_GERROR) {
			switch (error->code) {
				case DBUS_GERROR_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Failed", error->message);
				break;
				case DBUS_GERROR_NO_MEMORY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoMemory", error->message);
				break;
				case DBUS_GERROR_SERVICE_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.ServiceUnknown", error->message);
				break;
				case DBUS_GERROR_NAME_HAS_NO_OWNER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NameHasNoOwner", error->message);
				break;
				case DBUS_GERROR_NO_REPLY:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoReply", error->message);
				break;
				case DBUS_GERROR_IO_ERROR:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.IOError", error->message);
				break;
				case DBUS_GERROR_BAD_ADDRESS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.BadAddress", error->message);
				break;
				case DBUS_GERROR_NOT_SUPPORTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NotSupported", error->message);
				break;
				case DBUS_GERROR_LIMITS_EXCEEDED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.LimitsExceeded", error->message);
				break;
				case DBUS_GERROR_ACCESS_DENIED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AccessDenied", error->message);
				break;
				case DBUS_GERROR_AUTH_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AuthFailed", error->message);
				break;
				case DBUS_GERROR_NO_SERVER:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoServer", error->message);
				break;
				case DBUS_GERROR_TIMEOUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Timeout", error->message);
				break;
				case DBUS_GERROR_NO_NETWORK:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.NoNetwork", error->message);
				break;
				case DBUS_GERROR_ADDRESS_IN_USE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.AddressInUse", error->message);
				break;
				case DBUS_GERROR_DISCONNECTED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Disconnected", error->message);
				break;
				case DBUS_GERROR_INVALID_ARGS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidArgs", error->message);
				break;
				case DBUS_GERROR_FILE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileNotFound", error->message);
				break;
				case DBUS_GERROR_FILE_EXISTS:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.FileExists", error->message);
				break;
				case DBUS_GERROR_UNKNOWN_METHOD:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnknownMethod", error->message);
				break;
				case DBUS_GERROR_TIMED_OUT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.TimedOut", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_NOT_FOUND:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleNotFound", error->message);
				break;
				case DBUS_GERROR_MATCH_RULE_INVALID:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.MatchRuleInvalid", error->message);
				break;
				case DBUS_GERROR_SPAWN_EXEC_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ExecFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_FORK_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ForkFailed", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_EXITED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildExited", error->message);
				break;
				case DBUS_GERROR_SPAWN_CHILD_SIGNALED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.ChildSignaled", error->message);
				break;
				case DBUS_GERROR_SPAWN_FAILED:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.Spawn.Failed", error->message);
				break;
				case DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.UnixProcessIdUnknown", error->message);
				break;
				case DBUS_GERROR_INVALID_SIGNATURE:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidSignature", error->message);
				break;
				case DBUS_GERROR_INVALID_FILE_CONTENT:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.InvalidFileContent", error->message);
				break;
				case DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.SELinuxSecurityContextUnknown", error->message);
				break;
				case DBUS_GERROR_REMOTE_EXCEPTION:
				reply = dbus_message_new_error (message, "org.freedesktop.DBus.Error.RemoteException", error->message);
				break;
			}
		}
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	}
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


DBusHandlerResult mpris_player_dbus_message (DBusConnection* connection, DBusMessage* message, void* object) {
	DBusHandlerResult result;
	result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Introspectable", "Introspect")) {
		result = _dbus_mpris_player_introspect (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Properties", "Get")) {
		result = _dbus_mpris_player_property_get (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Properties", "Set")) {
		result = _dbus_mpris_player_property_set (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Properties", "GetAll")) {
		result = _dbus_mpris_player_property_get_all (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.mpris.MediaPlayer2.Player", "SetPosition")) {
		result = _dbus_mpris_player_SetPosition (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.mpris.MediaPlayer2.Player", "PlayPause")) {
		result = _dbus_mpris_player_PlayPause (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.mpris.MediaPlayer2.Player", "Pause")) {
		result = _dbus_mpris_player_Pause (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.mpris.MediaPlayer2.Player", "Next")) {
		result = _dbus_mpris_player_Next (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.mpris.MediaPlayer2.Player", "Previous")) {
		result = _dbus_mpris_player_Previous (object, connection, message);
	}
	if (result == DBUS_HANDLER_RESULT_HANDLED) {
		return result;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static void _dbus_mpris_player_seeked (GObject* _sender, gint64 new_position, DBusConnection* _connection) {
	const char * _path;
	DBusMessage *_message;
	DBusMessageIter _iter;
	dbus_int64_t _tmp124_;
	_path = g_object_get_data (_sender, "dbus_object_path");
	_message = dbus_message_new_signal (_path, "org.mpris.MediaPlayer2.Player", "Seeked");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp124_ = new_position;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_INT64, &_tmp124_);
	dbus_connection_send (_connection, _message, NULL);
	dbus_message_unref (_message);
}


void mpris_player_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
	if (!g_object_get_data (object, "dbus_object_path")) {
		g_object_set_data (object, "dbus_object_path", g_strdup (path));
		dbus_connection_register_object_path (connection, path, &_mpris_player_dbus_path_vtable, object);
		g_object_weak_ref (object, _vala_dbus_unregister_object, connection);
	}
	g_signal_connect (object, "seeked", (GCallback) _dbus_mpris_player_seeked, connection);
}


static void mpris_player_base_init (MprisPlayerIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
		g_object_interface_install_property (iface, g_param_spec_boxed ("Metadata", "Metadata", "Metadata", G_TYPE_HASH_TABLE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
		g_object_interface_install_property (iface, g_param_spec_int ("Position", "Position", "Position", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
		g_object_interface_install_property (iface, g_param_spec_string ("PlaybackStatus", "PlaybackStatus", "PlaybackStatus", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
		g_signal_new ("seeked", TYPE_MPRIS_PLAYER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__INT64, G_TYPE_NONE, 1, G_TYPE_INT64);
		g_type_set_qdata (TYPE_MPRIS_PLAYER, g_quark_from_static_string ("DBusObjectVTable"), (void*) (&_mpris_player_dbus_vtable));
	}
}


GType mpris_player_get_type (void) {
	static volatile gsize mpris_player_type_id__volatile = 0;
	if (g_once_init_enter (&mpris_player_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (MprisPlayerIface), (GBaseInitFunc) mpris_player_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType mpris_player_type_id;
		mpris_player_type_id = g_type_register_static (G_TYPE_INTERFACE, "MprisPlayer", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (mpris_player_type_id, DBUS_TYPE_G_PROXY);
		g_type_set_qdata (mpris_player_type_id, g_quark_from_string ("ValaDBusInterfaceProxyType"), &mpris_player_dbus_proxy_get_type);
		g_once_init_leave (&mpris_player_type_id__volatile, mpris_player_type_id);
	}
	return mpris_player_type_id__volatile;
}


G_DEFINE_TYPE_EXTENDED (MprisPlayerDBusProxy, mpris_player_dbus_proxy, DBUS_TYPE_G_PROXY, 0, G_IMPLEMENT_INTERFACE (TYPE_MPRIS_PLAYER, mpris_player_dbus_proxy_mpris_player__interface_init) );
MprisPlayer* mpris_player_dbus_proxy_new (DBusGConnection* connection, const char* name, const char* path) {
	MprisPlayer* self;
	self = g_object_new (mpris_player_dbus_proxy_get_type (), "connection", connection, "name", name, "path", path, "interface", "org.mpris.MediaPlayer2.Player", NULL);
	return self;
}


static GObject* mpris_player_dbus_proxy_construct (GType gtype, guint n_properties, GObjectConstructParam* properties) {
	GObject* self;
	DBusGConnection *connection;
	char* path;
	char* filter;
	self = G_OBJECT_CLASS (mpris_player_dbus_proxy_parent_class)->constructor (gtype, n_properties, properties);
	g_object_get (self, "connection", &connection, NULL);
	g_object_get (self, "path", &path, NULL);
	dbus_connection_add_filter (dbus_g_connection_get_connection (connection), mpris_player_dbus_proxy_filter, self, NULL);
	filter = g_strdup_printf ("type='signal',path='%s'", path);
	dbus_bus_add_match (dbus_g_connection_get_connection (connection), filter, NULL);
	dbus_g_connection_unref (connection);
	g_free (path);
	g_free (filter);
	return self;
}


static void _dbus_handle_mpris_player_seeked (MprisPlayer* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	gint64 new_position = 0LL;
	dbus_int64_t _tmp125_;
	DBusMessage* reply;
	if (strcmp (dbus_message_get_signature (message), "x")) {
		return;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp125_);
	dbus_message_iter_next (&iter);
	new_position = _tmp125_;
	g_signal_emit_by_name (self, "seeked", new_position);
}


DBusHandlerResult mpris_player_dbus_proxy_filter (DBusConnection* connection, DBusMessage* message, void* user_data) {
	if (dbus_message_has_path (message, dbus_g_proxy_get_path (user_data))) {
		if (dbus_message_is_signal (message, "org.mpris.MediaPlayer2.Player", "Seeked")) {
			_dbus_handle_mpris_player_seeked (user_data, connection, message);
		}
	}
	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
}


static void mpris_player_dbus_proxy_dispose (GObject* self) {
	DBusGConnection *connection;
	if (((MprisPlayerDBusProxy*) self)->disposed) {
		return;
	}
	((MprisPlayerDBusProxy*) self)->disposed = TRUE;
	g_object_get (self, "connection", &connection, NULL);
	dbus_connection_remove_filter (dbus_g_connection_get_connection (connection), mpris_player_dbus_proxy_filter, self);
	G_OBJECT_CLASS (mpris_player_dbus_proxy_parent_class)->dispose (self);
}


static void mpris_player_dbus_proxy_class_init (MprisPlayerDBusProxyClass* klass) {
	G_OBJECT_CLASS (klass)->constructor = mpris_player_dbus_proxy_construct;
	G_OBJECT_CLASS (klass)->dispose = mpris_player_dbus_proxy_dispose;
	G_OBJECT_CLASS (klass)->get_property = mpris_player_dbus_proxy_get_property;
	G_OBJECT_CLASS (klass)->set_property = mpris_player_dbus_proxy_set_property;
	g_object_class_override_property (G_OBJECT_CLASS (klass), MPRIS_PLAYER_DBUS_PROXY_METADATA, "Metadata");
	g_object_class_override_property (G_OBJECT_CLASS (klass), MPRIS_PLAYER_DBUS_PROXY_POSITION, "Position");
	g_object_class_override_property (G_OBJECT_CLASS (klass), MPRIS_PLAYER_DBUS_PROXY_PLAYBACK_STATUS, "PlaybackStatus");
}


static void mpris_player_dbus_proxy_init (MprisPlayerDBusProxy* self) {
}


static void mpris_player_dbus_proxy_SetPosition (MprisPlayer* self, const char* path, gint64 pos, GError** error) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter;
	const char* _tmp126_;
	dbus_int64_t _tmp127_;
	if (((MprisPlayerDBusProxy*) self)->disposed) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
		return;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.mpris.MediaPlayer2.Player", "SetPosition");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp126_ = path;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_OBJECT_PATH, &_tmp126_);
	_tmp127_ = pos;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_INT64, &_tmp127_);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		GQuark _edomain;
		gint _ecode;
		if (strstr (_dbus_error.name, "org.freedesktop.DBus.Error") == _dbus_error.name) {
			const char* _tmp128_;
			_edomain = DBUS_GERROR;
			_tmp128_ = _dbus_error.name + 27;
			if (strcmp (_tmp128_, "Failed") == 0) {
				_ecode = DBUS_GERROR_FAILED;
			} else if (strcmp (_tmp128_, "NoMemory") == 0) {
				_ecode = DBUS_GERROR_NO_MEMORY;
			} else if (strcmp (_tmp128_, "ServiceUnknown") == 0) {
				_ecode = DBUS_GERROR_SERVICE_UNKNOWN;
			} else if (strcmp (_tmp128_, "NameHasNoOwner") == 0) {
				_ecode = DBUS_GERROR_NAME_HAS_NO_OWNER;
			} else if (strcmp (_tmp128_, "NoReply") == 0) {
				_ecode = DBUS_GERROR_NO_REPLY;
			} else if (strcmp (_tmp128_, "IOError") == 0) {
				_ecode = DBUS_GERROR_IO_ERROR;
			} else if (strcmp (_tmp128_, "BadAddress") == 0) {
				_ecode = DBUS_GERROR_BAD_ADDRESS;
			} else if (strcmp (_tmp128_, "NotSupported") == 0) {
				_ecode = DBUS_GERROR_NOT_SUPPORTED;
			} else if (strcmp (_tmp128_, "LimitsExceeded") == 0) {
				_ecode = DBUS_GERROR_LIMITS_EXCEEDED;
			} else if (strcmp (_tmp128_, "AccessDenied") == 0) {
				_ecode = DBUS_GERROR_ACCESS_DENIED;
			} else if (strcmp (_tmp128_, "AuthFailed") == 0) {
				_ecode = DBUS_GERROR_AUTH_FAILED;
			} else if (strcmp (_tmp128_, "NoServer") == 0) {
				_ecode = DBUS_GERROR_NO_SERVER;
			} else if (strcmp (_tmp128_, "Timeout") == 0) {
				_ecode = DBUS_GERROR_TIMEOUT;
			} else if (strcmp (_tmp128_, "NoNetwork") == 0) {
				_ecode = DBUS_GERROR_NO_NETWORK;
			} else if (strcmp (_tmp128_, "AddressInUse") == 0) {
				_ecode = DBUS_GERROR_ADDRESS_IN_USE;
			} else if (strcmp (_tmp128_, "Disconnected") == 0) {
				_ecode = DBUS_GERROR_DISCONNECTED;
			} else if (strcmp (_tmp128_, "InvalidArgs") == 0) {
				_ecode = DBUS_GERROR_INVALID_ARGS;
			} else if (strcmp (_tmp128_, "FileNotFound") == 0) {
				_ecode = DBUS_GERROR_FILE_NOT_FOUND;
			} else if (strcmp (_tmp128_, "FileExists") == 0) {
				_ecode = DBUS_GERROR_FILE_EXISTS;
			} else if (strcmp (_tmp128_, "UnknownMethod") == 0) {
				_ecode = DBUS_GERROR_UNKNOWN_METHOD;
			} else if (strcmp (_tmp128_, "TimedOut") == 0) {
				_ecode = DBUS_GERROR_TIMED_OUT;
			} else if (strcmp (_tmp128_, "MatchRuleNotFound") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_NOT_FOUND;
			} else if (strcmp (_tmp128_, "MatchRuleInvalid") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_INVALID;
			} else if (strcmp (_tmp128_, "Spawn.ExecFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_EXEC_FAILED;
			} else if (strcmp (_tmp128_, "Spawn.ForkFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FORK_FAILED;
			} else if (strcmp (_tmp128_, "Spawn.ChildExited") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_EXITED;
			} else if (strcmp (_tmp128_, "Spawn.ChildSignaled") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_SIGNALED;
			} else if (strcmp (_tmp128_, "Spawn.Failed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FAILED;
			} else if (strcmp (_tmp128_, "UnixProcessIdUnknown") == 0) {
				_ecode = DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN;
			} else if (strcmp (_tmp128_, "InvalidSignature") == 0) {
				_ecode = DBUS_GERROR_INVALID_SIGNATURE;
			} else if (strcmp (_tmp128_, "InvalidFileContent") == 0) {
				_ecode = DBUS_GERROR_INVALID_FILE_CONTENT;
			} else if (strcmp (_tmp128_, "SELinuxSecurityContextUnknown") == 0) {
				_ecode = DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN;
			} else if (strcmp (_tmp128_, "RemoteException") == 0) {
				_ecode = DBUS_GERROR_REMOTE_EXCEPTION;
			}
		}
		g_set_error (error, _edomain, _ecode, "%s", _dbus_error.message);
		dbus_error_free (&_dbus_error);
		return;
	}
	if (strcmp (dbus_message_get_signature (_reply), "")) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_unref (_reply);
}


static void mpris_player_dbus_proxy_PlayPause (MprisPlayer* self, GError** error) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter;
	if (((MprisPlayerDBusProxy*) self)->disposed) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
		return;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.mpris.MediaPlayer2.Player", "PlayPause");
	dbus_message_iter_init_append (_message, &_iter);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		GQuark _edomain;
		gint _ecode;
		if (strstr (_dbus_error.name, "org.freedesktop.DBus.Error") == _dbus_error.name) {
			const char* _tmp129_;
			_edomain = DBUS_GERROR;
			_tmp129_ = _dbus_error.name + 27;
			if (strcmp (_tmp129_, "Failed") == 0) {
				_ecode = DBUS_GERROR_FAILED;
			} else if (strcmp (_tmp129_, "NoMemory") == 0) {
				_ecode = DBUS_GERROR_NO_MEMORY;
			} else if (strcmp (_tmp129_, "ServiceUnknown") == 0) {
				_ecode = DBUS_GERROR_SERVICE_UNKNOWN;
			} else if (strcmp (_tmp129_, "NameHasNoOwner") == 0) {
				_ecode = DBUS_GERROR_NAME_HAS_NO_OWNER;
			} else if (strcmp (_tmp129_, "NoReply") == 0) {
				_ecode = DBUS_GERROR_NO_REPLY;
			} else if (strcmp (_tmp129_, "IOError") == 0) {
				_ecode = DBUS_GERROR_IO_ERROR;
			} else if (strcmp (_tmp129_, "BadAddress") == 0) {
				_ecode = DBUS_GERROR_BAD_ADDRESS;
			} else if (strcmp (_tmp129_, "NotSupported") == 0) {
				_ecode = DBUS_GERROR_NOT_SUPPORTED;
			} else if (strcmp (_tmp129_, "LimitsExceeded") == 0) {
				_ecode = DBUS_GERROR_LIMITS_EXCEEDED;
			} else if (strcmp (_tmp129_, "AccessDenied") == 0) {
				_ecode = DBUS_GERROR_ACCESS_DENIED;
			} else if (strcmp (_tmp129_, "AuthFailed") == 0) {
				_ecode = DBUS_GERROR_AUTH_FAILED;
			} else if (strcmp (_tmp129_, "NoServer") == 0) {
				_ecode = DBUS_GERROR_NO_SERVER;
			} else if (strcmp (_tmp129_, "Timeout") == 0) {
				_ecode = DBUS_GERROR_TIMEOUT;
			} else if (strcmp (_tmp129_, "NoNetwork") == 0) {
				_ecode = DBUS_GERROR_NO_NETWORK;
			} else if (strcmp (_tmp129_, "AddressInUse") == 0) {
				_ecode = DBUS_GERROR_ADDRESS_IN_USE;
			} else if (strcmp (_tmp129_, "Disconnected") == 0) {
				_ecode = DBUS_GERROR_DISCONNECTED;
			} else if (strcmp (_tmp129_, "InvalidArgs") == 0) {
				_ecode = DBUS_GERROR_INVALID_ARGS;
			} else if (strcmp (_tmp129_, "FileNotFound") == 0) {
				_ecode = DBUS_GERROR_FILE_NOT_FOUND;
			} else if (strcmp (_tmp129_, "FileExists") == 0) {
				_ecode = DBUS_GERROR_FILE_EXISTS;
			} else if (strcmp (_tmp129_, "UnknownMethod") == 0) {
				_ecode = DBUS_GERROR_UNKNOWN_METHOD;
			} else if (strcmp (_tmp129_, "TimedOut") == 0) {
				_ecode = DBUS_GERROR_TIMED_OUT;
			} else if (strcmp (_tmp129_, "MatchRuleNotFound") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_NOT_FOUND;
			} else if (strcmp (_tmp129_, "MatchRuleInvalid") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_INVALID;
			} else if (strcmp (_tmp129_, "Spawn.ExecFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_EXEC_FAILED;
			} else if (strcmp (_tmp129_, "Spawn.ForkFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FORK_FAILED;
			} else if (strcmp (_tmp129_, "Spawn.ChildExited") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_EXITED;
			} else if (strcmp (_tmp129_, "Spawn.ChildSignaled") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_SIGNALED;
			} else if (strcmp (_tmp129_, "Spawn.Failed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FAILED;
			} else if (strcmp (_tmp129_, "UnixProcessIdUnknown") == 0) {
				_ecode = DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN;
			} else if (strcmp (_tmp129_, "InvalidSignature") == 0) {
				_ecode = DBUS_GERROR_INVALID_SIGNATURE;
			} else if (strcmp (_tmp129_, "InvalidFileContent") == 0) {
				_ecode = DBUS_GERROR_INVALID_FILE_CONTENT;
			} else if (strcmp (_tmp129_, "SELinuxSecurityContextUnknown") == 0) {
				_ecode = DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN;
			} else if (strcmp (_tmp129_, "RemoteException") == 0) {
				_ecode = DBUS_GERROR_REMOTE_EXCEPTION;
			}
		}
		g_set_error (error, _edomain, _ecode, "%s", _dbus_error.message);
		dbus_error_free (&_dbus_error);
		return;
	}
	if (strcmp (dbus_message_get_signature (_reply), "")) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_unref (_reply);
}


static void mpris_player_dbus_proxy_Pause (MprisPlayer* self, GError** error) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter;
	if (((MprisPlayerDBusProxy*) self)->disposed) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
		return;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.mpris.MediaPlayer2.Player", "Pause");
	dbus_message_iter_init_append (_message, &_iter);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		GQuark _edomain;
		gint _ecode;
		if (strstr (_dbus_error.name, "org.freedesktop.DBus.Error") == _dbus_error.name) {
			const char* _tmp130_;
			_edomain = DBUS_GERROR;
			_tmp130_ = _dbus_error.name + 27;
			if (strcmp (_tmp130_, "Failed") == 0) {
				_ecode = DBUS_GERROR_FAILED;
			} else if (strcmp (_tmp130_, "NoMemory") == 0) {
				_ecode = DBUS_GERROR_NO_MEMORY;
			} else if (strcmp (_tmp130_, "ServiceUnknown") == 0) {
				_ecode = DBUS_GERROR_SERVICE_UNKNOWN;
			} else if (strcmp (_tmp130_, "NameHasNoOwner") == 0) {
				_ecode = DBUS_GERROR_NAME_HAS_NO_OWNER;
			} else if (strcmp (_tmp130_, "NoReply") == 0) {
				_ecode = DBUS_GERROR_NO_REPLY;
			} else if (strcmp (_tmp130_, "IOError") == 0) {
				_ecode = DBUS_GERROR_IO_ERROR;
			} else if (strcmp (_tmp130_, "BadAddress") == 0) {
				_ecode = DBUS_GERROR_BAD_ADDRESS;
			} else if (strcmp (_tmp130_, "NotSupported") == 0) {
				_ecode = DBUS_GERROR_NOT_SUPPORTED;
			} else if (strcmp (_tmp130_, "LimitsExceeded") == 0) {
				_ecode = DBUS_GERROR_LIMITS_EXCEEDED;
			} else if (strcmp (_tmp130_, "AccessDenied") == 0) {
				_ecode = DBUS_GERROR_ACCESS_DENIED;
			} else if (strcmp (_tmp130_, "AuthFailed") == 0) {
				_ecode = DBUS_GERROR_AUTH_FAILED;
			} else if (strcmp (_tmp130_, "NoServer") == 0) {
				_ecode = DBUS_GERROR_NO_SERVER;
			} else if (strcmp (_tmp130_, "Timeout") == 0) {
				_ecode = DBUS_GERROR_TIMEOUT;
			} else if (strcmp (_tmp130_, "NoNetwork") == 0) {
				_ecode = DBUS_GERROR_NO_NETWORK;
			} else if (strcmp (_tmp130_, "AddressInUse") == 0) {
				_ecode = DBUS_GERROR_ADDRESS_IN_USE;
			} else if (strcmp (_tmp130_, "Disconnected") == 0) {
				_ecode = DBUS_GERROR_DISCONNECTED;
			} else if (strcmp (_tmp130_, "InvalidArgs") == 0) {
				_ecode = DBUS_GERROR_INVALID_ARGS;
			} else if (strcmp (_tmp130_, "FileNotFound") == 0) {
				_ecode = DBUS_GERROR_FILE_NOT_FOUND;
			} else if (strcmp (_tmp130_, "FileExists") == 0) {
				_ecode = DBUS_GERROR_FILE_EXISTS;
			} else if (strcmp (_tmp130_, "UnknownMethod") == 0) {
				_ecode = DBUS_GERROR_UNKNOWN_METHOD;
			} else if (strcmp (_tmp130_, "TimedOut") == 0) {
				_ecode = DBUS_GERROR_TIMED_OUT;
			} else if (strcmp (_tmp130_, "MatchRuleNotFound") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_NOT_FOUND;
			} else if (strcmp (_tmp130_, "MatchRuleInvalid") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_INVALID;
			} else if (strcmp (_tmp130_, "Spawn.ExecFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_EXEC_FAILED;
			} else if (strcmp (_tmp130_, "Spawn.ForkFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FORK_FAILED;
			} else if (strcmp (_tmp130_, "Spawn.ChildExited") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_EXITED;
			} else if (strcmp (_tmp130_, "Spawn.ChildSignaled") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_SIGNALED;
			} else if (strcmp (_tmp130_, "Spawn.Failed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FAILED;
			} else if (strcmp (_tmp130_, "UnixProcessIdUnknown") == 0) {
				_ecode = DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN;
			} else if (strcmp (_tmp130_, "InvalidSignature") == 0) {
				_ecode = DBUS_GERROR_INVALID_SIGNATURE;
			} else if (strcmp (_tmp130_, "InvalidFileContent") == 0) {
				_ecode = DBUS_GERROR_INVALID_FILE_CONTENT;
			} else if (strcmp (_tmp130_, "SELinuxSecurityContextUnknown") == 0) {
				_ecode = DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN;
			} else if (strcmp (_tmp130_, "RemoteException") == 0) {
				_ecode = DBUS_GERROR_REMOTE_EXCEPTION;
			}
		}
		g_set_error (error, _edomain, _ecode, "%s", _dbus_error.message);
		dbus_error_free (&_dbus_error);
		return;
	}
	if (strcmp (dbus_message_get_signature (_reply), "")) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_unref (_reply);
}


static void mpris_player_dbus_proxy_Next (MprisPlayer* self, GError** error) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter;
	if (((MprisPlayerDBusProxy*) self)->disposed) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
		return;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.mpris.MediaPlayer2.Player", "Next");
	dbus_message_iter_init_append (_message, &_iter);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		GQuark _edomain;
		gint _ecode;
		if (strstr (_dbus_error.name, "org.freedesktop.DBus.Error") == _dbus_error.name) {
			const char* _tmp131_;
			_edomain = DBUS_GERROR;
			_tmp131_ = _dbus_error.name + 27;
			if (strcmp (_tmp131_, "Failed") == 0) {
				_ecode = DBUS_GERROR_FAILED;
			} else if (strcmp (_tmp131_, "NoMemory") == 0) {
				_ecode = DBUS_GERROR_NO_MEMORY;
			} else if (strcmp (_tmp131_, "ServiceUnknown") == 0) {
				_ecode = DBUS_GERROR_SERVICE_UNKNOWN;
			} else if (strcmp (_tmp131_, "NameHasNoOwner") == 0) {
				_ecode = DBUS_GERROR_NAME_HAS_NO_OWNER;
			} else if (strcmp (_tmp131_, "NoReply") == 0) {
				_ecode = DBUS_GERROR_NO_REPLY;
			} else if (strcmp (_tmp131_, "IOError") == 0) {
				_ecode = DBUS_GERROR_IO_ERROR;
			} else if (strcmp (_tmp131_, "BadAddress") == 0) {
				_ecode = DBUS_GERROR_BAD_ADDRESS;
			} else if (strcmp (_tmp131_, "NotSupported") == 0) {
				_ecode = DBUS_GERROR_NOT_SUPPORTED;
			} else if (strcmp (_tmp131_, "LimitsExceeded") == 0) {
				_ecode = DBUS_GERROR_LIMITS_EXCEEDED;
			} else if (strcmp (_tmp131_, "AccessDenied") == 0) {
				_ecode = DBUS_GERROR_ACCESS_DENIED;
			} else if (strcmp (_tmp131_, "AuthFailed") == 0) {
				_ecode = DBUS_GERROR_AUTH_FAILED;
			} else if (strcmp (_tmp131_, "NoServer") == 0) {
				_ecode = DBUS_GERROR_NO_SERVER;
			} else if (strcmp (_tmp131_, "Timeout") == 0) {
				_ecode = DBUS_GERROR_TIMEOUT;
			} else if (strcmp (_tmp131_, "NoNetwork") == 0) {
				_ecode = DBUS_GERROR_NO_NETWORK;
			} else if (strcmp (_tmp131_, "AddressInUse") == 0) {
				_ecode = DBUS_GERROR_ADDRESS_IN_USE;
			} else if (strcmp (_tmp131_, "Disconnected") == 0) {
				_ecode = DBUS_GERROR_DISCONNECTED;
			} else if (strcmp (_tmp131_, "InvalidArgs") == 0) {
				_ecode = DBUS_GERROR_INVALID_ARGS;
			} else if (strcmp (_tmp131_, "FileNotFound") == 0) {
				_ecode = DBUS_GERROR_FILE_NOT_FOUND;
			} else if (strcmp (_tmp131_, "FileExists") == 0) {
				_ecode = DBUS_GERROR_FILE_EXISTS;
			} else if (strcmp (_tmp131_, "UnknownMethod") == 0) {
				_ecode = DBUS_GERROR_UNKNOWN_METHOD;
			} else if (strcmp (_tmp131_, "TimedOut") == 0) {
				_ecode = DBUS_GERROR_TIMED_OUT;
			} else if (strcmp (_tmp131_, "MatchRuleNotFound") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_NOT_FOUND;
			} else if (strcmp (_tmp131_, "MatchRuleInvalid") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_INVALID;
			} else if (strcmp (_tmp131_, "Spawn.ExecFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_EXEC_FAILED;
			} else if (strcmp (_tmp131_, "Spawn.ForkFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FORK_FAILED;
			} else if (strcmp (_tmp131_, "Spawn.ChildExited") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_EXITED;
			} else if (strcmp (_tmp131_, "Spawn.ChildSignaled") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_SIGNALED;
			} else if (strcmp (_tmp131_, "Spawn.Failed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FAILED;
			} else if (strcmp (_tmp131_, "UnixProcessIdUnknown") == 0) {
				_ecode = DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN;
			} else if (strcmp (_tmp131_, "InvalidSignature") == 0) {
				_ecode = DBUS_GERROR_INVALID_SIGNATURE;
			} else if (strcmp (_tmp131_, "InvalidFileContent") == 0) {
				_ecode = DBUS_GERROR_INVALID_FILE_CONTENT;
			} else if (strcmp (_tmp131_, "SELinuxSecurityContextUnknown") == 0) {
				_ecode = DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN;
			} else if (strcmp (_tmp131_, "RemoteException") == 0) {
				_ecode = DBUS_GERROR_REMOTE_EXCEPTION;
			}
		}
		g_set_error (error, _edomain, _ecode, "%s", _dbus_error.message);
		dbus_error_free (&_dbus_error);
		return;
	}
	if (strcmp (dbus_message_get_signature (_reply), "")) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_unref (_reply);
}


static void mpris_player_dbus_proxy_Previous (MprisPlayer* self, GError** error) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter;
	if (((MprisPlayerDBusProxy*) self)->disposed) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_DISCONNECTED, "%s", "Connection is closed");
		return;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.mpris.MediaPlayer2.Player", "Previous");
	dbus_message_iter_init_append (_message, &_iter);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		GQuark _edomain;
		gint _ecode;
		if (strstr (_dbus_error.name, "org.freedesktop.DBus.Error") == _dbus_error.name) {
			const char* _tmp132_;
			_edomain = DBUS_GERROR;
			_tmp132_ = _dbus_error.name + 27;
			if (strcmp (_tmp132_, "Failed") == 0) {
				_ecode = DBUS_GERROR_FAILED;
			} else if (strcmp (_tmp132_, "NoMemory") == 0) {
				_ecode = DBUS_GERROR_NO_MEMORY;
			} else if (strcmp (_tmp132_, "ServiceUnknown") == 0) {
				_ecode = DBUS_GERROR_SERVICE_UNKNOWN;
			} else if (strcmp (_tmp132_, "NameHasNoOwner") == 0) {
				_ecode = DBUS_GERROR_NAME_HAS_NO_OWNER;
			} else if (strcmp (_tmp132_, "NoReply") == 0) {
				_ecode = DBUS_GERROR_NO_REPLY;
			} else if (strcmp (_tmp132_, "IOError") == 0) {
				_ecode = DBUS_GERROR_IO_ERROR;
			} else if (strcmp (_tmp132_, "BadAddress") == 0) {
				_ecode = DBUS_GERROR_BAD_ADDRESS;
			} else if (strcmp (_tmp132_, "NotSupported") == 0) {
				_ecode = DBUS_GERROR_NOT_SUPPORTED;
			} else if (strcmp (_tmp132_, "LimitsExceeded") == 0) {
				_ecode = DBUS_GERROR_LIMITS_EXCEEDED;
			} else if (strcmp (_tmp132_, "AccessDenied") == 0) {
				_ecode = DBUS_GERROR_ACCESS_DENIED;
			} else if (strcmp (_tmp132_, "AuthFailed") == 0) {
				_ecode = DBUS_GERROR_AUTH_FAILED;
			} else if (strcmp (_tmp132_, "NoServer") == 0) {
				_ecode = DBUS_GERROR_NO_SERVER;
			} else if (strcmp (_tmp132_, "Timeout") == 0) {
				_ecode = DBUS_GERROR_TIMEOUT;
			} else if (strcmp (_tmp132_, "NoNetwork") == 0) {
				_ecode = DBUS_GERROR_NO_NETWORK;
			} else if (strcmp (_tmp132_, "AddressInUse") == 0) {
				_ecode = DBUS_GERROR_ADDRESS_IN_USE;
			} else if (strcmp (_tmp132_, "Disconnected") == 0) {
				_ecode = DBUS_GERROR_DISCONNECTED;
			} else if (strcmp (_tmp132_, "InvalidArgs") == 0) {
				_ecode = DBUS_GERROR_INVALID_ARGS;
			} else if (strcmp (_tmp132_, "FileNotFound") == 0) {
				_ecode = DBUS_GERROR_FILE_NOT_FOUND;
			} else if (strcmp (_tmp132_, "FileExists") == 0) {
				_ecode = DBUS_GERROR_FILE_EXISTS;
			} else if (strcmp (_tmp132_, "UnknownMethod") == 0) {
				_ecode = DBUS_GERROR_UNKNOWN_METHOD;
			} else if (strcmp (_tmp132_, "TimedOut") == 0) {
				_ecode = DBUS_GERROR_TIMED_OUT;
			} else if (strcmp (_tmp132_, "MatchRuleNotFound") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_NOT_FOUND;
			} else if (strcmp (_tmp132_, "MatchRuleInvalid") == 0) {
				_ecode = DBUS_GERROR_MATCH_RULE_INVALID;
			} else if (strcmp (_tmp132_, "Spawn.ExecFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_EXEC_FAILED;
			} else if (strcmp (_tmp132_, "Spawn.ForkFailed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FORK_FAILED;
			} else if (strcmp (_tmp132_, "Spawn.ChildExited") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_EXITED;
			} else if (strcmp (_tmp132_, "Spawn.ChildSignaled") == 0) {
				_ecode = DBUS_GERROR_SPAWN_CHILD_SIGNALED;
			} else if (strcmp (_tmp132_, "Spawn.Failed") == 0) {
				_ecode = DBUS_GERROR_SPAWN_FAILED;
			} else if (strcmp (_tmp132_, "UnixProcessIdUnknown") == 0) {
				_ecode = DBUS_GERROR_UNIX_PROCESS_ID_UNKNOWN;
			} else if (strcmp (_tmp132_, "InvalidSignature") == 0) {
				_ecode = DBUS_GERROR_INVALID_SIGNATURE;
			} else if (strcmp (_tmp132_, "InvalidFileContent") == 0) {
				_ecode = DBUS_GERROR_INVALID_FILE_CONTENT;
			} else if (strcmp (_tmp132_, "SELinuxSecurityContextUnknown") == 0) {
				_ecode = DBUS_GERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN;
			} else if (strcmp (_tmp132_, "RemoteException") == 0) {
				_ecode = DBUS_GERROR_REMOTE_EXCEPTION;
			}
		}
		g_set_error (error, _edomain, _ecode, "%s", _dbus_error.message);
		dbus_error_free (&_dbus_error);
		return;
	}
	if (strcmp (dbus_message_get_signature (_reply), "")) {
		g_set_error (error, DBUS_GERROR, DBUS_GERROR_INVALID_SIGNATURE, "Invalid signature, expected \"%s\", got \"%s\"", "", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_unref (_reply);
}


static GHashTable* mpris_player_dbus_proxy_get_Metadata (MprisPlayer* self) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp133_;
	const char* _tmp134_;
	GHashTable* _result;
	GHashTable* _tmp135_;
	DBusMessageIter _tmp136_;
	DBusMessageIter _tmp137_;
	if (((MprisPlayerDBusProxy*) self)->disposed) {
		return NULL;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Get");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp133_ = "org.mpris.MediaPlayer2.Player";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp133_);
	_tmp134_ = "Metadata";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp134_);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s)", __FILE__, __LINE__, _dbus_error.message, _dbus_error.name);
		dbus_error_free (&_dbus_error);
		return NULL;
	}
	if (strcmp (dbus_message_get_signature (_reply), "v")) {
		g_critical ("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "v", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return NULL;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_iter_recurse (&_iter, &_subiter);
	if (strcmp (dbus_message_iter_get_signature (&_subiter), "a{sv}")) {
		g_critical ("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "a{sv}", dbus_message_iter_get_signature (&_subiter));
		dbus_message_unref (_reply);
		return NULL;
	}
	_tmp135_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
	dbus_message_iter_recurse (&_subiter, &_tmp136_);
	while (dbus_message_iter_get_arg_type (&_tmp136_)) {
		char* _key;
		GValue* _value;
		const char* _tmp138_;
		GValue _tmp139_ = {0};
		DBusMessageIter _tmp140_;
		dbus_message_iter_recurse (&_tmp136_, &_tmp137_);
		dbus_message_iter_get_basic (&_tmp137_, &_tmp138_);
		dbus_message_iter_next (&_tmp137_);
		_key = g_strdup (_tmp138_);
		dbus_message_iter_recurse (&_tmp137_, &_tmp140_);
		if (dbus_message_iter_get_arg_type (&_tmp140_) == DBUS_TYPE_BYTE) {
			guint8 _tmp141_;
			dbus_message_iter_get_basic (&_tmp140_, &_tmp141_);
			g_value_init (&_tmp139_, G_TYPE_UCHAR);
			g_value_set_uchar (&_tmp139_, _tmp141_);
		} else if (dbus_message_iter_get_arg_type (&_tmp140_) == DBUS_TYPE_BOOLEAN) {
			dbus_bool_t _tmp142_;
			dbus_message_iter_get_basic (&_tmp140_, &_tmp142_);
			g_value_init (&_tmp139_, G_TYPE_BOOLEAN);
			g_value_set_boolean (&_tmp139_, _tmp142_);
		} else if (dbus_message_iter_get_arg_type (&_tmp140_) == DBUS_TYPE_INT16) {
			dbus_int16_t _tmp143_;
			dbus_message_iter_get_basic (&_tmp140_, &_tmp143_);
			g_value_init (&_tmp139_, G_TYPE_INT);
			g_value_set_int (&_tmp139_, _tmp143_);
		} else if (dbus_message_iter_get_arg_type (&_tmp140_) == DBUS_TYPE_UINT16) {
			dbus_uint16_t _tmp144_;
			dbus_message_iter_get_basic (&_tmp140_, &_tmp144_);
			g_value_init (&_tmp139_, G_TYPE_UINT);
			g_value_set_uint (&_tmp139_, _tmp144_);
		} else if (dbus_message_iter_get_arg_type (&_tmp140_) == DBUS_TYPE_INT32) {
			dbus_int32_t _tmp145_;
			dbus_message_iter_get_basic (&_tmp140_, &_tmp145_);
			g_value_init (&_tmp139_, G_TYPE_INT);
			g_value_set_int (&_tmp139_, _tmp145_);
		} else if (dbus_message_iter_get_arg_type (&_tmp140_) == DBUS_TYPE_UINT32) {
			dbus_uint32_t _tmp146_;
			dbus_message_iter_get_basic (&_tmp140_, &_tmp146_);
			g_value_init (&_tmp139_, G_TYPE_UINT);
			g_value_set_uint (&_tmp139_, _tmp146_);
		} else if (dbus_message_iter_get_arg_type (&_tmp140_) == DBUS_TYPE_INT64) {
			dbus_int64_t _tmp147_;
			dbus_message_iter_get_basic (&_tmp140_, &_tmp147_);
			g_value_init (&_tmp139_, G_TYPE_INT64);
			g_value_set_int64 (&_tmp139_, _tmp147_);
		} else if (dbus_message_iter_get_arg_type (&_tmp140_) == DBUS_TYPE_UINT64) {
			dbus_uint64_t _tmp148_;
			dbus_message_iter_get_basic (&_tmp140_, &_tmp148_);
			g_value_init (&_tmp139_, G_TYPE_UINT64);
			g_value_set_uint64 (&_tmp139_, _tmp148_);
		} else if (dbus_message_iter_get_arg_type (&_tmp140_) == DBUS_TYPE_DOUBLE) {
			double _tmp149_;
			dbus_message_iter_get_basic (&_tmp140_, &_tmp149_);
			g_value_init (&_tmp139_, G_TYPE_DOUBLE);
			g_value_set_double (&_tmp139_, _tmp149_);
		} else if (dbus_message_iter_get_arg_type (&_tmp140_) == DBUS_TYPE_STRING) {
			const char* _tmp150_;
			dbus_message_iter_get_basic (&_tmp140_, &_tmp150_);
			g_value_init (&_tmp139_, G_TYPE_STRING);
			g_value_take_string (&_tmp139_, g_strdup (_tmp150_));
		} else if (dbus_message_iter_get_arg_type (&_tmp140_) == DBUS_TYPE_OBJECT_PATH) {
			const char* _tmp151_;
			dbus_message_iter_get_basic (&_tmp140_, &_tmp151_);
			g_value_init (&_tmp139_, G_TYPE_STRING);
			g_value_take_string (&_tmp139_, g_strdup (_tmp151_));
		} else if (dbus_message_iter_get_arg_type (&_tmp140_) == DBUS_TYPE_SIGNATURE) {
			const char* _tmp152_;
			dbus_message_iter_get_basic (&_tmp140_, &_tmp152_);
			g_value_init (&_tmp139_, G_TYPE_STRING);
			g_value_take_string (&_tmp139_, g_strdup (_tmp152_));
		} else if ((dbus_message_iter_get_arg_type (&_tmp140_) == DBUS_TYPE_ARRAY) && (dbus_message_iter_get_element_type (&_tmp140_) == DBUS_TYPE_STRING)) {
			const char** _tmp153_;
			int _tmp153__length;
			int _tmp153__size;
			int _tmp153__length1;
			DBusMessageIter _tmp154_;
			_tmp153_ = g_new (const char*, 5);
			_tmp153__length = 0;
			_tmp153__size = 4;
			_tmp153__length1 = 0;
			dbus_message_iter_recurse (&_tmp140_, &_tmp154_);
			for (; dbus_message_iter_get_arg_type (&_tmp154_); _tmp153__length1++) {
				const char* _tmp155_;
				if (_tmp153__size == _tmp153__length) {
					_tmp153__size = 2 * _tmp153__size;
					_tmp153_ = g_renew (const char*, _tmp153_, _tmp153__size + 1);
				}
				dbus_message_iter_get_basic (&_tmp154_, &_tmp155_);
				dbus_message_iter_next (&_tmp154_);
				_tmp153_[_tmp153__length++] = g_strdup (_tmp155_);
			}
			_tmp153_[_tmp153__length] = NULL;
			g_value_init (&_tmp139_, G_TYPE_STRV);
			g_value_take_boxed (&_tmp139_, _tmp153_);
		}
		dbus_message_iter_next (&_tmp137_);
		_value = g_memdup (&_tmp139_, sizeof (GValue));
		g_hash_table_insert (_tmp135_, _key, _value);
		dbus_message_iter_next (&_tmp136_);
	}
	dbus_message_iter_next (&_subiter);
	_result = _tmp135_;
	dbus_message_unref (_reply);
	return _result;
}


static void mpris_player_dbus_proxy_set_Metadata (MprisPlayer* self, GHashTable* value) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp156_;
	const char* _tmp157_;
	DBusMessageIter _tmp158_, _tmp159_;
	GHashTableIter _tmp160_;
	gpointer _tmp161_, _tmp162_;
	if (((MprisPlayerDBusProxy*) self)->disposed) {
		return;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Set");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp156_ = "org.mpris.MediaPlayer2.Player";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp156_);
	_tmp157_ = "Metadata";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp157_);
	dbus_message_iter_open_container (&_iter, DBUS_TYPE_VARIANT, "a{sv}", &_subiter);
	dbus_message_iter_open_container (&_subiter, DBUS_TYPE_ARRAY, "{sv}", &_tmp158_);
	g_hash_table_iter_init (&_tmp160_, value);
	while (g_hash_table_iter_next (&_tmp160_, &_tmp161_, &_tmp162_)) {
		char* _key;
		GValue* _value;
		const char* _tmp163_;
		DBusMessageIter _tmp164_;
		dbus_message_iter_open_container (&_tmp158_, DBUS_TYPE_DICT_ENTRY, NULL, &_tmp159_);
		_key = (char*) _tmp161_;
		_value = (GValue*) _tmp162_;
		_tmp163_ = _key;
		dbus_message_iter_append_basic (&_tmp159_, DBUS_TYPE_STRING, &_tmp163_);
		if (G_VALUE_TYPE (_value) == G_TYPE_UCHAR) {
			guint8 _tmp165_;
			dbus_message_iter_open_container (&_tmp159_, DBUS_TYPE_VARIANT, "y", &_tmp164_);
			_tmp165_ = g_value_get_uchar (_value);
			dbus_message_iter_append_basic (&_tmp164_, DBUS_TYPE_BYTE, &_tmp165_);
			dbus_message_iter_close_container (&_tmp159_, &_tmp164_);
		} else if (G_VALUE_TYPE (_value) == G_TYPE_BOOLEAN) {
			dbus_bool_t _tmp166_;
			dbus_message_iter_open_container (&_tmp159_, DBUS_TYPE_VARIANT, "b", &_tmp164_);
			_tmp166_ = g_value_get_boolean (_value);
			dbus_message_iter_append_basic (&_tmp164_, DBUS_TYPE_BOOLEAN, &_tmp166_);
			dbus_message_iter_close_container (&_tmp159_, &_tmp164_);
		} else if (G_VALUE_TYPE (_value) == G_TYPE_INT) {
			dbus_int32_t _tmp167_;
			dbus_message_iter_open_container (&_tmp159_, DBUS_TYPE_VARIANT, "i", &_tmp164_);
			_tmp167_ = g_value_get_int (_value);
			dbus_message_iter_append_basic (&_tmp164_, DBUS_TYPE_INT32, &_tmp167_);
			dbus_message_iter_close_container (&_tmp159_, &_tmp164_);
		} else if (G_VALUE_TYPE (_value) == G_TYPE_UINT) {
			dbus_uint32_t _tmp168_;
			dbus_message_iter_open_container (&_tmp159_, DBUS_TYPE_VARIANT, "u", &_tmp164_);
			_tmp168_ = g_value_get_uint (_value);
			dbus_message_iter_append_basic (&_tmp164_, DBUS_TYPE_UINT32, &_tmp168_);
			dbus_message_iter_close_container (&_tmp159_, &_tmp164_);
		} else if (G_VALUE_TYPE (_value) == G_TYPE_INT64) {
			dbus_int64_t _tmp169_;
			dbus_message_iter_open_container (&_tmp159_, DBUS_TYPE_VARIANT, "x", &_tmp164_);
			_tmp169_ = g_value_get_int64 (_value);
			dbus_message_iter_append_basic (&_tmp164_, DBUS_TYPE_INT64, &_tmp169_);
			dbus_message_iter_close_container (&_tmp159_, &_tmp164_);
		} else if (G_VALUE_TYPE (_value) == G_TYPE_UINT64) {
			dbus_uint64_t _tmp170_;
			dbus_message_iter_open_container (&_tmp159_, DBUS_TYPE_VARIANT, "t", &_tmp164_);
			_tmp170_ = g_value_get_uint64 (_value);
			dbus_message_iter_append_basic (&_tmp164_, DBUS_TYPE_UINT64, &_tmp170_);
			dbus_message_iter_close_container (&_tmp159_, &_tmp164_);
		} else if (G_VALUE_TYPE (_value) == G_TYPE_DOUBLE) {
			double _tmp171_;
			dbus_message_iter_open_container (&_tmp159_, DBUS_TYPE_VARIANT, "d", &_tmp164_);
			_tmp171_ = g_value_get_double (_value);
			dbus_message_iter_append_basic (&_tmp164_, DBUS_TYPE_DOUBLE, &_tmp171_);
			dbus_message_iter_close_container (&_tmp159_, &_tmp164_);
		} else if (G_VALUE_TYPE (_value) == G_TYPE_STRING) {
			const char* _tmp172_;
			dbus_message_iter_open_container (&_tmp159_, DBUS_TYPE_VARIANT, "s", &_tmp164_);
			_tmp172_ = g_value_get_string (_value);
			dbus_message_iter_append_basic (&_tmp164_, DBUS_TYPE_STRING, &_tmp172_);
			dbus_message_iter_close_container (&_tmp159_, &_tmp164_);
		} else if (G_VALUE_TYPE (_value) == G_TYPE_STRV) {
			const char** _tmp173_;
			DBusMessageIter _tmp174_;
			int _tmp175_;
			dbus_message_iter_open_container (&_tmp159_, DBUS_TYPE_VARIANT, "as", &_tmp164_);
			_tmp173_ = g_value_get_boxed (_value);
			dbus_message_iter_open_container (&_tmp164_, DBUS_TYPE_ARRAY, "s", &_tmp174_);
			for (_tmp175_ = 0; _tmp175_ < g_strv_length (g_value_get_boxed (_value)); _tmp175_++) {
				const char* _tmp176_;
				_tmp176_ = *_tmp173_;
				dbus_message_iter_append_basic (&_tmp174_, DBUS_TYPE_STRING, &_tmp176_);
				_tmp173_++;
			}
			dbus_message_iter_close_container (&_tmp164_, &_tmp174_);
			dbus_message_iter_close_container (&_tmp159_, &_tmp164_);
		}
		dbus_message_iter_close_container (&_tmp158_, &_tmp159_);
	}
	dbus_message_iter_close_container (&_subiter, &_tmp158_);
	dbus_message_iter_close_container (&_iter, &_subiter);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s)", __FILE__, __LINE__, _dbus_error.message, _dbus_error.name);
		dbus_error_free (&_dbus_error);
		return;
	}
	if (strcmp (dbus_message_get_signature (_reply), "")) {
		g_critical ("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_unref (_reply);
}


static gint32 mpris_player_dbus_proxy_get_Position (MprisPlayer* self) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp177_;
	const char* _tmp178_;
	gint32 _result;
	dbus_int32_t _tmp179_;
	if (((MprisPlayerDBusProxy*) self)->disposed) {
		return 0;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Get");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp177_ = "org.mpris.MediaPlayer2.Player";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp177_);
	_tmp178_ = "Position";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp178_);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s)", __FILE__, __LINE__, _dbus_error.message, _dbus_error.name);
		dbus_error_free (&_dbus_error);
		return 0;
	}
	if (strcmp (dbus_message_get_signature (_reply), "v")) {
		g_critical ("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "v", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return 0;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_iter_recurse (&_iter, &_subiter);
	if (strcmp (dbus_message_iter_get_signature (&_subiter), "i")) {
		g_critical ("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "i", dbus_message_iter_get_signature (&_subiter));
		dbus_message_unref (_reply);
		return 0;
	}
	dbus_message_iter_get_basic (&_subiter, &_tmp179_);
	dbus_message_iter_next (&_subiter);
	_result = _tmp179_;
	dbus_message_unref (_reply);
	return _result;
}


static void mpris_player_dbus_proxy_set_Position (MprisPlayer* self, gint32 value) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp180_;
	const char* _tmp181_;
	dbus_int32_t _tmp182_;
	if (((MprisPlayerDBusProxy*) self)->disposed) {
		return;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Set");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp180_ = "org.mpris.MediaPlayer2.Player";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp180_);
	_tmp181_ = "Position";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp181_);
	dbus_message_iter_open_container (&_iter, DBUS_TYPE_VARIANT, "i", &_subiter);
	_tmp182_ = value;
	dbus_message_iter_append_basic (&_subiter, DBUS_TYPE_INT32, &_tmp182_);
	dbus_message_iter_close_container (&_iter, &_subiter);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s)", __FILE__, __LINE__, _dbus_error.message, _dbus_error.name);
		dbus_error_free (&_dbus_error);
		return;
	}
	if (strcmp (dbus_message_get_signature (_reply), "")) {
		g_critical ("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_unref (_reply);
}


static char* mpris_player_dbus_proxy_get_PlaybackStatus (MprisPlayer* self) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp183_;
	const char* _tmp184_;
	char* _result;
	const char* _tmp185_;
	if (((MprisPlayerDBusProxy*) self)->disposed) {
		return NULL;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Get");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp183_ = "org.mpris.MediaPlayer2.Player";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp183_);
	_tmp184_ = "PlaybackStatus";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp184_);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s)", __FILE__, __LINE__, _dbus_error.message, _dbus_error.name);
		dbus_error_free (&_dbus_error);
		return NULL;
	}
	if (strcmp (dbus_message_get_signature (_reply), "v")) {
		g_critical ("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "v", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return NULL;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_iter_recurse (&_iter, &_subiter);
	if (strcmp (dbus_message_iter_get_signature (&_subiter), "s")) {
		g_critical ("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "s", dbus_message_iter_get_signature (&_subiter));
		dbus_message_unref (_reply);
		return NULL;
	}
	dbus_message_iter_get_basic (&_subiter, &_tmp185_);
	dbus_message_iter_next (&_subiter);
	_result = g_strdup (_tmp185_);
	dbus_message_unref (_reply);
	return _result;
}


static void mpris_player_dbus_proxy_set_PlaybackStatus (MprisPlayer* self, const char* value) {
	DBusError _dbus_error;
	DBusGConnection *_connection;
	DBusMessage *_message, *_reply;
	DBusMessageIter _iter, _subiter;
	const char* _tmp186_;
	const char* _tmp187_;
	const char* _tmp188_;
	if (((MprisPlayerDBusProxy*) self)->disposed) {
		return;
	}
	_message = dbus_message_new_method_call (dbus_g_proxy_get_bus_name ((DBusGProxy*) self), dbus_g_proxy_get_path ((DBusGProxy*) self), "org.freedesktop.DBus.Properties", "Set");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp186_ = "org.mpris.MediaPlayer2.Player";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp186_);
	_tmp187_ = "PlaybackStatus";
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp187_);
	dbus_message_iter_open_container (&_iter, DBUS_TYPE_VARIANT, "s", &_subiter);
	_tmp188_ = value;
	dbus_message_iter_append_basic (&_subiter, DBUS_TYPE_STRING, &_tmp188_);
	dbus_message_iter_close_container (&_iter, &_subiter);
	g_object_get (self, "connection", &_connection, NULL);
	dbus_error_init (&_dbus_error);
	_reply = dbus_connection_send_with_reply_and_block (dbus_g_connection_get_connection (_connection), _message, -1, &_dbus_error);
	dbus_g_connection_unref (_connection);
	dbus_message_unref (_message);
	if (dbus_error_is_set (&_dbus_error)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s)", __FILE__, __LINE__, _dbus_error.message, _dbus_error.name);
		dbus_error_free (&_dbus_error);
		return;
	}
	if (strcmp (dbus_message_get_signature (_reply), "")) {
		g_critical ("file %s: line %d: Invalid signature, expected \"%s\", got \"%s\"", __FILE__, __LINE__, "", dbus_message_get_signature (_reply));
		dbus_message_unref (_reply);
		return;
	}
	dbus_message_iter_init (_reply, &_iter);
	dbus_message_unref (_reply);
}


static void mpris_player_dbus_proxy_mpris_player__interface_init (MprisPlayerIface* iface) {
	iface->SetPosition = mpris_player_dbus_proxy_SetPosition;
	iface->PlayPause = mpris_player_dbus_proxy_PlayPause;
	iface->Pause = mpris_player_dbus_proxy_Pause;
	iface->Next = mpris_player_dbus_proxy_Next;
	iface->Previous = mpris_player_dbus_proxy_Previous;
	iface->get_Metadata = mpris_player_dbus_proxy_get_Metadata;
	iface->set_Metadata = mpris_player_dbus_proxy_set_Metadata;
	iface->get_Position = mpris_player_dbus_proxy_get_Position;
	iface->set_Position = mpris_player_dbus_proxy_set_Position;
	iface->get_PlaybackStatus = mpris_player_dbus_proxy_get_PlaybackStatus;
	iface->set_PlaybackStatus = mpris_player_dbus_proxy_set_PlaybackStatus;
}


static void mpris_player_dbus_proxy_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
}


static void mpris_player_dbus_proxy_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
}


void _free_desktop_properties_dbus_unregister (DBusConnection* connection, void* _user_data_) {
}


static DBusHandlerResult _dbus_free_desktop_properties_introspect (FreeDesktopProperties* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter;
	GString* xml_data;
	char** children;
	int i;
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	xml_data = g_string_new ("<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\" \"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n");
	g_string_append (xml_data, "<node>\n<interface name=\"org.freedesktop.DBus.Introspectable\">\n  <method name=\"Introspect\">\n    <arg name=\"data\" direction=\"out\" type=\"s\"/>\n  </method>\n</interface>\n<interface name=\"org.freedesktop.DBus.Properties\">\n  <method name=\"Get\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"out\" type=\"v\"/>\n  </method>\n  <method name=\"Set\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"in\" type=\"v\"/>\n  </method>\n  <method name=\"GetAll\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"props\" direction=\"out\" type=\"a{sv}\"/>\n  </method>\n</interface>\n<interface name=\"org.freedesktop.DBus.Properties\">\n  <signal name=\"PropertiesChanged\">\n    <arg name=\"source\" type=\"s\"/>\n    <arg name=\"changed_properties\" type=\"a{sv}\"/>\n    <arg name=\"invalid\" type=\"as\"/>\n  </signal>\n</interface>\n");
	dbus_connection_list_registered (connection, g_object_get_data ((GObject *) self, "dbus_object_path"), &children);
	for (i = 0; children[i]; i++) {
		g_string_append_printf (xml_data, "<node name=\"%s\"/>\n", children[i]);
	}
	dbus_free_string_array (children);
	g_string_append (xml_data, "</node>\n");
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &xml_data->str);
	g_string_free (xml_data, TRUE);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_free_desktop_properties_property_get_all (FreeDesktopProperties* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter, reply_iter, subiter;
	char* interface_name;
	const char* _tmp189_;
	if (strcmp (dbus_message_get_signature (message), "s")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &reply_iter);
	dbus_message_iter_get_basic (&iter, &_tmp189_);
	dbus_message_iter_next (&iter);
	interface_name = g_strdup (_tmp189_);
	if (strcmp (interface_name, "org.freedesktop.DBus.Properties") == 0) {
		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_ARRAY, "{sv}", &subiter);
		dbus_message_iter_close_container (&reply_iter, &subiter);
	} else {
		dbus_message_unref (reply);
		reply = NULL;
	}
	g_free (interface_name);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


DBusHandlerResult free_desktop_properties_dbus_message (DBusConnection* connection, DBusMessage* message, void* object) {
	DBusHandlerResult result;
	result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Introspectable", "Introspect")) {
		result = _dbus_free_desktop_properties_introspect (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Properties", "GetAll")) {
		result = _dbus_free_desktop_properties_property_get_all (object, connection, message);
	}
	if (result == DBUS_HANDLER_RESULT_HANDLED) {
		return result;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static void _dbus_free_desktop_properties_properties_changed (GObject* _sender, const char* source, GHashTable* changed_properties, char** invalid, int invalid_length1, DBusConnection* _connection) {
	const char * _path;
	DBusMessage *_message;
	DBusMessageIter _iter;
	const char* _tmp190_;
	DBusMessageIter _tmp191_, _tmp192_;
	GHashTableIter _tmp193_;
	gpointer _tmp194_, _tmp195_;
	char** _tmp210_;
	DBusMessageIter _tmp211_;
	int _tmp212_;
	_path = g_object_get_data (_sender, "dbus_object_path");
	_message = dbus_message_new_signal (_path, "org.freedesktop.DBus.Properties", "PropertiesChanged");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp190_ = source;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp190_);
	dbus_message_iter_open_container (&_iter, DBUS_TYPE_ARRAY, "{sv}", &_tmp191_);
	g_hash_table_iter_init (&_tmp193_, changed_properties);
	while (g_hash_table_iter_next (&_tmp193_, &_tmp194_, &_tmp195_)) {
		char* _key;
		GValue* _value;
		const char* _tmp196_;
		DBusMessageIter _tmp197_;
		dbus_message_iter_open_container (&_tmp191_, DBUS_TYPE_DICT_ENTRY, NULL, &_tmp192_);
		_key = (char*) _tmp194_;
		_value = (GValue*) _tmp195_;
		_tmp196_ = _key;
		dbus_message_iter_append_basic (&_tmp192_, DBUS_TYPE_STRING, &_tmp196_);
		if (G_VALUE_TYPE (_value) == G_TYPE_UCHAR) {
			guint8 _tmp198_;
			dbus_message_iter_open_container (&_tmp192_, DBUS_TYPE_VARIANT, "y", &_tmp197_);
			_tmp198_ = g_value_get_uchar (_value);
			dbus_message_iter_append_basic (&_tmp197_, DBUS_TYPE_BYTE, &_tmp198_);
			dbus_message_iter_close_container (&_tmp192_, &_tmp197_);
		} else if (G_VALUE_TYPE (_value) == G_TYPE_BOOLEAN) {
			dbus_bool_t _tmp199_;
			dbus_message_iter_open_container (&_tmp192_, DBUS_TYPE_VARIANT, "b", &_tmp197_);
			_tmp199_ = g_value_get_boolean (_value);
			dbus_message_iter_append_basic (&_tmp197_, DBUS_TYPE_BOOLEAN, &_tmp199_);
			dbus_message_iter_close_container (&_tmp192_, &_tmp197_);
		} else if (G_VALUE_TYPE (_value) == G_TYPE_INT) {
			dbus_int32_t _tmp200_;
			dbus_message_iter_open_container (&_tmp192_, DBUS_TYPE_VARIANT, "i", &_tmp197_);
			_tmp200_ = g_value_get_int (_value);
			dbus_message_iter_append_basic (&_tmp197_, DBUS_TYPE_INT32, &_tmp200_);
			dbus_message_iter_close_container (&_tmp192_, &_tmp197_);
		} else if (G_VALUE_TYPE (_value) == G_TYPE_UINT) {
			dbus_uint32_t _tmp201_;
			dbus_message_iter_open_container (&_tmp192_, DBUS_TYPE_VARIANT, "u", &_tmp197_);
			_tmp201_ = g_value_get_uint (_value);
			dbus_message_iter_append_basic (&_tmp197_, DBUS_TYPE_UINT32, &_tmp201_);
			dbus_message_iter_close_container (&_tmp192_, &_tmp197_);
		} else if (G_VALUE_TYPE (_value) == G_TYPE_INT64) {
			dbus_int64_t _tmp202_;
			dbus_message_iter_open_container (&_tmp192_, DBUS_TYPE_VARIANT, "x", &_tmp197_);
			_tmp202_ = g_value_get_int64 (_value);
			dbus_message_iter_append_basic (&_tmp197_, DBUS_TYPE_INT64, &_tmp202_);
			dbus_message_iter_close_container (&_tmp192_, &_tmp197_);
		} else if (G_VALUE_TYPE (_value) == G_TYPE_UINT64) {
			dbus_uint64_t _tmp203_;
			dbus_message_iter_open_container (&_tmp192_, DBUS_TYPE_VARIANT, "t", &_tmp197_);
			_tmp203_ = g_value_get_uint64 (_value);
			dbus_message_iter_append_basic (&_tmp197_, DBUS_TYPE_UINT64, &_tmp203_);
			dbus_message_iter_close_container (&_tmp192_, &_tmp197_);
		} else if (G_VALUE_TYPE (_value) == G_TYPE_DOUBLE) {
			double _tmp204_;
			dbus_message_iter_open_container (&_tmp192_, DBUS_TYPE_VARIANT, "d", &_tmp197_);
			_tmp204_ = g_value_get_double (_value);
			dbus_message_iter_append_basic (&_tmp197_, DBUS_TYPE_DOUBLE, &_tmp204_);
			dbus_message_iter_close_container (&_tmp192_, &_tmp197_);
		} else if (G_VALUE_TYPE (_value) == G_TYPE_STRING) {
			const char* _tmp205_;
			dbus_message_iter_open_container (&_tmp192_, DBUS_TYPE_VARIANT, "s", &_tmp197_);
			_tmp205_ = g_value_get_string (_value);
			dbus_message_iter_append_basic (&_tmp197_, DBUS_TYPE_STRING, &_tmp205_);
			dbus_message_iter_close_container (&_tmp192_, &_tmp197_);
		} else if (G_VALUE_TYPE (_value) == G_TYPE_STRV) {
			const char** _tmp206_;
			DBusMessageIter _tmp207_;
			int _tmp208_;
			dbus_message_iter_open_container (&_tmp192_, DBUS_TYPE_VARIANT, "as", &_tmp197_);
			_tmp206_ = g_value_get_boxed (_value);
			dbus_message_iter_open_container (&_tmp197_, DBUS_TYPE_ARRAY, "s", &_tmp207_);
			for (_tmp208_ = 0; _tmp208_ < g_strv_length (g_value_get_boxed (_value)); _tmp208_++) {
				const char* _tmp209_;
				_tmp209_ = *_tmp206_;
				dbus_message_iter_append_basic (&_tmp207_, DBUS_TYPE_STRING, &_tmp209_);
				_tmp206_++;
			}
			dbus_message_iter_close_container (&_tmp197_, &_tmp207_);
			dbus_message_iter_close_container (&_tmp192_, &_tmp197_);
		}
		dbus_message_iter_close_container (&_tmp191_, &_tmp192_);
	}
	dbus_message_iter_close_container (&_iter, &_tmp191_);
	_tmp210_ = invalid;
	dbus_message_iter_open_container (&_iter, DBUS_TYPE_ARRAY, "s", &_tmp211_);
	for (_tmp212_ = 0; _tmp212_ < invalid_length1; _tmp212_++) {
		const char* _tmp213_;
		_tmp213_ = *_tmp210_;
		dbus_message_iter_append_basic (&_tmp211_, DBUS_TYPE_STRING, &_tmp213_);
		_tmp210_++;
	}
	dbus_message_iter_close_container (&_iter, &_tmp211_);
	dbus_connection_send (_connection, _message, NULL);
	dbus_message_unref (_message);
}


void free_desktop_properties_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
	if (!g_object_get_data (object, "dbus_object_path")) {
		g_object_set_data (object, "dbus_object_path", g_strdup (path));
		dbus_connection_register_object_path (connection, path, &_free_desktop_properties_dbus_path_vtable, object);
		g_object_weak_ref (object, _vala_dbus_unregister_object, connection);
	}
	g_signal_connect (object, "properties-changed", (GCallback) _dbus_free_desktop_properties_properties_changed, connection);
}


static void free_desktop_properties_base_init (FreeDesktopPropertiesIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
		g_signal_new ("properties_changed", TYPE_FREE_DESKTOP_PROPERTIES, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_BOXED_BOXED_INT, G_TYPE_NONE, 4, G_TYPE_STRING, G_TYPE_HASH_TABLE, G_TYPE_STRV, G_TYPE_INT);
		g_type_set_qdata (TYPE_FREE_DESKTOP_PROPERTIES, g_quark_from_static_string ("DBusObjectVTable"), (void*) (&_free_desktop_properties_dbus_vtable));
	}
}


GType free_desktop_properties_get_type (void) {
	static volatile gsize free_desktop_properties_type_id__volatile = 0;
	if (g_once_init_enter (&free_desktop_properties_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FreeDesktopPropertiesIface), (GBaseInitFunc) free_desktop_properties_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType free_desktop_properties_type_id;
		free_desktop_properties_type_id = g_type_register_static (G_TYPE_INTERFACE, "FreeDesktopProperties", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (free_desktop_properties_type_id, DBUS_TYPE_G_PROXY);
		g_type_set_qdata (free_desktop_properties_type_id, g_quark_from_string ("ValaDBusInterfaceProxyType"), &free_desktop_properties_dbus_proxy_get_type);
		g_once_init_leave (&free_desktop_properties_type_id__volatile, free_desktop_properties_type_id);
	}
	return free_desktop_properties_type_id__volatile;
}


G_DEFINE_TYPE_EXTENDED (FreeDesktopPropertiesDBusProxy, free_desktop_properties_dbus_proxy, DBUS_TYPE_G_PROXY, 0, G_IMPLEMENT_INTERFACE (TYPE_FREE_DESKTOP_PROPERTIES, free_desktop_properties_dbus_proxy_free_desktop_properties__interface_init) );
FreeDesktopProperties* free_desktop_properties_dbus_proxy_new (DBusGConnection* connection, const char* name, const char* path) {
	FreeDesktopProperties* self;
	self = g_object_new (free_desktop_properties_dbus_proxy_get_type (), "connection", connection, "name", name, "path", path, "interface", "org.freedesktop.DBus.Properties", NULL);
	return self;
}


static GObject* free_desktop_properties_dbus_proxy_construct (GType gtype, guint n_properties, GObjectConstructParam* properties) {
	GObject* self;
	DBusGConnection *connection;
	char* path;
	char* filter;
	self = G_OBJECT_CLASS (free_desktop_properties_dbus_proxy_parent_class)->constructor (gtype, n_properties, properties);
	g_object_get (self, "connection", &connection, NULL);
	g_object_get (self, "path", &path, NULL);
	dbus_connection_add_filter (dbus_g_connection_get_connection (connection), free_desktop_properties_dbus_proxy_filter, self, NULL);
	filter = g_strdup_printf ("type='signal',path='%s'", path);
	dbus_bus_add_match (dbus_g_connection_get_connection (connection), filter, NULL);
	dbus_g_connection_unref (connection);
	g_free (path);
	g_free (filter);
	return self;
}


static void _dbus_handle_free_desktop_properties_properties_changed (FreeDesktopProperties* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	char* source = NULL;
	const char* _tmp214_;
	GHashTable* changed_properties = NULL;
	GHashTable* _tmp215_;
	DBusMessageIter _tmp216_;
	DBusMessageIter _tmp217_;
	char** invalid = NULL;
	int invalid_length1;
	char** _tmp236_;
	int _tmp236__length;
	int _tmp236__size;
	int _tmp236__length1;
	DBusMessageIter _tmp237_;
	DBusMessage* reply;
	if (strcmp (dbus_message_get_signature (message), "sa{sv}as")) {
		return;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp214_);
	dbus_message_iter_next (&iter);
	source = g_strdup (_tmp214_);
	_tmp215_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
	dbus_message_iter_recurse (&iter, &_tmp216_);
	while (dbus_message_iter_get_arg_type (&_tmp216_)) {
		char* _key;
		GValue* _value;
		const char* _tmp218_;
		GValue _tmp219_ = {0};
		DBusMessageIter _tmp220_;
		dbus_message_iter_recurse (&_tmp216_, &_tmp217_);
		dbus_message_iter_get_basic (&_tmp217_, &_tmp218_);
		dbus_message_iter_next (&_tmp217_);
		_key = g_strdup (_tmp218_);
		dbus_message_iter_recurse (&_tmp217_, &_tmp220_);
		if (dbus_message_iter_get_arg_type (&_tmp220_) == DBUS_TYPE_BYTE) {
			guint8 _tmp221_;
			dbus_message_iter_get_basic (&_tmp220_, &_tmp221_);
			g_value_init (&_tmp219_, G_TYPE_UCHAR);
			g_value_set_uchar (&_tmp219_, _tmp221_);
		} else if (dbus_message_iter_get_arg_type (&_tmp220_) == DBUS_TYPE_BOOLEAN) {
			dbus_bool_t _tmp222_;
			dbus_message_iter_get_basic (&_tmp220_, &_tmp222_);
			g_value_init (&_tmp219_, G_TYPE_BOOLEAN);
			g_value_set_boolean (&_tmp219_, _tmp222_);
		} else if (dbus_message_iter_get_arg_type (&_tmp220_) == DBUS_TYPE_INT16) {
			dbus_int16_t _tmp223_;
			dbus_message_iter_get_basic (&_tmp220_, &_tmp223_);
			g_value_init (&_tmp219_, G_TYPE_INT);
			g_value_set_int (&_tmp219_, _tmp223_);
		} else if (dbus_message_iter_get_arg_type (&_tmp220_) == DBUS_TYPE_UINT16) {
			dbus_uint16_t _tmp224_;
			dbus_message_iter_get_basic (&_tmp220_, &_tmp224_);
			g_value_init (&_tmp219_, G_TYPE_UINT);
			g_value_set_uint (&_tmp219_, _tmp224_);
		} else if (dbus_message_iter_get_arg_type (&_tmp220_) == DBUS_TYPE_INT32) {
			dbus_int32_t _tmp225_;
			dbus_message_iter_get_basic (&_tmp220_, &_tmp225_);
			g_value_init (&_tmp219_, G_TYPE_INT);
			g_value_set_int (&_tmp219_, _tmp225_);
		} else if (dbus_message_iter_get_arg_type (&_tmp220_) == DBUS_TYPE_UINT32) {
			dbus_uint32_t _tmp226_;
			dbus_message_iter_get_basic (&_tmp220_, &_tmp226_);
			g_value_init (&_tmp219_, G_TYPE_UINT);
			g_value_set_uint (&_tmp219_, _tmp226_);
		} else if (dbus_message_iter_get_arg_type (&_tmp220_) == DBUS_TYPE_INT64) {
			dbus_int64_t _tmp227_;
			dbus_message_iter_get_basic (&_tmp220_, &_tmp227_);
			g_value_init (&_tmp219_, G_TYPE_INT64);
			g_value_set_int64 (&_tmp219_, _tmp227_);
		} else if (dbus_message_iter_get_arg_type (&_tmp220_) == DBUS_TYPE_UINT64) {
			dbus_uint64_t _tmp228_;
			dbus_message_iter_get_basic (&_tmp220_, &_tmp228_);
			g_value_init (&_tmp219_, G_TYPE_UINT64);
			g_value_set_uint64 (&_tmp219_, _tmp228_);
		} else if (dbus_message_iter_get_arg_type (&_tmp220_) == DBUS_TYPE_DOUBLE) {
			double _tmp229_;
			dbus_message_iter_get_basic (&_tmp220_, &_tmp229_);
			g_value_init (&_tmp219_, G_TYPE_DOUBLE);
			g_value_set_double (&_tmp219_, _tmp229_);
		} else if (dbus_message_iter_get_arg_type (&_tmp220_) == DBUS_TYPE_STRING) {
			const char* _tmp230_;
			dbus_message_iter_get_basic (&_tmp220_, &_tmp230_);
			g_value_init (&_tmp219_, G_TYPE_STRING);
			g_value_take_string (&_tmp219_, g_strdup (_tmp230_));
		} else if (dbus_message_iter_get_arg_type (&_tmp220_) == DBUS_TYPE_OBJECT_PATH) {
			const char* _tmp231_;
			dbus_message_iter_get_basic (&_tmp220_, &_tmp231_);
			g_value_init (&_tmp219_, G_TYPE_STRING);
			g_value_take_string (&_tmp219_, g_strdup (_tmp231_));
		} else if (dbus_message_iter_get_arg_type (&_tmp220_) == DBUS_TYPE_SIGNATURE) {
			const char* _tmp232_;
			dbus_message_iter_get_basic (&_tmp220_, &_tmp232_);
			g_value_init (&_tmp219_, G_TYPE_STRING);
			g_value_take_string (&_tmp219_, g_strdup (_tmp232_));
		} else if ((dbus_message_iter_get_arg_type (&_tmp220_) == DBUS_TYPE_ARRAY) && (dbus_message_iter_get_element_type (&_tmp220_) == DBUS_TYPE_STRING)) {
			const char** _tmp233_;
			int _tmp233__length;
			int _tmp233__size;
			int _tmp233__length1;
			DBusMessageIter _tmp234_;
			_tmp233_ = g_new (const char*, 5);
			_tmp233__length = 0;
			_tmp233__size = 4;
			_tmp233__length1 = 0;
			dbus_message_iter_recurse (&_tmp220_, &_tmp234_);
			for (; dbus_message_iter_get_arg_type (&_tmp234_); _tmp233__length1++) {
				const char* _tmp235_;
				if (_tmp233__size == _tmp233__length) {
					_tmp233__size = 2 * _tmp233__size;
					_tmp233_ = g_renew (const char*, _tmp233_, _tmp233__size + 1);
				}
				dbus_message_iter_get_basic (&_tmp234_, &_tmp235_);
				dbus_message_iter_next (&_tmp234_);
				_tmp233_[_tmp233__length++] = g_strdup (_tmp235_);
			}
			_tmp233_[_tmp233__length] = NULL;
			g_value_init (&_tmp219_, G_TYPE_STRV);
			g_value_take_boxed (&_tmp219_, _tmp233_);
		}
		dbus_message_iter_next (&_tmp217_);
		_value = g_memdup (&_tmp219_, sizeof (GValue));
		g_hash_table_insert (_tmp215_, _key, _value);
		dbus_message_iter_next (&_tmp216_);
	}
	dbus_message_iter_next (&iter);
	changed_properties = _tmp215_;
	invalid_length1 = 0;
	_tmp236_ = g_new (char*, 5);
	_tmp236__length = 0;
	_tmp236__size = 4;
	_tmp236__length1 = 0;
	dbus_message_iter_recurse (&iter, &_tmp237_);
	for (; dbus_message_iter_get_arg_type (&_tmp237_); _tmp236__length1++) {
		const char* _tmp238_;
		if (_tmp236__size == _tmp236__length) {
			_tmp236__size = 2 * _tmp236__size;
			_tmp236_ = g_renew (char*, _tmp236_, _tmp236__size + 1);
		}
		dbus_message_iter_get_basic (&_tmp237_, &_tmp238_);
		dbus_message_iter_next (&_tmp237_);
		_tmp236_[_tmp236__length++] = g_strdup (_tmp238_);
	}
	invalid_length1 = _tmp236__length1;
	_tmp236_[_tmp236__length] = NULL;
	dbus_message_iter_next (&iter);
	invalid = _tmp236_;
	g_signal_emit_by_name (self, "properties-changed", source, changed_properties, invalid, invalid_length1);
	_g_free0 (source);
	_g_hash_table_unref0 (changed_properties);
	invalid = (_vala_array_free (invalid, invalid_length1, (GDestroyNotify) g_free), NULL);
}


DBusHandlerResult free_desktop_properties_dbus_proxy_filter (DBusConnection* connection, DBusMessage* message, void* user_data) {
	if (dbus_message_has_path (message, dbus_g_proxy_get_path (user_data))) {
		if (dbus_message_is_signal (message, "org.freedesktop.DBus.Properties", "PropertiesChanged")) {
			_dbus_handle_free_desktop_properties_properties_changed (user_data, connection, message);
		}
	}
	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
}


static void free_desktop_properties_dbus_proxy_dispose (GObject* self) {
	DBusGConnection *connection;
	if (((FreeDesktopPropertiesDBusProxy*) self)->disposed) {
		return;
	}
	((FreeDesktopPropertiesDBusProxy*) self)->disposed = TRUE;
	g_object_get (self, "connection", &connection, NULL);
	dbus_connection_remove_filter (dbus_g_connection_get_connection (connection), free_desktop_properties_dbus_proxy_filter, self);
	G_OBJECT_CLASS (free_desktop_properties_dbus_proxy_parent_class)->dispose (self);
}


static void free_desktop_properties_dbus_proxy_class_init (FreeDesktopPropertiesDBusProxyClass* klass) {
	G_OBJECT_CLASS (klass)->constructor = free_desktop_properties_dbus_proxy_construct;
	G_OBJECT_CLASS (klass)->dispose = free_desktop_properties_dbus_proxy_dispose;
	G_OBJECT_CLASS (klass)->get_property = free_desktop_properties_dbus_proxy_get_property;
	G_OBJECT_CLASS (klass)->set_property = free_desktop_properties_dbus_proxy_set_property;
}


static void free_desktop_properties_dbus_proxy_init (FreeDesktopPropertiesDBusProxy* self) {
}


static void free_desktop_properties_dbus_proxy_free_desktop_properties__interface_init (FreeDesktopPropertiesIface* iface) {
}


static void free_desktop_properties_dbus_proxy_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
}


static void free_desktop_properties_dbus_proxy_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
}


Mpris2Controller* mpris2_controller_construct (GType object_type, PlayerController* ctrl) {
	Mpris2Controller * self;
	g_return_val_if_fail (ctrl != NULL, NULL);
	self = (Mpris2Controller*) g_object_new (object_type, "owner", ctrl, NULL);
	return self;
}


Mpris2Controller* mpris2_controller_new (PlayerController* ctrl) {
	return mpris2_controller_construct (TYPE_MPRIS2_CONTROLLER, ctrl);
}


static GValue* _g_value_dup (GValue* self) {
	return g_boxed_copy (G_TYPE_VALUE, self);
}


static gpointer __g_value_dup0 (gpointer self) {
	return self ? _g_value_dup (self) : NULL;
}


void mpris2_controller_property_changed_cb (Mpris2Controller* self, const char* interface_source, GHashTable* changed_properties, char** invalid, int invalid_length1) {
	gboolean _tmp0_ = FALSE;
	GValue* play_v;
	GValue* pos_v;
	GValue* meta_v;
	g_return_if_fail (self != NULL);
	g_return_if_fail (interface_source != NULL);
	g_return_if_fail (changed_properties != NULL);
	g_debug ("mpris2-controller.vala:98: properties-changed for interface %s", interface_source);
	if (changed_properties == NULL) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = g_str_has_prefix (interface_source, MPRIS2_CONTROLLER_root_interface) == FALSE;
	}
	if (_tmp0_) {
		g_warning ("mpris2-controller.vala:100: Property-changed hash is null or this is a" \
"n interface that concerns us");
		return;
	}
	play_v = __g_value_dup0 ((GValue*) g_hash_table_lookup (changed_properties, "PlaybackStatus"));
	if (play_v != NULL) {
		char* state;
		gint p;
		TransportMenuitem* _tmp2_;
		PlayerItem* _tmp1_;
		ScrubMenuitem* _tmp4_;
		PlayerItem* _tmp3_;
		state = g_strdup (g_value_get_string (play_v));
		g_debug ("mpris2-controller.vala:106: new playback state = %s", state);
		p = mpris2_controller_determine_play_state (self, state);
		transport_menuitem_change_play_state (_tmp2_ = (_tmp1_ = (PlayerItem*) gee_abstract_list_get ((GeeAbstractList*) self->priv->_owner->custom_items, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_TRANSPORT), IS_TRANSPORT_MENUITEM (_tmp1_) ? ((TransportMenuitem*) _tmp1_) : NULL), p);
		_g_object_unref0 (_tmp2_);
		scrub_menuitem_update_playstate (_tmp4_ = (_tmp3_ = (PlayerItem*) gee_abstract_list_get ((GeeAbstractList*) self->priv->_owner->custom_items, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_SCRUB), IS_SCRUB_MENUITEM (_tmp3_) ? ((ScrubMenuitem*) _tmp3_) : NULL), p);
		_g_object_unref0 (_tmp4_);
		_g_free0 (state);
	}
	pos_v = __g_value_dup0 ((GValue*) g_hash_table_lookup (changed_properties, "Position"));
	if (pos_v != NULL) {
		gint64 pos;
		ScrubMenuitem* _tmp6_;
		PlayerItem* _tmp5_;
		pos = g_value_get_int64 (pos_v);
		g_debug ("mpris2-controller.vala:115: new position = %i", (gint) pos);
		scrub_menuitem_update_position (_tmp6_ = (_tmp5_ = (PlayerItem*) gee_abstract_list_get ((GeeAbstractList*) self->priv->_owner->custom_items, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_SCRUB), IS_SCRUB_MENUITEM (_tmp5_) ? ((ScrubMenuitem*) _tmp5_) : NULL), (gint32) pos);
		_g_object_unref0 (_tmp6_);
	}
	meta_v = __g_value_dup0 ((GValue*) g_hash_table_lookup (changed_properties, "Metadata"));
	if (meta_v != NULL) {
		GHashTable* _tmp7_;
		GeeHashSet* _tmp9_;
		PlayerItem* _tmp8_;
		GeeHashSet* _tmp12_;
		GHashTable* _tmp11_;
		PlayerItem* _tmp10_;
		GeeHashSet* _tmp14_;
		PlayerItem* _tmp13_;
		gboolean _tmp15_ = FALSE;
		GHashTable* _tmp16_;
		gboolean _tmp17_;
		char* _tmp24_;
		ScrubMenuitem* _tmp23_;
		PlayerItem* _tmp22_;
		g_debug ("mpris2-controller.vala:121: metadata is not empty");
		g_debug ("mpris2-controller.vala:122: artist : %s", g_value_get_string ((GValue*) g_hash_table_lookup (_tmp7_ = mpris_player_get_Metadata (self->priv->_player), "artist")));
		_g_hash_table_unref0 (_tmp7_);
		player_item_reset (_tmp8_ = (PlayerItem*) gee_abstract_list_get ((GeeAbstractList*) self->priv->_owner->custom_items, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_METADATA), _tmp9_ = metadata_menuitem_attributes_format ());
		_g_object_unref0 (_tmp9_);
		_g_object_unref0 (_tmp8_);
		player_item_update (_tmp10_ = (PlayerItem*) gee_abstract_list_get ((GeeAbstractList*) self->priv->_owner->custom_items, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_METADATA), _tmp11_ = mpris_player_get_Metadata (self->priv->_player), _tmp12_ = metadata_menuitem_attributes_format ());
		_g_object_unref0 (_tmp12_);
		_g_hash_table_unref0 (_tmp11_);
		_g_object_unref0 (_tmp10_);
		player_item_reset (_tmp13_ = (PlayerItem*) gee_abstract_list_get ((GeeAbstractList*) self->priv->_owner->custom_items, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_SCRUB), _tmp14_ = scrub_menuitem_attributes_format ());
		_g_object_unref0 (_tmp14_);
		_g_object_unref0 (_tmp13_);
		if ((_tmp17_ = ((gint) g_utf8_strlen (g_value_get_string ((GValue*) g_hash_table_lookup (_tmp16_ = mpris_player_get_Metadata (self->priv->_player), "artist")), -1)) > 0, _g_hash_table_unref0 (_tmp16_), _tmp17_)) {
			_tmp15_ = TRUE;
		} else {
			GHashTable* _tmp18_;
			_tmp15_ = ((gint) g_utf8_strlen (g_value_get_string ((GValue*) g_hash_table_lookup (_tmp18_ = mpris_player_get_Metadata (self->priv->_player), "artist")), -1)) > 0;
			_g_hash_table_unref0 (_tmp18_);
		}
		if (_tmp15_) {
			GeeHashSet* _tmp21_;
			GHashTable* _tmp20_;
			PlayerItem* _tmp19_;
			player_item_update (_tmp19_ = (PlayerItem*) gee_abstract_list_get ((GeeAbstractList*) self->priv->_owner->custom_items, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_SCRUB), _tmp20_ = mpris_player_get_Metadata (self->priv->_player), _tmp21_ = scrub_menuitem_attributes_format ());
			_g_object_unref0 (_tmp21_);
			_g_hash_table_unref0 (_tmp20_);
			_g_object_unref0 (_tmp19_);
		}
		scrub_menuitem_update_playstate (_tmp23_ = (_tmp22_ = (PlayerItem*) gee_abstract_list_get ((GeeAbstractList*) self->priv->_owner->custom_items, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_SCRUB), IS_SCRUB_MENUITEM (_tmp22_) ? ((ScrubMenuitem*) _tmp22_) : NULL), mpris2_controller_determine_play_state (self, _tmp24_ = mpris_player_get_PlaybackStatus (self->priv->_player)));
		_g_free0 (_tmp24_);
		_g_object_unref0 (_tmp23_);
	}
	_g_free0 (meta_v);
	_g_free0 (pos_v);
	_g_free0 (play_v);
}


static gint mpris2_controller_determine_play_state (Mpris2Controller* self, const char* status) {
	gint result = 0;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (status != NULL, 0);
	if (status == NULL) {
		result = 1;
		return result;
	}
	if (status != NULL) {
		_tmp0_ = _vala_strcmp0 (status, "Playing") == 0;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		g_debug ("mpris2-controller.vala:142: determine play state - state = %s", status);
		result = 0;
		return result;
	}
	result = 1;
	return result;
}


void mpris2_controller_initial_update (Mpris2Controller* self) {
	gint32 status = 0;
	char* _tmp0_;
	gboolean _tmp1_;
	TransportMenuitem* _tmp4_;
	PlayerItem* _tmp3_;
	GeeHashSet* _tmp7_;
	GHashTable* _tmp6_;
	PlayerItem* _tmp5_;
	GeeHashSet* _tmp10_;
	GHashTable* _tmp9_;
	PlayerItem* _tmp8_;
	g_return_if_fail (self != NULL);
	if ((_tmp1_ = (_tmp0_ = mpris_player_get_PlaybackStatus (self->priv->_player)) == NULL, _g_free0 (_tmp0_), _tmp1_)) {
		status = (gint32) 1;
	} else {
		char* _tmp2_;
		status = (gint32) mpris2_controller_determine_play_state (self, _tmp2_ = mpris_player_get_PlaybackStatus (self->priv->_player));
		_g_free0 (_tmp2_);
	}
	g_debug ("mpris2-controller.vala:157: initial update - play state %i", (gint) status);
	transport_menuitem_change_play_state (_tmp4_ = (_tmp3_ = (PlayerItem*) gee_abstract_list_get ((GeeAbstractList*) self->priv->_owner->custom_items, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_TRANSPORT), IS_TRANSPORT_MENUITEM (_tmp3_) ? ((TransportMenuitem*) _tmp3_) : NULL), (gint) status);
	_g_object_unref0 (_tmp4_);
	player_item_update (_tmp5_ = (PlayerItem*) gee_abstract_list_get ((GeeAbstractList*) self->priv->_owner->custom_items, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_METADATA), _tmp6_ = mpris_player_get_Metadata (self->priv->_player), _tmp7_ = metadata_menuitem_attributes_format ());
	_g_object_unref0 (_tmp7_);
	_g_hash_table_unref0 (_tmp6_);
	_g_object_unref0 (_tmp5_);
	player_item_update (_tmp8_ = (PlayerItem*) gee_abstract_list_get ((GeeAbstractList*) self->priv->_owner->custom_items, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_SCRUB), _tmp9_ = mpris_player_get_Metadata (self->priv->_player), _tmp10_ = scrub_menuitem_attributes_format ());
	_g_object_unref0 (_tmp10_);
	_g_hash_table_unref0 (_tmp9_);
	_g_object_unref0 (_tmp8_);
}


void mpris2_controller_transport_event (Mpris2Controller* self, TransportMenuitemaction command) {
	GError * _inner_error_;
	g_return_if_fail (self != NULL);
	_inner_error_ = NULL;
	g_debug ("mpris2-controller.vala:168: transport_event input = %i", (gint) command);
	if (command == TRANSPORT_MENUITEM_ACTION_PLAY_PAUSE) {
		g_debug ("mpris2-controller.vala:170: transport_event PLAY_PAUSE");
		{
			mpris_player_PlayPause (self->priv->_player, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == DBUS_GERROR) {
					goto __catch2_dbus_gerror;
				}
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
		goto __finally2;
		__catch2_dbus_gerror:
		{
			GError * _error_;
			_error_ = _inner_error_;
			_inner_error_ = NULL;
			{
				g_warning ("mpris2-controller.vala:175: DBus Error calling the player objects Play" \
"Pause method %s", _error_->message);
				_g_error_free0 (_error_);
			}
		}
		__finally2:
		if (_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	} else {
		if (command == TRANSPORT_MENUITEM_ACTION_PREVIOUS) {
			{
				mpris_player_Previous (self->priv->_player, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == DBUS_GERROR) {
						goto __catch3_dbus_gerror;
					}
					g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
			goto __finally3;
			__catch3_dbus_gerror:
			{
				GError * _error_;
				_error_ = _inner_error_;
				_inner_error_ = NULL;
				{
					g_warning ("mpris2-controller.vala:184: DBus Error calling the player objects Prev" \
"ious method %s", _error_->message);
					_g_error_free0 (_error_);
				}
			}
			__finally3:
			if (_inner_error_ != NULL) {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		} else {
			if (command == TRANSPORT_MENUITEM_ACTION_NEXT) {
				{
					mpris_player_Next (self->priv->_player, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == DBUS_GERROR) {
							goto __catch4_dbus_gerror;
						}
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
				goto __finally4;
				__catch4_dbus_gerror:
				{
					GError * _error_;
					_error_ = _inner_error_;
					_inner_error_ = NULL;
					{
						g_warning ("mpris2-controller.vala:193: DBus Error calling the player objects Next" \
" method %s", _error_->message);
						_g_error_free0 (_error_);
					}
				}
				__finally4:
				if (_inner_error_ != NULL) {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
		}
	}
}


/**
TODO: SetPosition on the player object is not working with rhythmbox,
  runtime error - "dbus function not supported"
 */
void mpris2_controller_set_position (Mpris2Controller* self, double position) {
	GError * _inner_error_;
	GHashTable* data;
	GValue* time_value;
	guint32 total_time;
	double new_time_position;
	GHashTable* _tmp0_;
	GValue* _tmp1_;
	GValue* v;
	g_return_if_fail (self != NULL);
	_inner_error_ = NULL;
	g_debug ("mpris2-controller.vala:204: Set position with pos (0-100) %f", position);
	data = mpris_player_get_Metadata (self->priv->_player);
	time_value = __g_value_dup0 ((GValue*) g_hash_table_lookup (data, "time"));
	if (time_value == NULL) {
		g_warning ("mpris2-controller.vala:208: Can't fetch the duration of the track ther" \
"efore cant set the position");
		_g_free0 (time_value);
		_g_hash_table_unref0 (data);
		return;
	}
	total_time = (guint32) (g_value_get_uint (time_value) * 1000);
	g_debug ("mpris2-controller.vala:213: total time of track = %i", (gint) total_time);
	new_time_position = (total_time * position) / 100.0;
	g_debug ("mpris2-controller.vala:215: new position = %f", new_time_position);
	v = (_tmp1_ = __g_value_dup0 ((GValue*) g_hash_table_lookup (_tmp0_ = mpris_player_get_Metadata (self->priv->_player), "trackid")), _g_hash_table_unref0 (_tmp0_), _tmp1_);
	if (v != NULL) {
		if (G_VALUE_HOLDS (v, G_TYPE_STRING)) {
			char* path;
			g_debug ("mpris2-controller.vala:220: the trackid = %s", g_value_get_string (v));
			path = g_strdup (g_value_get_string (v));
			{
			}
			goto __finally5;
			__catch5_dbus_gerror:
			{
				GError * e;
				e = _inner_error_;
				_inner_error_ = NULL;
				{
					g_error ("mpris2-controller.vala:226: DBus Error calling the player objects SetP" \
"osition method %s", e->message);
					_g_error_free0 (e);
				}
			}
			__finally5:
			if (_inner_error_ != NULL) {
				_g_free0 (path);
				_g_free0 (v);
				_g_free0 (time_value);
				_g_hash_table_unref0 (data);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
			_g_free0 (path);
		}
	}
	_g_free0 (v);
	_g_free0 (time_value);
	_g_hash_table_unref0 (data);
}


void mpris2_controller_onSeeked (Mpris2Controller* self, gint64 position) {
	PlayerItem* _tmp0_;
	ScrubMenuitem* scrub;
	g_return_if_fail (self != NULL);
	g_debug ("mpris2-controller.vala:234: Seeked signal callback with pos = %i", ((gint) position) / 1000);
	scrub = (_tmp0_ = (PlayerItem*) gee_abstract_list_get ((GeeAbstractList*) self->priv->_owner->custom_items, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_SCRUB), IS_SCRUB_MENUITEM (_tmp0_) ? ((ScrubMenuitem*) _tmp0_) : NULL);
	scrub_menuitem_update_position (scrub, ((gint32) position) / 1000);
	_g_object_unref0 (scrub);
}


gboolean mpris2_controller_connected (Mpris2Controller* self) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	if (self->priv->_player != NULL) {
		_tmp0_ = self->priv->_mpris2_root != NULL;
	} else {
		_tmp0_ = FALSE;
	}
	result = _tmp0_;
	return result;
}


gboolean mpris2_controller_was_successfull (Mpris2Controller* self) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	if (self->priv->_mpris2_root == NULL) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = self->priv->_player == NULL;
	}
	if (_tmp0_) {
		result = FALSE;
		return result;
	}
	result = TRUE;
	return result;
}


void mpris2_controller_expose (Mpris2Controller* self) {
	GError * _inner_error_;
	g_return_if_fail (self != NULL);
	_inner_error_ = NULL;
	if (mpris2_controller_connected (self) == TRUE) {
		{
			mpris_root_Raise (self->priv->_mpris2_root, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == DBUS_GERROR) {
					goto __catch6_dbus_gerror;
				}
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
		goto __finally6;
		__catch6_dbus_gerror:
		{
			GError * e;
			e = _inner_error_;
			_inner_error_ = NULL;
			{
				g_error ("mpris2-controller.vala:259: Exception thrown while calling root functi" \
"on Raise - %s", e->message);
				_g_error_free0 (e);
			}
		}
		__finally6:
		if (_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
}


MprisRoot* mpris2_controller_get_mpris2_root (Mpris2Controller* self) {
	MprisRoot* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_mpris2_root;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void mpris2_controller_set_mpris2_root (Mpris2Controller* self, MprisRoot* value) {
	MprisRoot* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_mpris2_root = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_mpris2_root), _tmp0_);
	g_object_notify ((GObject *) self, "mpris2-root");
}


MprisPlayer* mpris2_controller_get_player (Mpris2Controller* self) {
	MprisPlayer* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_player;
	return result;
}


static void mpris2_controller_set_player (Mpris2Controller* self, MprisPlayer* value) {
	MprisPlayer* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_player = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_player), _tmp0_);
	g_object_notify ((GObject *) self, "player");
}


PlayerController* mpris2_controller_get_owner (Mpris2Controller* self) {
	PlayerController* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_owner;
	return result;
}


static void mpris2_controller_set_owner (Mpris2Controller* self, PlayerController* value) {
	PlayerController* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_owner = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_owner), _tmp0_);
	g_object_notify ((GObject *) self, "owner");
}


FreeDesktopProperties* mpris2_controller_get_properties_interface (Mpris2Controller* self) {
	FreeDesktopProperties* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_properties_interface;
	return result;
}


static void mpris2_controller_set_properties_interface (Mpris2Controller* self, FreeDesktopProperties* value) {
	FreeDesktopProperties* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_properties_interface = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_properties_interface), _tmp0_);
	g_object_notify ((GObject *) self, "properties-interface");
}


static void _mpris2_controller_onSeeked_mpris_player_seeked (MprisPlayer* _sender, gint64 new_position, gpointer self) {
	mpris2_controller_onSeeked (self, new_position);
}


static void _mpris2_controller_property_changed_cb_free_desktop_properties_properties_changed (FreeDesktopProperties* _sender, const char* source, GHashTable* changed_properties, char** invalid, int invalid_length1, gpointer self) {
	mpris2_controller_property_changed_cb (self, source, changed_properties, invalid, invalid_length1);
}


static GObject * mpris2_controller_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	Mpris2Controller * self;
	GError * _inner_error_;
	parent_class = G_OBJECT_CLASS (mpris2_controller_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = MPRIS2_CONTROLLER (obj);
	_inner_error_ = NULL;
	{
		{
			DBusGConnection* connection;
			MprisRoot* _tmp245_;
			char* _tmp244_;
			char* _tmp243_;
			char* _tmp242_;
			char* _tmp241_;
			char* _tmp240_;
			char* _tmp239_;
			MprisPlayer* _tmp253_;
			char* _tmp252_;
			char* _tmp251_;
			char* _tmp250_;
			char* _tmp249_;
			char* _tmp248_;
			char* _tmp247_;
			char* _tmp246_;
			FreeDesktopProperties* _tmp260_;
			char* _tmp259_;
			char* _tmp258_;
			char* _tmp257_;
			char* _tmp256_;
			char* _tmp255_;
			char* _tmp254_;
			connection = dbus_g_bus_get (DBUS_BUS_SESSION, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == DBUS_GERROR) {
					goto __catch7_dbus_gerror;
				}
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
			}
			mpris2_controller_set_mpris2_root (self, _tmp245_ = mpris_root_dbus_proxy_new (connection, _tmp244_ = g_strconcat (_tmp242_ = g_strconcat (MPRIS2_CONTROLLER_root_interface, ".", NULL), _tmp243_ = g_utf8_strdown (player_controller_get_name (self->priv->_owner), -1), NULL), "/org/mpris/MediaPlayer2"));
			_g_object_unref0 (_tmp245_);
			_g_free0 (_tmp244_);
			_g_free0 (_tmp243_);
			_g_free0 (_tmp242_);
			_g_free0 (_tmp241_);
			_g_free0 (_tmp240_);
			_g_free0 (_tmp239_);
			mpris2_controller_set_player (self, _tmp253_ = mpris_player_dbus_proxy_new (connection, _tmp252_ = g_strconcat (_tmp250_ = g_strconcat (MPRIS2_CONTROLLER_root_interface, ".", NULL), _tmp251_ = g_utf8_strdown (player_controller_get_name (self->priv->_owner), -1), NULL), "/org/mpris/MediaPlayer2"));
			_g_object_unref0 (_tmp253_);
			_g_free0 (_tmp252_);
			_g_free0 (_tmp251_);
			_g_free0 (_tmp250_);
			_g_free0 (_tmp249_);
			_g_free0 (_tmp248_);
			_g_free0 (_tmp247_);
			_g_free0 (_tmp246_);
			g_signal_connect_object (self->priv->_player, "seeked", (GCallback) _mpris2_controller_onSeeked_mpris_player_seeked, self, 0);
			mpris2_controller_set_properties_interface (self, _tmp260_ = free_desktop_properties_dbus_proxy_new (connection, _tmp259_ = g_strconcat (_tmp257_ = g_strconcat (MPRIS2_CONTROLLER_root_interface, ".", NULL), _tmp258_ = g_utf8_strdown (player_controller_get_name (self->priv->_owner), -1), NULL), "/org/mpris/MediaPlayer2"));
			_g_object_unref0 (_tmp260_);
			_g_free0 (_tmp259_);
			_g_free0 (_tmp258_);
			_g_free0 (_tmp257_);
			_g_free0 (_tmp256_);
			_g_free0 (_tmp255_);
			_g_free0 (_tmp254_);
			g_signal_connect_object (self->priv->_properties_interface, "properties-changed", (GCallback) _mpris2_controller_property_changed_cb_free_desktop_properties_properties_changed, self, 0);
			_dbus_g_connection_unref0 (connection);
		}
		goto __finally7;
		__catch7_dbus_gerror:
		{
			GError * e;
			e = _inner_error_;
			_inner_error_ = NULL;
			{
				g_error ("mpris2-controller.vala:92: Problems connecting to the session bus - %s", e->message);
				_g_error_free0 (e);
			}
		}
		__finally7:
		if (_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
		}
	}
	return obj;
}


static void mpris2_controller_class_init (Mpris2ControllerClass * klass) {
	mpris2_controller_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (Mpris2ControllerPrivate));
	G_OBJECT_CLASS (klass)->get_property = mpris2_controller_get_property;
	G_OBJECT_CLASS (klass)->set_property = mpris2_controller_set_property;
	G_OBJECT_CLASS (klass)->constructor = mpris2_controller_constructor;
	G_OBJECT_CLASS (klass)->finalize = mpris2_controller_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), MPRIS2_CONTROLLER_MPRIS2_ROOT, g_param_spec_object ("mpris2-root", "mpris2-root", "mpris2-root", TYPE_MPRIS_ROOT, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MPRIS2_CONTROLLER_PLAYER, g_param_spec_object ("player", "player", "player", TYPE_MPRIS_PLAYER, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MPRIS2_CONTROLLER_OWNER, g_param_spec_object ("owner", "owner", "owner", TYPE_PLAYER_CONTROLLER, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MPRIS2_CONTROLLER_PROPERTIES_INTERFACE, g_param_spec_object ("properties-interface", "properties-interface", "properties-interface", TYPE_FREE_DESKTOP_PROPERTIES, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
}


static void mpris2_controller_instance_init (Mpris2Controller * self) {
	self->priv = MPRIS2_CONTROLLER_GET_PRIVATE (self);
}


static void mpris2_controller_finalize (GObject* obj) {
	Mpris2Controller * self;
	self = MPRIS2_CONTROLLER (obj);
	_g_object_unref0 (self->priv->_mpris2_root);
	_g_object_unref0 (self->priv->_player);
	_g_object_unref0 (self->priv->_owner);
	_g_object_unref0 (self->priv->_properties_interface);
	G_OBJECT_CLASS (mpris2_controller_parent_class)->finalize (obj);
}


GType mpris2_controller_get_type (void) {
	static volatile gsize mpris2_controller_type_id__volatile = 0;
	if (g_once_init_enter (&mpris2_controller_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (Mpris2ControllerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) mpris2_controller_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Mpris2Controller), 0, (GInstanceInitFunc) mpris2_controller_instance_init, NULL };
		GType mpris2_controller_type_id;
		mpris2_controller_type_id = g_type_register_static (G_TYPE_OBJECT, "Mpris2Controller", &g_define_type_info, 0);
		g_once_init_leave (&mpris2_controller_type_id__volatile, mpris2_controller_type_id);
	}
	return mpris2_controller_type_id__volatile;
}


static void mpris2_controller_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	Mpris2Controller * self;
	self = MPRIS2_CONTROLLER (object);
	switch (property_id) {
		case MPRIS2_CONTROLLER_MPRIS2_ROOT:
		g_value_set_object (value, mpris2_controller_get_mpris2_root (self));
		break;
		case MPRIS2_CONTROLLER_PLAYER:
		g_value_set_object (value, mpris2_controller_get_player (self));
		break;
		case MPRIS2_CONTROLLER_OWNER:
		g_value_set_object (value, mpris2_controller_get_owner (self));
		break;
		case MPRIS2_CONTROLLER_PROPERTIES_INTERFACE:
		g_value_set_object (value, mpris2_controller_get_properties_interface (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void mpris2_controller_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	Mpris2Controller * self;
	self = MPRIS2_CONTROLLER (object);
	switch (property_id) {
		case MPRIS2_CONTROLLER_MPRIS2_ROOT:
		mpris2_controller_set_mpris2_root (self, g_value_get_object (value));
		break;
		case MPRIS2_CONTROLLER_PLAYER:
		mpris2_controller_set_player (self, g_value_get_object (value));
		break;
		case MPRIS2_CONTROLLER_OWNER:
		mpris2_controller_set_owner (self, g_value_get_object (value));
		break;
		case MPRIS2_CONTROLLER_PROPERTIES_INTERFACE:
		mpris2_controller_set_properties_interface (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static int _vala_strcmp0 (const char * str1, const char * str2) {
	if (str1 == NULL) {
		return -(str1 != str2);
	}
	if (str2 == NULL) {
		return str1 != str2;
	}
	return strcmp (str1, str2);
}



static void g_cclosure_user_marshal_VOID__INT64 (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__INT64) (gpointer data1, gint64 arg_1, gpointer data2);
	register GMarshalFunc_VOID__INT64 callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 2);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__INT64) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_int64 (param_values + 1), data2);
}


static void g_cclosure_user_marshal_VOID__STRING_BOXED_BOXED_INT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__STRING_BOXED_BOXED_INT) (gpointer data1, const char* arg_1, gpointer arg_2, gpointer arg_3, gint arg_4, gpointer data2);
	register GMarshalFunc_VOID__STRING_BOXED_BOXED_INT callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 5);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_BOXED_BOXED_INT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_boxed (param_values + 2), g_value_get_boxed (param_values + 3), g_value_get_int (param_values + 4), data2);
}



